C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE STOE
OBJECT MODULE PLACED IN .\stoe.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mmac\stoe.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(..\
                    -src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mping;.
                    -.\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\mht
                    -tp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug) DEFINE(RuntimeCodeAt32KH) V
                    -ARBANKING DEBUG PRINT(.\stoe.lst) OBJECT(.\stoe.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2010       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: stoe.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: stoe.c,v $
  18           * no message
  19           *
  20           *=============================================================================
  21           */
  22          
  23          /* INCLUDE FILE DECLARATIONS */
  24          #include "ax22000.h"
  25          #include "stoe.h"
  26          #include "dma.h"
  27          #include "delay.h"
  28          #include "interrupt.h"
  29          
  30          #include "adapter.h"
  31          #include "printd.h"
  32          #include <intrins.h>
  33          #include "uart0.h"
  34          #include "at24c02.h"
  35          #include "mcpu.h"
  36          
  37          /* NAMING CONSTANT DECLARATIONS */
  38          #define XSTACKSIZE 64
  39          
  40          /* GLOBAL VARIABLES DECLARATIONS */
  41          LOCAL_STATION XDATA* PNetStation = {0};
  42          BUF_DESC_PAGE XDATA* PBDP = 0;
  43          void (*STOE_RcvCallback)(U8_T XDATA*, U16_T, U8_T); /* call eth layer rcv process
  44                                                                                                                  function. */
  45          U8_T STOE_ConnectState = 0;
  46          U8_T XDATA STOE_DROP_PKT = 0;
  47          #if STOE_WIFI_QOS_SUPPORT
  48            U8_T STOE_WiFiQosFlag = 0;
  49            U8_T STOE_WiFiQos = 0;
  50          #endif
  51          
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 2   

  52          /* LOCAL VARIABLES DECLARATIONS */
  53          static U8_T XDATA stoe_BufferSize[STOE_SOCKET_BUFFER_SIZE] _at_ STOE_BDP_START_ADDR;
  54          static U8_T XDATA stoe_InterruptStatus = 0;
  55          static U8_T stoe_DeferredCnt=0;
  56          
  57          /* LOCAL SUBPROGRAM DECLARATIONS */
  58          static void stoe_BdpInit(void);
  59          #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)
                static void stoe_InterruptEnable(void);
              #endif
  62          static void stoe_StartOperate(void);
  63          static void stoe_RcvHandle(void);
  64          static U8_T stoe_CheckLink(U8_T* pbuf);
  65          
  66          /* Reserved xstack for the functions with reenterence in bootloader and runtime code will use those functi
             -ons */
  67          U8_T XDATA xStackBuf[XSTACKSIZE] _at_ (STOE_BDP_START_ADDR-XSTACKSIZE);
  68          
  69          /*
  70           * ----------------------------------------------------------------------------
  71           * Function Name: stoe_ReadReg
  72           * Purpose:
  73           * Params:
  74           * Returns:
  75           * Note:
  76           * ----------------------------------------------------------------------------
  77           */
  78          void stoe_ReadReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  79          {
  80   1              U8_T    isr;
  81   1      
  82   1              isr = EA;
  83   1              EA = 0;
  84   1              _nop_();
  85   1              TCIR = regaddr;
  86   1              while (length--)
  87   1                      pbuf[length] = TDR;
  88   1              EA = isr;
  89   1      
  90   1      } /* End of stoe_ReadReg */
  91          
  92          /*
  93           * ----------------------------------------------------------------------------
  94           * Function Name: stoe_WriteReg
  95           * Purpose:
  96           * Params:
  97           * Returns:
  98           * Note:
  99           * ----------------------------------------------------------------------------
 100           */
 101          void stoe_WriteReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
 102          {
 103   1              U8_T    isr;
 104   1      
 105   1              isr = EA;
 106   1              EA = 0;
 107   1              while (length--)
 108   1                      TDR = pbuf[length];
 109   1              TCIR = regaddr;
 110   1              EA = isr;
 111   1      
 112   1      } /* End of stoe_WriteReg */
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 3   

 113          
 114          /*
 115           * ----------------------------------------------------------------------------
 116           * Function Name: STOE_Init
 117           * Purpose: to initial all registers and variables of STOE. 
 118           * Params: network_type -0: auto- negotiation
 119           *                                              -1: fixed 100 full speed.
 120           *                                              -2: fixed 100 half speed.
 121           *                                              -3: fixed 10 full speed.
 122           *                                              -4: fixed 10 half speed.
 123           * Returns: none
 124           * Note:
 125           * ----------------------------------------------------------------------------
 126           */
 127          void STOE_Init(U8_T network_type)
 128          {
 129   1              U8_T XDATA      temp[2];
 130   1              U8_T XDATA      value[6] = {0,0,0,0,0,0};
 131   1      #if (STOE_TRANSPARENT == STOE_NON_TRANSPARENT_MODE)
                      U8_T            index, count;
              #endif
 134   1      
 135   1      #ifdef RuntimeCodeAt32KH
 136   1              MCPU_ExecuteRuntimeFlag |= 0x01;
 137   1      #else
                      MCPU_ExecuteRuntimeFlag = 0;
              #endif
 140   1      
 141   1              /* set xmit & rcv memory. */
 142   1              stoe_BdpInit();
 143   1      
 144   1              PNetStation = &PBDP->NetStation;
 145   1      
 146   1      #if (STOE_TRANSPARENT == STOE_NON_TRANSPARENT_MODE)
                      /* clear arp table */
                      for (index = 0; index < 128 ; index++)
                      {
                              count = index * 2;
                              stoe_WriteReg(STOE_ARP_ADDR_REG, &count, 1);
                              stoe_WriteReg(STOE_ARP_DATA_REG, value, 6);
                              count = ARP_CACHE_CMD_GO;
                              stoe_WriteReg(STOE_ARP_CMD_REG, &count, 1);
                              while (count & ARP_CACHE_CMD_GO)
                                      stoe_ReadReg(STOE_ARP_CMD_REG, &count, 1);
                      }
              #endif
 159   1      
 160   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 161   1              /* Validate Subsystem ID of WCPU */
 162   1              MAC_ValidateSubsystemId();
 163   1      
 164   1              /* source IP */
 165   1              value[0] = MAC_WifiIp[0];
 166   1              value[1] = MAC_WifiIp[1];
 167   1              value[2] = MAC_WifiIp[2];
 168   1              value[3] = MAC_WifiIp[3];
 169   1              PNetStation->SecDefaultIP = *(U32_T XDATA*)value;
 170   1              PNetStation->SecStationIP = PNetStation->SecDefaultIP;
 171   1              
 172   1              stoe_WriteReg(STOE_IP_ADDR_REG, (U8_T XDATA*)&PNetStation->SecDefaultIP, 4);
 173   1      #else /* (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
                      stoe_ReadReg(STOE_IP_ADDR_REG, (U8_T XDATA*)&PNetStation->DefaultIP, 4);
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 4   

                      PNetStation->StationIP = PNetStation->DefaultIP;
              #endif
 177   1      
 178   1              /* subnet mask */
 179   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 180   1              value[0] = MAC_WifiSubMask[0];
 181   1              value[1] = MAC_WifiSubMask[1];
 182   1              value[2] = MAC_WifiSubMask[2];
 183   1              value[3] = MAC_WifiSubMask[3];
 184   1              PNetStation->SecDefaultMask = *(U32_T XDATA*)value;
 185   1              PNetStation->SecSubnetMask = PNetStation->SecDefaultMask;
 186   1              
 187   1              stoe_WriteReg(STOE_SUBNET_MASK_REG, (U8_T XDATA*)&PNetStation->SecDefaultMask, 4);
 188   1      #else /* (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
                      stoe_ReadReg(STOE_SUBNET_MASK_REG, (U8_T XDATA*)&PNetStation->DefaultMask, 4);
                      PNetStation->SubnetMask = PNetStation->DefaultMask;
              #endif
 192   1      
 193   1              /* gateway */
 194   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 195   1              PNetStation->SecDefaultGateway =
 196   1                      ((PNetStation->SecStationIP & PNetStation->SecSubnetMask) |1);
 197   1              if (PNetStation->SecStationIP == PNetStation->SecDefaultGateway)
 198   1              {
 199   2                      PNetStation->SecDefaultGateway |= (~PNetStation->SecSubnetMask);
 200   2                      PNetStation->SecDefaultGateway &= 0xfffffffe; 
 201   2              }
 202   1              PNetStation->SecGateway = PNetStation->SecDefaultGateway;
 203   1              
 204   1              stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->SecGateway, 4);
 205   1      #else /* (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
                      PNetStation->DefaultGateway =((PNetStation->StationIP &PNetStation->SubnetMask)|1);
                      if (PNetStation->StationIP == PNetStation->DefaultGateway)
                      {
                              PNetStation->DefaultGateway |= (~PNetStation->SubnetMask);
                              PNetStation->DefaultGateway &= 0xfffffffe; 
                      }
                      PNetStation->Gateway = PNetStation->DefaultGateway;
                              
                      stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->Gateway, 4);
              #endif
 216   1      
 217   1              /* set L2 control register */
 218   1      #if (STOE_TRANSPARENT == STOE_TRANSPARENT_MODE)
 219   1              temp[0] = (RX_TRANSPARENT | TX_TRANSPARENT | RX_VLAN_ENABLE);
 220   1      #else
                      temp[0] = 0;
              #endif
 223   1      
 224   1              stoe_WriteReg(STOE_L2_CTL_REG, temp, 1);
 225   1      
 226   1              /* set ARP table timeout register */
 227   1              temp[0] = STOE_ARP_TIMEOUT;
 228   1              stoe_WriteReg(STOE_ARP_TIMEOUT_REG, temp, 1);
 229   1      
 230   1              /* set L4 control register */
 231   1      #if (STOE_CHECKSUM_OFFLOAD)
 232   1              temp[0] = (DROP_CHKSUMERR_PKT | ENABLE_XMIT_CHKSUM | ENABLE_XMIT_CROSS);
 233   1      #else
                      temp[0] = ENABLE_XMIT_CROSS;
              #endif
 236   1              stoe_WriteReg(STOE_L4_CTL_REG, temp, 1);
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 5   

 237   1      
 238   1              /* set BDP point */
 239   1              temp[0] = (STOE_BDP_START_ADDR >> 16);
 240   1              temp[1] = (STOE_BDP_START_ADDR >> 8);
 241   1              stoe_WriteReg(STOE_L4_BDP_PNT_REG, temp, 2);
 242   1      
 243   1              /* receive callback function initialize to null point. */
 244   1              STOE_RcvCallback = 0;
 245   1      
 246   1              DMA_Init();
 247   1              DELAY_Init();
 248   1              MAC_Init(network_type);
 249   1      
 250   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)
                      STOE_SetGateway(PNetStation->DefaultGateway);
              #else /* (MAC_ARBIT_MODE == MAC_ARBIT_WIFI) */
 253   1              STOE_SetGateway(PNetStation->SecDefaultGateway);
 254   1      #endif
 255   1      
 256   1      } /* End of STOE_Init */
 257          
 258          /*
 259          * -----------------------------------------------------------------------------
 260           * Function Name: stoe_BdpInit
 261           * Purpose: initial Buffer Descriptor Page.
 262           * Params:
 263           * Returns:
 264           * Note:
 265           * ----------------------------------------------------------------------------
 266           */
 267          void stoe_BdpInit(void)
 268          {
 269   1              U16_T   page = (STOE_BDP_START_ADDR >> 8);
 270   1      
 271   1              PBDP = STOE_BDP_START_ADDR;
 272   1      
 273   1              // set BDP number
 274   1              PBDP->BDP_ID = 0;
 275   1      
 276   1              // set rcv buffer.
 277   1              PBDP->RSPP = page + 1;
 278   1              PBDP->REPP = page + PAGES_OF_RCV;
 279   1              PBDP->RHPR = PBDP->RSPP;
 280   1              PBDP->RTPR = PBDP->RSPP;
 281   1              PBDP->RFP = PAGES_OF_RCV;
 282   1      
 283   1              // set xmit buffer.
 284   1              PBDP->TSPP = page + 1 + PAGES_OF_RCV;
 285   1              PBDP->TEPP = page + PAGES_OF_RCV + PAGES_OF_XMIT;
 286   1              PBDP->THPR = PBDP->TSPP;
 287   1              PBDP->TTPR = PBDP->TSPP;
 288   1              PBDP->TFP = PAGES_OF_XMIT;
 289   1      
 290   1              // set rcv and xmit start/end buffer address.
 291   1              PBDP->RcvStartAddr = STOE_BDP_START_ADDR + 256;
 292   1              PBDP->XmtStartAddr = PBDP->RcvStartAddr + STOE_RCV_BUF_SIZE;
 293   1              PBDP->RcvEndAddr = PBDP->XmtStartAddr - 1;
 294   1              PBDP->XmtEndAddr = PBDP->XmtStartAddr + STOE_XMIT_BUF_SIZE - 1;
 295   1      
 296   1      } /* End of stoe_BdpInit */
 297          
 298          /*
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 6   

 299           * ----------------------------------------------------------------------------
 300           * Function Name: STOE_SetIPAddr
 301           * Purpose:
 302           * Params:      ip- IP Address
 303           * Returns:
 304           * Note:
 305           * ----------------------------------------------------------------------------
 306           */
 307          void STOE_SetIPAddr(U32_T ip)
 308          {
 309   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)   
                      if (ip != PNetStation->StationIP)
                      {
                              PNetStation->StationIP = ip;
                              stoe_WriteReg(STOE_IP_ADDR_REG, (U8_T XDATA*)&PNetStation->StationIP, 4);
                      }
              #else /* (MAC_ARBIT_MODE == MAC_ARBIT_WIFI) */
 316   1              if (ip != PNetStation->SecStationIP)
 317   1              {
 318   2                      PNetStation->SecStationIP = ip;
 319   2                      stoe_WriteReg(STOE_IP_ADDR_REG, (U8_T XDATA*)&PNetStation->SecStationIP, 4);
 320   2              }
 321   1      #endif
 322   1      } /* End of STOE_SetIPAddr*/
 323          
 324          /*
 325           * ----------------------------------------------------------------------------
 326           * Function Name: STOE_SetSubnetMask
 327           * Purpose:
 328           * Params:      subnet- Subnet Mask
 329           * Returns:
 330           * Note:
 331           * ----------------------------------------------------------------------------
 332           */
 333          void STOE_SetSubnetMask(U32_T subnet)
 334          {
 335   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)   
                      if (subnet != PNetStation->SubnetMask)
                      {
                              PNetStation->SubnetMask = subnet;
                              stoe_WriteReg(STOE_SUBNET_MASK_REG, (U8_T XDATA*)&PNetStation->SubnetMask, 4);
                      }
              #else /* (MAC_ARBIT_MODE == MAC_ARBIT_WIFI) */
 342   1              if (subnet != PNetStation->SecSubnetMask)
 343   1              {
 344   2                      PNetStation->SecSubnetMask = subnet;
 345   2                      stoe_WriteReg(STOE_SUBNET_MASK_REG, (U8_T XDATA*)&PNetStation->SecSubnetMask, 4);
 346   2              }
 347   1      #endif
 348   1      } /* End of STOE_SetSubnetMask */
 349          
 350          /*
 351           * ----------------------------------------------------------------------------
 352           * Function Name: STOE_SetGateway
 353           * Purpose:
 354           * Params:      gateway- Gateway
 355           * Returns:
 356           * Note:
 357           * ----------------------------------------------------------------------------
 358           */
 359          void STOE_SetGateway(U32_T gateway)
 360          {
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 7   

 361   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)   
                      PNetStation->Gateway = gateway;
                      if (gateway)
                      {
                              stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->Gateway, 4);
                              ETH_RestartSendArpToGateway();
                      }
                      else
                      {
                              gateway = ((PNetStation->StationIP & PNetStation->SubnetMask) | 1);
                              if (PNetStation->StationIP == gateway)
                              {
                                      gateway |= (~PNetStation->SubnetMask);
                                      gateway &= 0xfffffffe;
                                      PNetStation->Gateway = gateway;
                              }
              
                              stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->Gateway, 4);
                              }
              #else /* (MAC_ARBIT_MODE == MAC_ARBIT_WIFI) */
 381   1              PNetStation->SecGateway = gateway;
 382   1              if (gateway)
 383   1              {
 384   2                      stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->SecGateway, 4);
 385   2                      ETH_RestartSendArpToGateway();
 386   2              }
 387   1              else
 388   1              {
 389   2                      gateway = ((PNetStation->SecStationIP & PNetStation->SecSubnetMask) | 1);
 390   2                      if (PNetStation->SecStationIP == gateway)
 391   2                      {
 392   3                              gateway |= (~PNetStation->SecSubnetMask);
 393   3                              gateway &= 0xfffffffe;
 394   3                              PNetStation->SecGateway = gateway;
 395   3                      }
 396   2      
 397   2                      stoe_WriteReg(STOE_GATEWAY_IP_REG, (U8_T XDATA*)&PNetStation->SecGateway, 4);
 398   2              }
 399   1      
 400   1      #endif
 401   1      } /* End of STOE_SetGateway */
 402          
 403          /*
 404           * ----------------------------------------------------------------------------
 405           * Function Name: STOE_Start
 406           * Purpose: enable all used interrupts and set some register to start
 407           *                      timer, software-dma and processing received packets.
 408           * Params:
 409           * Returns:
 410           * Note:
 411           * ----------------------------------------------------------------------------
 412           */
 413          void STOE_Start(void)
 414          {
 415   1              U8_T XDATA      temp;
 416   1      
 417   1              /* clear interrupt status */
 418   1              stoe_ReadReg(STOE_INT_STATUS_REG, &temp, 1);
 419   1      
 420   1      #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)
                      /* enable STOE interrupt */
                      stoe_InterruptEnable();
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 8   

              #endif
 424   1      
 425   1              /* start STOE L2/L3/L4 engines*/
 426   1              stoe_StartOperate();
 427   1      
 428   1              /* start DMA module */
 429   1              DMA_Start();
 430   1      
 431   1              /* start MAC module */
 432   1              MAC_Start();
 433   1      
 434   1              EXTINT4(1);     /* Enable INT4 interrupt for stoe & mac modules. */
 435   1      
 436   1      } /* End of STOE_Start */
 437          
 438          #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)
              /*
               * ----------------------------------------------------------------------------
               * Function Name: stoe_InterruptEnable
               * Purpose: enable STOE used interrupt
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void stoe_InterruptEnable(void)
              {
                      U8_T XDATA      temp;
              
                      temp = STOE_DEFAULT_INT_MASK;
                      stoe_WriteReg(STOE_INT_MASK_REG, &temp, 1);
              
              } /* End of stoe_InterruptEnable */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: stoe_InterruptDisable
               * Purpose: disable STOE used interrupt
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void stoe_InterruptDisable(void)
              {
                      U8_T XDATA      temp;
              
                      temp = 0;
                      stoe_WriteReg(STOE_INT_MASK_REG, &temp, 1);
              
              } /* End of stoe_InterruptDisable */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: STOE_SetInterruptFlag
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void STOE_SetInterruptFlag(void)
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 9   

              {
                      U8_T XDATA      int_status;
              
                      /* disable stoe interrupt*/
                      stoe_InterruptDisable();
              
                      /* read stoe interrupt status */
                      stoe_ReadReg(STOE_INT_STATUS_REG, &int_status, 1);
              
                      stoe_InterruptStatus = (int_status & STOE_DEFAULT_INT_MASK);
              
              } /* End of STOE_SetInterruptFlag */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: STOE_GetInterruptFlag
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T STOE_GetInterruptFlag(void)
              {
                      return stoe_InterruptStatus;
              
              } /* End of STOE_GetInterruptFlag */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: STOE_ProcessInterrupt
               * Purpose: When STOE interrupt is trigged, programmer can call this function
               *                      to process interrupt event. 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void STOE_ProcessInterrupt(void)
              {
                      U8_T XDATA      temp;
                      U8_T            isr = EA;
              
                      while (stoe_InterruptStatus)
                      {
                              EA = isr;
              
                              if (stoe_InterruptStatus & RCV_PACKET)
                              {
                                      while (PBDP->RFP < PAGES_OF_RCV)
                                              stoe_RcvHandle();
                              }
                              if (stoe_InterruptStatus & RCV_BUF_RING_FULL)
                              {
                                      temp = RESUME_PKT_RCV;
                                      stoe_WriteReg(STOE_L4_CMD_REG, &temp, 1);
                              }
              
                              isr = EA;
                              EA = 0;
              
                              /* read stoe interrupt status */
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 10  

                              stoe_ReadReg(STOE_INT_STATUS_REG, &stoe_InterruptStatus, 1);
                              stoe_InterruptStatus &= STOE_DEFAULT_INT_MASK;
                      }
              
                      /* enable stoe interrupt */
                      stoe_InterruptEnable();
                      EA = isr;
              
              } /* End of STOE_ProcessInterrupt() */
              #else
 557          /*
 558           * ----------------------------------------------------------------------------
 559           * Function Name: STOE_ProcessInterrupt
 560           * Purpose: programmer can call this function by polling type to find that
 561           *                      interrupt event had happened.
 562           * Params:
 563           * Returns:
 564           * Note:
 565           * ----------------------------------------------------------------------------
 566           */
 567          void STOE_ProcessInterrupt(void)
 568          {
 569   1              U8_T XDATA                      temp;
 570   1              U8_T                            stoe_Page;
 571   1              static U8_T                     count;
 572   1      
 573   1              count = 0;
 574   1              
 575   1              EMDMR = BIT5;
 576   1              stoe_Page = PBDP->RFP;
 577   1              EMDMR = 0; 
 578   1              while (stoe_Page < PAGES_OF_RCV)
 579   1              {
 580   2                      stoe_RcvHandle();
 581   2      
 582   2                      if (++count > 3)
 583   2                      {
 584   3                              break;
 585   3                      }
 586   2      
 587   2                      EMDMR = BIT5;
 588   2                      stoe_Page = PBDP->RFP;
 589   2                      EMDMR = 0; 
 590   2              }
 591   1      
 592   1              /* read stoe interrupt status */
 593   1              stoe_ReadReg(STOE_INT_STATUS_REG, &stoe_InterruptStatus, 1);
 594   1      
 595   1              if (stoe_InterruptStatus & RCV_BUF_RING_FULL)
 596   1              {
 597   2                      temp = RESUME_PKT_RCV;
 598   2                      stoe_WriteReg(STOE_L4_CMD_REG, &temp, 1);
 599   2              }
 600   1      }
 601          
 602          #endif
 603          
 604          /*
 605           * ----------------------------------------------------------------------------
 606           * Function Name: stoe_StartOperate
 607           * Purpose: start L2/L3/L4 engine
 608           * Params:
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 11  

 609           * Returns:
 610           * Note:
 611           * ----------------------------------------------------------------------------
 612           */
 613          void stoe_StartOperate(void)
 614          {
 615   1              U8_T XDATA      temp;
 616   1      
 617   1              stoe_ReadReg(STOE_L2_CTL_REG, &temp, 1);
 618   1      
 619   1              temp |= (RX_START_OPERA | TX_START_OPERA);
 620   1              stoe_WriteReg(STOE_L2_CTL_REG, &temp, 1);
 621   1      
 622   1      } /* End of stoe_StartOperate */
 623          
 624          #if 0
              /*
               * ----------------------------------------------------------------------------
               * Function Name: stoe_StopOperate
               * Purpose: stop L2/L3/L4 engine
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void stoe_StopOperate(void)
              {
                      U8_T XDATA      temp;
              
                      stoe_ReadReg(STOE_L2_CTL_REG, &temp, 1);
              
                      Temp &= ~(RX_START_OPERA | TX_START_OPERA);
                      stoe_WriteReg(STOE_L2_CTL_REG, &temp, 1);
              
              } /* End of stoe_StopOperate */
              #endif
 645          
 646          /*
 647          * -----------------------------------------------------------------------------
 648           * Function Name: stoe_RcvHandle
 649           * Purpose: 
 650           * Params: 
 651           * Returns:
 652           * Note:
 653           * ----------------------------------------------------------------------------
 654           */
 655          void stoe_RcvHandle(void)
 656          {
 657   1              static STOE_FRAME_HEADER XDATA* pframe;
 658   1              U16_T   length;
 659   1              U8_T    pages;
 660   1      
 661   1              pframe = ((PBDP->RHPR) << 8);
 662   1              length = (pframe->Length & 0x7ff);
 663   1      
 664   1              if (length > 1536)
 665   1              {
 666   2                      return;
 667   2              }
 668   1      
 669   1              PBDP->STOE_RxInform.Protocol = pframe->Protocol;
 670   1              PBDP->STOE_RxInform.TotalLen = length;
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 12  

 671   1              PBDP->STOE_RxInform.PBuf = &pframe->Packet;
 672   1      
 673   1              if (length && STOE_RcvCallback)
 674   1                      STOE_RcvCallback(&pframe->Packet, length, pframe->Protocol);
 675   1      
 676   1              if (PBDP->RHPR > pframe->NPR)
 677   1                      pages = (PBDP->TSPP - PBDP->RHPR) + (pframe->NPR - PBDP->RSPP);
 678   1              else
 679   1                      pages = pframe->NPR - PBDP->RHPR;
 680   1      
 681   1              EMDMR = BIT5;
 682   1              PBDP->RHPR = pframe->NPR;
 683   1              PBDP->RFP += pages;
 684   1              EMDMR = 0;
 685   1      
 686   1      } /* End of stoe_RcvHandle() */
 687          
 688          /*
 689          * -----------------------------------------------------------------------------
 690           * Function Name: stoe_XmitHandle
 691           * Purpose: Set send packet bit to tell hardware transmit one packet to ethernet.
 692           * Params: 
 693           * Returns:     
 694           * Note:
 695           * ----------------------------------------------------------------------------
 696           */
 697          void stoe_XmitHandle(void)
 698          {
 699   1              U8_T XDATA      temp;
 700   1      
 701   1          /* Check the tx available */
 702   1          stoe_ReadReg(STOE_L4_CMD_REG, &temp, 1);
 703   1          if (!(temp & XMIT_PACKET))
 704   1          {
 705   2              temp = XMIT_PACKET;
 706   2              stoe_WriteReg(STOE_L4_CMD_REG, &temp, 1);
 707   2          }
 708   1          else
 709   1              stoe_DeferredCnt++;
 710   1      
 711   1      } /* stoe_XmitHandle */
 712          
 713          /*
 714          * -----------------------------------------------------------------------------
 715           * Function Name: STOE_DeferredProcess
 716           * Purpose: Check the packet was deferred and send it if the tx is available.
 717           * Params: 
 718           * Returns:     
 719           * Note:
 720           * ----------------------------------------------------------------------------
 721           */
 722          void STOE_DeferredProcess(void)
 723          {
 724   1              U8_T XDATA      temp;
 725   1      
 726   1          if (stoe_DeferredCnt)
 727   1          {
 728   2              /* Check the tx available */
 729   2              stoe_ReadReg(STOE_L4_CMD_REG, &temp, 1);
 730   2              if (!(temp & XMIT_PACKET))
 731   2              {
 732   3                  temp = XMIT_PACKET;
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 13  

 733   3                  stoe_WriteReg(STOE_L4_CMD_REG, &temp, 1);
 734   3                  stoe_DeferredCnt--;
 735   3              }
 736   2          }
 737   1      } /* STOE_DeferredProcess */
 738          
 739          /*
 740          * -----------------------------------------------------------------------------
 741           * Function Name: STOE_Send
 742           * Purpose:     Call this function to set add STOE header.
 743           * Params:      pbuf : buffer address, must between TSPP and TEPP.
 744           *                      length : packet length.
 745           *                      protocol : if the packet is ip packet, set the ip layer protocol,
 746           *                                              if not a ip packet, set value to 0xff.
 747           * Returns:
 748           * Note:
 749           * ----------------------------------------------------------------------------
 750           */
 751          void STOE_Send(U8_T XDATA* pbuf, U16_T length, U8_T protocol)
 752          {
 753   1              STOE_FRAME_HEADER XDATA*        pframe = (STOE_FRAME_HEADER XDATA*)pbuf;
 754   1              U8_T    occupypages = PBDP->STOE_TxInform.Pages;
 755   1      
 756   1              pframe->Length = length;
 757   1              pframe->Protocol = protocol;
 758   1      
 759   1              EMDMR = BIT5;
 760   1              PBDP->TFP -= occupypages;
 761   1      
 762   1              PBDP->TTPR += occupypages;
 763   1              if (PBDP->TTPR > PBDP->TEPP)
 764   1              {
 765   2                      PBDP->TTPR = PBDP->TSPP + PBDP->TTPR - PBDP->TEPP - 1;
 766   2              }
 767   1              EMDMR = 0;
 768   1      
 769   1              pframe->NPR = PBDP->TTPR;
 770   1      
 771   1              stoe_XmitHandle();
 772   1      
 773   1      } /* End of STOE_Send() */
 774          
 775          
 776          /*
 777          * -----------------------------------------------------------------------------
 778           * Function Name: STOE_AssignSendBuf
 779           * Purpose: Assign a buffer that adress is between TSPP and TEPP, so STOE engine
 780           *                              cans transmit the packet to MAC SRAM.
 781           * Params: length : Buffer size that the packet occupied.
 782           * Returns: Assigned transmit buffer address
 783           * Note:
 784           * ----------------------------------------------------------------------------
 785           */
 786          U8_T XDATA* STOE_AssignSendBuf(U16_T length)
 787          {
 788   1              U8_T XDATA*     pframe;
 789   1              U8_T            occupypages;
 790   1      
 791   1              occupypages = ((length + PAGE_SIZE - 1)/PAGE_SIZE);
 792   1              if (PBDP->TFP <= occupypages)
 793   1          {
 794   2                      return (U8_T XDATA*)0;
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 14  

 795   2          }
 796   1      
 797   1              pframe = ((PBDP->TTPR) << 8);
 798   1              PBDP->STOE_TxInform.Pages = occupypages;
 799   1      
 800   1              return pframe;
 801   1      
 802   1      } /* End of STOE_AssignSendBuf */
 803          
 804          #if STOE_DEBUG
 805          /*
 806           * ----------------------------------------------------------------------------
 807           * Function Name: STOE_IndirectIO
 808           * Purpose: stoe indirect register read/write, only for debugging.
 809           * Params:
 810           * Returns:
 811           * Note:
 812           * ----------------------------------------------------------------------------
 813           */
 814          U8_T STOE_IndirectIO(U8_T rw, U16_T index, U8_T XDATA* pbuf)
 815          {
 816   1              U8_T len;
 817   1      
 818   1              switch (index)
 819   1              {
 820   2              case STOE_ARP_DATA_REG:
 821   2                      len = 6;
 822   2                      break;
 823   2              case STOE_IP_ADDR_REG:
 824   2                      if (rw == 1)
 825   2                              STOE_SetIPAddr(*(U32_T XDATA*)pbuf);
 826   2                      len = 4;
 827   2                      break;
 828   2              case STOE_SUBNET_MASK_REG:
 829   2                      if (rw == 1)
 830   2                              STOE_SetSubnetMask(*(U32_T XDATA*)pbuf);
 831   2                      len = 4;
 832   2                      break;
 833   2              case STOE_GATEWAY_IP_REG:
 834   2                      if (rw == 1)
 835   2                              STOE_SetGateway(*(U32_T XDATA*)pbuf);
 836   2                      len = 4;
 837   2                      break;
 838   2              case STOE_RX_VLAN_TAG_REG:
 839   2              case STOE_TX_VLAN_TAG_REG:
 840   2              case STOE_L4_BDP_PNT_REG:
 841   2                      len = 2;
 842   2                      break;
 843   2              case STOE_L2_CTL_REG:
 844   2              case STOE_BYPASS_REG:
 845   2              case STOE_ARP_CMD_REG:
 846   2              case STOE_ARP_ADDR_REG:
 847   2              case STOE_ARP_TIMEOUT_REG:
 848   2              case STOE_CHKSUM_STATUS_REG:
 849   2              case STOE_L4_CTL_REG:
 850   2              case STOE_L4_CMD_REG:
 851   2              case STOE_L4_DMA_BURST_REG:
 852   2              case STOE_INT_STATUS_REG:
 853   2              case STOE_INT_MASK_REG:
 854   2                      len = 1;
 855   2                      break;
 856   2              default:
C51 COMPILER V9.01   STOE                                                                  03/08/2012 11:01:03 PAGE 15  

 857   2                      return 0xff;
 858   2              }
 859   1      
 860   1              if (rw == 0) /* read */
 861   1                      stoe_ReadReg (index, pbuf, len);
 862   1              else if (rw == 1) /* write */
 863   1                      stoe_WriteReg (index, pbuf, len);
 864   1              else
 865   1                      return 0xff;
 866   1      
 867   1              return  len;
 868   1      
 869   1      } /* End of STOE_IndirectIO() */
 870          #endif
 871          
 872          /* End of stoe.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3928    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     16      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
