C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DHCPS
OBJECT MODULE PLACED IN .\dhcps.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mdhcps\dhcps.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(
                    -..\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mpin
                    -g;..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\
                    -mhttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug) DEFINE(RuntimeCodeAt32KH
                    -) VARBANKING DEBUG PRINT(.\dhcps.lst) OBJECT(.\dhcps.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2010   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : dhcps.c
  13           * Purpose     : DHCP Server module implement DHCP server function over uIP stack.
  14           *               module.
  15           * Author      :
  16           * Date        :
  17           * Notes       :
  18           * $Log: dhcps.c,v $
  19           *
  20           *================================================================================
  21           */
  22          
  23          /* INCLUDE FILE DECLARATIONS */
  24          #include <string.h>
  25          #include "main.h"
  26          #include "dhcps.h"
  27          #include "adapter.h"
  28          #include "tcpip.h"
  29          #include "uip.h"
  30          #include "mstimer.h"
  31          #include "dma.h"
  32          #include "stoe.h"
  33          
  34          #if (INCLUDE_DHCP_SERVER)
  35          /* NAMING CONSTANT DECLARATIONS */
  36          /* GLOBAL VARIABLES DECLARATIONS */
  37          U8_T DHCPS_EnableFlag = 0xFF;
  38          U32_T DHCPS_IpPoolStartAddr = 0;
  39          U32_T DHCPS_IpPoolEndAddr = 0;
  40          U32_T DHCPS_SubnetMask = 0;
  41          U32_T DHCPS_Router = 0;
  42          U16_T DHCPS_LeaseTime = 0;
  43          
  44          /* STATIC VARIABLE DECLARATIONS */
  45          static DHCPS_CONN     dhcps_Conn;
  46          static DHCPS_CONNINFO dhcps_ConnsInfo[DHCPS_MAX_STA_CONNS];
  47          static DHCPS_POOL         dhcps_IpPoolTable[DHCPS_MAX_IP_POOL_NUM];
  48          static DHCPS_HEADER       dhcps_Buffer;
  49          static U8_T               dhcps_AppIfId;
  50          static U8_T               dhcps_CurrConnId;
  51          static U16_T          dhcps_RcvPktLength;
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 2   

  52          static U16_T          dhcps_RcvPktLeftLength;
  53          static DHCPS_HEADER   *dhcps_PktHeaderPtr;
  54          static U8_T *dhcps_pOpt;
  55          static U8_T dhcps_StartIpOffset=0;
  56          static U16_T dhcps_MaxIpPool=0;
  57          static U32_T dhcps_LastTimeTick = 0;
  58          static U8_T dhcps_Init=0;
  59          static U32_T dhcps_DnsServer = 0;
  60          
  61          /* LOCAL SUBPROGRAM DECLARATIONS */
  62          static void dhcps_SendPkt(U8_T pktType);
  63          static void dhcps_ReceiveMessage(void);
  64          static U8_T dhcps_FindConnInfoIndex(U8_T* pMacAddr);
  65          static U8_T *dhcps_GetOption(U8_T *optMsg, U8_T msgCode, U8_T *vLen, U16_T);
  66          static U8_T dhcps_FindIpPoolByIpAddr(U32_T ipAddr);
  67          static U8_T dhcps_FindIpPoolByMacAddr(U8_T* pMacAddr);
  68          static U8_T dhcps_CreateNewElementToIpPool(U32_T ipAddr, U8_T* pMacAddr);
  69          
  70          /*
  71           *--------------------------------------------------------------------------------
  72           * Function Name: DHCPS_Init
  73           * Purpose :
  74           * Params  :
  75           * Returns :
  76           * Note    :
  77           *--------------------------------------------------------------------------------
  78           */
  79          BOOL DHCPS_Init(U32_T startIp, U32_T endIp, U32_T netmask, U32_T gateway, U16_T lease, U8_T status)
  80          {
  81   1              U8_T index;
  82   1      
  83   1          if (dhcps_Init)
  84   1              return TRUE;
  85   1      
  86   1          dhcps_Init = 1;
  87   1          dhcps_Conn.State = DHCPS_STATE_IDLE;
  88   1          for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
  89   1              dhcps_ConnsInfo[index].State = DHCPS_STATE_IDLE;
  90   1      
  91   1          /* Initialize DHCP Server IP Pool Table */
  92   1          for (index = 0; index < DHCPS_MAX_IP_POOL_NUM; index++) 
  93   1          {
  94   2              dhcps_IpPoolTable[index].Occupy = 0;
  95   2          }
  96   1      
  97   1          dhcps_AppIfId = TCPIP_Bind(DHCPS_NewConnHandle, DHCPS_EventHandle, DHCPS_ReceiveHandle);
  98   1          TCPIP_UdpListen(DHCPS_SERVER_PORT, dhcps_AppIfId); /* Enable DHCP Server Listen Port */
  99   1      
 100   1          DHCPS_IpPoolStartAddr = startIp;
 101   1          DHCPS_IpPoolEndAddr = endIp;
 102   1          DHCPS_SubnetMask = netmask;
 103   1          DHCPS_Router = gateway;
 104   1          DHCPS_LeaseTime = lease;
 105   1      
 106   1          dhcps_MaxIpPool = DHCPS_IpPoolEndAddr - DHCPS_IpPoolStartAddr + 1;
 107   1          if (dhcps_MaxIpPool > DHCPS_MAX_IP_POOL_NUM)
 108   1              dhcps_MaxIpPool = DHCPS_MAX_IP_POOL_NUM;
 109   1              
 110   1          DHCPS_EnableFlag = status;        
 111   1      
 112   1              return TRUE;
 113   1      
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 3   

 114   1      } /* End of DHCPS_Init() */
 115          
 116          /*
 117           *--------------------------------------------------------------------------------
 118           * Function Name: DHCPS_GetServerSettings
 119           * Purpose :
 120           * Params  :
 121           * Returns :
 122           * Note    :
 123           *--------------------------------------------------------------------------------
 124           */
 125          void DHCPS_GetServerSettings(U32_T *pStartIp, U32_T *pEndIp, U32_T *pNetmask, U32_T *pGateway, U16_T *pLea
             -se)
 126          {
 127   1          if (!pStartIp || !pEndIp || !pNetmask || !pGateway || !pLease)
 128   1              return;
 129   1      
 130   1          *pStartIp = DHCPS_IpPoolStartAddr;
 131   1          *pEndIp = DHCPS_IpPoolEndAddr;
 132   1          *pNetmask = DHCPS_SubnetMask;
 133   1          *pGateway = DHCPS_Router;
 134   1          *pLease = DHCPS_LeaseTime;
 135   1          
 136   1      } /* End of DHCPS_GetServerSettings() */
 137          
 138          /*
 139           *--------------------------------------------------------------------------------
 140           * Function Name: DHCPS_SetServerSettings
 141           * Purpose :
 142           * Params  :
 143           * Returns :
 144           * Note    :
 145           *--------------------------------------------------------------------------------
 146           */
 147          void DHCPS_SetServerSettings(U32_T startIp, U32_T endIp, U32_T netmask, U32_T gateway, U16_T lease)
 148          {
 149   1          if (!dhcps_Init)
 150   1              return;
 151   1      
 152   1          DHCPS_IpPoolStartAddr = startIp;
 153   1          DHCPS_IpPoolEndAddr = endIp; 
 154   1          DHCPS_SubnetMask = netmask;
 155   1          DHCPS_Router = gateway;
 156   1          DHCPS_LeaseTime = lease;
 157   1      
 158   1          dhcps_MaxIpPool = DHCPS_IpPoolEndAddr - DHCPS_IpPoolStartAddr + 1;
 159   1          if (dhcps_MaxIpPool > DHCPS_MAX_IP_POOL_NUM)
 160   1              dhcps_MaxIpPool = DHCPS_MAX_IP_POOL_NUM;
 161   1          
 162   1      } /* End of DHCPS_SetServerSettings() */
 163          
 164          /*
 165           *--------------------------------------------------------------------------------
 166           * Function Name: DHCPS_SetServerStatus
 167           * Purpose :
 168           * Params  :
 169           * Returns :
 170           * Note    :
 171           *--------------------------------------------------------------------------------
 172           */
 173          void DHCPS_SetServerStatus(U8_T status)
 174          {
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 4   

 175   1          DHCPS_EnableFlag = status;
 176   1      } /* End of DHCPS_SetServerStatus() */
 177          
 178          /*
 179           *--------------------------------------------------------------------------------
 180           * Function Name: DHCPS_GetServerStatus
 181           * Purpose :
 182           * Params  :
 183           * Returns :
 184           * Note    :
 185           *--------------------------------------------------------------------------------
 186           */
 187          U8_T DHCPS_GetServerStatus(void)
 188          {
 189   1          return DHCPS_EnableFlag ;
 190   1      } /* End of DHCPS_GetServerStatus() */
 191          
 192          /*
 193           *--------------------------------------------------------------------------------
 194           * Function Name: DHCPS_SetDnsServer
 195           * Purpose :
 196           * Params  :
 197           * Returns :
 198           * Note    :
 199           *--------------------------------------------------------------------------------
 200           */
 201          void DHCPS_SetDnsServer(U32_T dnsSrv)
 202          {
 203   1          dhcps_DnsServer = dnsSrv;
 204   1      } /* End of DHCPS_SetDnsServer() */
 205          
 206          /*
 207           * ----------------------------------------------------------------------------
 208           * Function Name: DHCPS_NewConnHandle
 209           * Purpose: 
 210           * Params:
 211           * Returns:
 212           * Note:
 213           * ----------------------------------------------------------------------------
 214           */
 215          U8_T DHCPS_NewConnHandle(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 216          {
 217   1              if (!DHCPS_EnableFlag || DHCPS_CLIENT_PORT != remotePort) /* frame not from DHCP client. */
 218   1                      return TCPIP_NO_NEW_CONN;
 219   1      
 220   1              if (dhcps_Conn.State == DHCPS_STATE_IDLE)
 221   1              {
 222   2                      dhcps_Conn.State = DHCPS_STATE_ACTIVE;
 223   2                      dhcps_Conn.Ip = *pip;
 224   2                      dhcps_Conn.SocketId = socket;
 225   2      
 226   2                      return 0;
 227   2              }
 228   1      
 229   1              return TCPIP_NO_NEW_CONN;
 230   1      } /* End of DHCPS_NewConnHandle() */
 231          
 232          /*
 233           * ----------------------------------------------------------------------------
 234           * void DHCPS_EventHandle(U8_T connId, U8_T event)
 235           * Purpose: 
 236           * Params:
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 5   

 237           * Returns:
 238           * Note:
 239           * ----------------------------------------------------------------------------
 240           */
 241          void DHCPS_EventHandle(U8_T connId, U8_T event)
 242          {
 243   1              if (!DHCPS_EnableFlag || connId != 0)
 244   1                      return;
 245   1      
 246   1              if (event == TCPIP_CONNECT_CANCEL)
 247   1              {
 248   2                      dhcps_Conn.State = DHCPS_STATE_IDLE;
 249   2              }
 250   1      } /* End of DHCPS_EventHandle() */
 251          
 252          /*
 253           * ----------------------------------------------------------------------------
 254           * void DHCPS_ReceiveHandle(U8_T XDATA* pData, U16_T length, U8_T connId)
 255           * Purpose: 
 256           * Params:
 257           * Returns:
 258           * Note:
 259           * ----------------------------------------------------------------------------
 260           */
 261          void DHCPS_ReceiveHandle(U8_T XDATA *pData, U16_T length, U8_T connId)
 262          {
 263   1          if (!DHCPS_EnableFlag)
 264   1              return;
 265   1      
 266   1              if ((connId != 0) || (dhcps_Conn.State == DHCPS_STATE_IDLE)) /* connection has not be created */
 267   1              {
 268   2                      TCPIP_UdpClose(dhcps_Conn.SocketId);
 269   2                      return;
 270   2              }
 271   1      
 272   1              dhcps_RcvPktLength = length;
 273   1              dhcps_RcvPktLeftLength = length;
 274   1              dhcps_PktHeaderPtr = (DHCPS_HEADER*)pData;
 275   1      
 276   1              dhcps_ReceiveMessage();
 277   1          TCPIP_UdpClose(dhcps_Conn.SocketId);
 278   1          dhcps_Conn.State = DHCPS_STATE_IDLE;
 279   1      
 280   1      } /* End of DHCPS_ReceiveHandle() */
 281          
 282          /*
 283           *--------------------------------------------------------------------------------
 284           * Function Name: dhcps_ReceiveMessage
 285           * Purpose :
 286           * Params  :
 287           * Returns :
 288           * Note    :
 289           *--------------------------------------------------------------------------------
 290           */
 291          void dhcps_ReceiveMessage(void)
 292          {
 293   1              DHCPS_HEADER *pDhcpMsg;
 294   1              U8_T         *optMsg, ipPoolIndex, dhcpMsgType = 0;
 295   1              U8_T         index, rcvChAddr[6], foundInIpPool = 0;
 296   1              U32_T        requestIp = 0;
 297   1      
 298   1              pDhcpMsg = dhcps_PktHeaderPtr; /* DHCP payload pointer */
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 6   

 299   1      
 300   1              /* calculate the options item length */
 301   1              dhcps_RcvPktLeftLength -= DHCPS_OFFSET_OPTIONS;
 302   1              dhcps_pOpt = pDhcpMsg->Options;
 303   1      
 304   1              if (pDhcpMsg->Op == DHCP_C_TO_S)
 305   1              {
 306   2                      for (index = 0 ; index < DHCPS_MAC_ADDRESS_LEN; index++)
 307   2                              rcvChAddr[index] = pDhcpMsg->ChAddr[index];
 308   2      
 309   2                      /* check the received MAC address within ChAddr, except 00-00-00-00-00-00 & FF-FF-FF-FF-FF-FF */
 310   2                      if ((rcvChAddr[0]==0 && rcvChAddr[1]==0 && rcvChAddr[2]==0 && rcvChAddr[3]==0 &&
 311   2                              rcvChAddr[4]==0 && rcvChAddr[5]==0)||(rcvChAddr[0]==0xFF && rcvChAddr[1]==0xFF &&
 312   2                              rcvChAddr[2]==0xFF && rcvChAddr[3]==0xFF && rcvChAddr[4]==0xFF && rcvChAddr[5]==0xFF))
 313   2                      {
 314   3                              return;
 315   3                      }
 316   2      
 317   2                      dhcps_CurrConnId = dhcps_FindConnInfoIndex(rcvChAddr);
 318   2                      if (dhcps_CurrConnId == 0xFF)
 319   2              {
 320   3                              return;
 321   3              }
 322   2      
 323   2                      dhcps_ConnsInfo[dhcps_CurrConnId].Timer = DHCPS_CONNECTION_TIMEOUT;
 324   2                      if (dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE)
 325   2                      {
 326   3                              dhcps_ConnsInfo[dhcps_CurrConnId].Xid = pDhcpMsg->Xid;
 327   3                      }
 328   2                      else /* DHCPS_OFFER_STATE */
 329   2                      {
 330   3                              if (dhcps_ConnsInfo[dhcps_CurrConnId].Xid != pDhcpMsg->Xid)
 331   3                              {
 332   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].Xid = pDhcpMsg->Xid;
 333   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_ACTIVE;
 334   4                              }
 335   3                      }
 336   2      
 337   2                      if ((*(dhcps_pOpt + 0) == 0x63) && (*(dhcps_pOpt + 1) == 0x82) &&
 338   2                              (*(dhcps_pOpt + 2) == 0x53) && (*(dhcps_pOpt + 3) == 0x63))
 339   2                      {
 340   3                              dhcps_pOpt += 4;
 341   3                              dhcps_RcvPktLeftLength -= 4;
 342   3      
 343   3                              index = 0;
 344   3                              optMsg = dhcps_GetOption(dhcps_pOpt, DHCPS_OPTION_MSG_TYPE, &index, dhcps_RcvPktLeftLength);
 345   3                              if (optMsg && index == 1)
 346   3                                      dhcpMsgType = *optMsg;
 347   3      
 348   3                              if ((dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE) && (dhcpMsgType != DHCPS_DISCOVER))
 349   3                              {
 350   4                                      if (dhcpMsgType == DHCPS_REQUEST)
 351   4                                      {
 352   5                          dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_OFFER;
 353   5                                      }
 354   4                                      else
 355   4                                      {
 356   5                                              return;
 357   5                                      }
 358   4                              }
 359   3                  else if ((dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_OFFER) && (dhcpMsgType != DHC
             -PS_REQUEST))
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 7   

 360   3                              {
 361   4                                      if (dhcpMsgType == DHCPS_DISCOVER)
 362   4                                      {
 363   5                                              dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_ACTIVE;
 364   5                                      }
 365   4                                      else if (dhcpMsgType == DHCPS_DECLINE)
 366   4                                      {
 367   5                                              ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 368   5                                              if (ipPoolIndex < dhcps_MaxIpPool)
 369   5                                              {
 370   6                                                      dhcps_IpPoolTable[ipPoolIndex].IpAddr = 0xFFFFFFFF;
 371   6                                                      dhcps_IpPoolTable[ipPoolIndex].MacAddr[0] = 0xFF;
 372   6                              dhcps_IpPoolTable[ipPoolIndex].Lease = 0;
 373   6                              dhcps_IpPoolTable[ipPoolIndex].Occupy = 0;
 374   6                                              }
 375   5                                              return;
 376   5                                      }
 377   4                                      else
 378   4                      {
 379   5                                              return;
 380   5                      }
 381   4                              }
 382   3      
 383   3                              index = 0;
 384   3                              optMsg = dhcps_GetOption(dhcps_pOpt, DHCPS_OPTION_REQ_IPADDR, &index, dhcps_RcvPktLeftLength);
 385   3                              if ((pDhcpMsg->CiAddr) || (optMsg && index == DHCPS_IP_ADDRESS_LEN))
 386   3                              {
 387   4                                      /* check the ip address requested by dhcp client */
 388   4                      if (pDhcpMsg->CiAddr)
 389   4                          requestIp = pDhcpMsg->CiAddr;
 390   4                      else
 391   4                                          requestIp = *(U32_T*)optMsg;
 392   4      
 393   4                                      if (((requestIp & DHCPS_SubnetMask) == (DHCPS_IpPoolStartAddr & DHCPS_SubnetMask)) &&
 394   4                                              (requestIp >= DHCPS_IpPoolStartAddr) && (requestIp <= DHCPS_IpPoolEndAddr))
 395   4                                      {
 396   5                           /* find index of ip pool by ip address */
 397   5                                              ipPoolIndex = dhcps_FindIpPoolByIpAddr(requestIp);
 398   5                                              if (ipPoolIndex < dhcps_MaxIpPool) /* had found in ip pool */
 399   5                                              {
 400   6                              if (!memcmp(rcvChAddr, dhcps_IpPoolTable[ipPoolIndex].MacAddr, 6))
 401   6                                                      {
 402   7                                                              foundInIpPool = 1;
 403   7                                                      }
 404   6                                                      else
 405   6                                                      {
 406   7                                  /* request the ip address but different host */
 407   7                                                              requestIp = 0;
 408   7                                                              ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 409   7                                                              if (ipPoolIndex < dhcps_MaxIpPool)
 410   7                                                                      foundInIpPool = 1;
 411   7                                                      }
 412   6                                              }
 413   5                                              else
 414   5                                              {
 415   6                                                      ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 416   6                                                      if (ipPoolIndex < dhcps_MaxIpPool)
 417   6                                                      {
 418   7                                                              requestIp = 0;
 419   7                                                              foundInIpPool = 1;
 420   7                                                      }
 421   6                                              }
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 8   

 422   5                                      }
 423   4                                      else
 424   4                                      {
 425   5                          if (dhcpMsgType == DHCPS_REQUEST)
 426   5                          {
 427   6                              dhcps_SendPkt(DHCPS_NAK);
 428   6                              return;
 429   6                          }
 430   5                                              requestIp = 0;
 431   5                          /* Check mac address existed in IP Pool table */
 432   5                          ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 433   5                          if (ipPoolIndex < dhcps_MaxIpPool)
 434   5                              foundInIpPool = 1;
 435   5                                      }
 436   4                              }
 437   3                              else
 438   3                              {
 439   4                                      ipPoolIndex = dhcps_FindIpPoolByMacAddr(rcvChAddr);
 440   4                                      if (ipPoolIndex < dhcps_MaxIpPool)
 441   4                                              foundInIpPool = 1;
 442   4                              }
 443   3      
 444   3                              if (!foundInIpPool)
 445   3                              {
 446   4                                      ipPoolIndex = dhcps_CreateNewElementToIpPool(requestIp, rcvChAddr); /* add a new element to IP pool*/
 447   4                                      if (ipPoolIndex >= dhcps_MaxIpPool) /* new item created failed, no resource */
 448   4                      {
 449   5                                              return;
 450   5                      }
 451   4                              }
 452   3                  else
 453   3                  {
 454   4                      dhcps_IpPoolTable[ipPoolIndex].Lease = DHCPS_LeaseTime * 60 * SWTIMER_COUNT_SECOND;
 455   4                  }
 456   3      
 457   3                              dhcps_ConnsInfo[dhcps_CurrConnId].IpPoolIndex = ipPoolIndex;
 458   3      
 459   3                              if (dhcps_ConnsInfo[dhcps_CurrConnId].State == DHCPS_STATE_ACTIVE)
 460   3                              {
 461   4                                      dhcps_SendPkt(DHCPS_OFFER);
 462   4                                      dhcps_ConnsInfo[dhcps_CurrConnId].State = DHCPS_STATE_OFFER;
 463   4                              }
 464   3                              else /* DHCPS_OFFER_STATE */
 465   3                              {
 466   4                                      dhcps_SendPkt(DHCPS_ACK);
 467   4                              }
 468   3                      }
 469   2              }
 470   1      } /* End of dhcps_ReceiveMessage() */
 471          
 472          /*
 473           *--------------------------------------------------------------------------------
 474           * Function Name: dhcps_FindConnInfoIndex
 475           * Purpose :
 476           * Params  :
 477           * Returns :
 478           * Note    :
 479           *--------------------------------------------------------------------------------
 480           */
 481          U8_T dhcps_FindConnInfoIndex(U8_T* pMacAddr)
 482          {
 483   1              U8_T index;
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 9   

 484   1      
 485   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 486   1              {
 487   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 488   2                              continue;
 489   2      
 490   2              if (!memcmp((char *)dhcps_ConnsInfo[index].ChMacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN))
 491   2                  return index;
 492   2              }
 493   1      
 494   1              /* not found in table */
 495   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 496   1              {
 497   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 498   2                      {
 499   3                              dhcps_ConnsInfo[index].State = DHCPS_STATE_ACTIVE;
 500   3                  memcpy((char *)dhcps_ConnsInfo[index].ChMacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN);
 501   3                              return index;
 502   3                      }
 503   2              }
 504   1      
 505   1              return 0xFF;
 506   1      } /* End of dhcps_FindConnInfoIndex() */
 507          
 508          /*
 509           *--------------------------------------------------------------------------------
 510           * Function Name: U8_T* dhcps_GetOption(void)
 511           * Purpose :
 512           * Params  :
 513           * Returns :
 514           * Note    :
 515           *--------------------------------------------------------------------------------
 516           */
 517          U8_T *dhcps_GetOption(U8_T *optMsg, U8_T msgCode, U8_T *vLen, U16_T maxLen)
 518          {
 519   1              U8_T    len, *optMsgEnd;
 520   1          
 521   1              optMsgEnd = optMsg + maxLen;
 522   1              while(*optMsg != DHCPS_OPTION_END && optMsg <= optMsgEnd) /* first to parse the msg type */
 523   1              {
 524   2                      if (*optMsg == msgCode)
 525   2                      {
 526   3                              *vLen = *(optMsg + 1);
 527   3                              optMsg += 2;
 528   3                              return optMsg;
 529   3                      }
 530   2                      else
 531   2                      {
 532   3                              len = *(optMsg + 1);
 533   3                              optMsg += (len + 2);
 534   3                      }
 535   2              }
 536   1      
 537   1              return 0;
 538   1      } /* End of dhcps_GetOption() */
 539          
 540          /*
 541           *--------------------------------------------------------------------------------
 542           * Function Name: dhcps_SendPkt
 543           * Purpose :
 544           * Params  :
 545           * Returns :
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 10  

 546           * Note    :
 547           *--------------------------------------------------------------------------------
 548           */
 549          void dhcps_SendPkt(U8_T pktType)
 550          {
 551   1              DHCPS_HEADER*   pDhcpMsg;
 552   1              U8_T XDATA*             pMacAddr = MAC_GetMacAddr();
 553   1              U8_T XDATA*             pRcvBuf = TCPIP_GetRcvBuffer();
 554   1              U16_T                   length = DHCPS_OFFSET_OPTIONS;
 555   1              U16_T                   headerLen, tmpShort, totalLen;
 556   1      
 557   1              uip_udpip_hdr XDATA*    pUdpHeader;
 558   1      
 559   1              pDhcpMsg = &dhcps_Buffer;
 560   1              DMA_Grant((U8_T*)&dhcps_Buffer, (U8_T*)dhcps_PktHeaderPtr, dhcps_RcvPktLength);
 561   1      
 562   1              pDhcpMsg->Op = DHCP_S_TO_C;
 563   1              pDhcpMsg->CiAddr = 0;
 564   1          if (DHCPS_NAK != pktType)
 565   1              pDhcpMsg->YiAddr = dhcps_IpPoolTable[dhcps_ConnsInfo[dhcps_CurrConnId].IpPoolIndex].IpAddr;
 566   1      
 567   1              /* Add magic cookie bytes */
 568   1              dhcps_pOpt = &pDhcpMsg->Options;
 569   1              *(dhcps_pOpt + 0) = 0x63;
 570   1              *(dhcps_pOpt + 1) = 0x82;
 571   1              *(dhcps_pOpt + 2) = 0x53;
 572   1              *(dhcps_pOpt + 3) = 0x63;
 573   1              dhcps_pOpt += 4;
 574   1              length += 4;
 575   1      
 576   1              /* Add DHCPS_OPTION_MSG_TYPE options */
 577   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_MSG_TYPE;
 578   1              *(dhcps_pOpt + 1) = 1; /* length */
 579   1              *(dhcps_pOpt + 2) = pktType;
 580   1              dhcps_pOpt += 3;
 581   1              length += 3;
 582   1      
 583   1              /* Add DHCPS_OPTION_SERVER_ID option */
 584   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_SERVER_ID;
 585   1              *(dhcps_pOpt + 1) = 4; /* length */
 586   1              *((U32_T*)(dhcps_pOpt + 2)) = STOE_GetIPAddr();
 587   1              dhcps_pOpt += 6;
 588   1              length += 6;
 589   1      
 590   1          if (DHCPS_NAK != pktType)
 591   1          {
 592   2              /* Add DHCPS_OPTION_LEASE_TIME options */
 593   2                  *(dhcps_pOpt + 0) = DHCPS_OPTION_LEASE_TIME;
 594   2                  *(dhcps_pOpt + 1) = 4; /* length */
 595   2                  *((U32_T*)(dhcps_pOpt + 2)) = (DHCPS_LeaseTime * 60); /* 1 day */
 596   2                  dhcps_pOpt += 6;
 597   2                  length += 6;
 598   2      
 599   2              /* Add DHCPS_OPTION_SUBNET_MASK option */
 600   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_SUBNET_MASK;
 601   2              *(dhcps_pOpt + 1) = 4; /* length */
 602   2              *((U32_T*)(dhcps_pOpt + 2)) = DHCPS_SubnetMask;
 603   2              dhcps_pOpt += 6;
 604   2              length += 6;
 605   2      
 606   2              /* Add DHCPS_OPTION_ROUTER option */
 607   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_ROUTER;
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 11  

 608   2              *(dhcps_pOpt + 1) = 4; /* length */
 609   2              *((U32_T*)(dhcps_pOpt + 2)) = DHCPS_Router;
 610   2              dhcps_pOpt += 6;
 611   2              length += 6;
 612   2      
 613   2              /* Add DHCPS_OPTION_DNS_SERVER option */
 614   2              *(dhcps_pOpt + 0) = DHCPS_OPTION_DNS_SERVER;
 615   2              *(dhcps_pOpt + 1) = 4; /* length */
 616   2              *((U32_T*)(dhcps_pOpt + 2)) = dhcps_DnsServer;
 617   2              dhcps_pOpt += 6;
 618   2              length += 6;
 619   2          }
 620   1      
 621   1              /* Add DHCPS_OPTION_END option */
 622   1              *(dhcps_pOpt + 0) = DHCPS_OPTION_END;
 623   1              length++;
 624   1      
 625   1              headerLen = (U16_T)dhcps_PktHeaderPtr - (U16_T)pRcvBuf;
 626   1              totalLen = length + headerLen;
 627   1      
 628   1      #if STOE_TRANSPARENT
 629   1              pRcvBuf[0] = 0xFF;
 630   1              pRcvBuf[1] = 0xFF;
 631   1              pRcvBuf[2] = 0xFF;
 632   1              pRcvBuf[3] = 0xFF;
 633   1              pRcvBuf[4] = 0xFF;
 634   1              pRcvBuf[5] = 0xFF;
 635   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN] = pMacAddr[0];
 636   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +1] = pMacAddr[1];
 637   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +2] = pMacAddr[2];
 638   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +3] = pMacAddr[3];
 639   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +4] = pMacAddr[4];
 640   1              pRcvBuf[DHCPS_MAC_ADDRESS_LEN +5] = pMacAddr[5];
 641   1      
 642   1              /* ip header */
 643   1              pUdpHeader = (uip_udpip_hdr XDATA*)(pRcvBuf + ETH_HEADER_LEN);
 644   1              tmpShort = totalLen - ETH_HEADER_LEN;
 645   1      #else
                      /* ip header */
                      pUdpHeader = (uip_udpip_hdr XDATA*)pRcvBuf;
                      tmpShort = totalLen;
              #endif
 650   1      
 651   1              pUdpHeader->len[0] = (U8_T)(tmpShort >> 8);
 652   1              pUdpHeader->len[1] = (U8_T)tmpShort;
 653   1              pUdpHeader->ipchksum = 0;
 654   1              pUdpHeader->destipaddr[0] = 0xFFFF;
 655   1              pUdpHeader->destipaddr[1] = 0xFFFF;
 656   1      
 657   1              uip_gethostaddr(pUdpHeader->srcipaddr);
 658   1      
 659   1              /* udp header */
 660   1              tmpShort = pUdpHeader->srcport;
 661   1              pUdpHeader->srcport = pUdpHeader->destport;
 662   1              pUdpHeader->destport = tmpShort;
 663   1              pUdpHeader->udplen = length + 8;
 664   1              pUdpHeader->udpchksum = 0;
 665   1      
 666   1              TCPIP_SetXmitLength(totalLen);
 667   1      
 668   1              uip_appdata = (U8_T*)&dhcps_Buffer;
 669   1      
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 12  

 670   1              ETH_Send(headerLen);
 671   1              uip_slen = 0;
 672   1      
 673   1      } /* End of dhcps_SendPkt() */
 674          
 675          /*
 676           *--------------------------------------------------------------------------------
 677           * Function Name: dhcps_FindIpPoolByIpAddr
 678           * Purpose :
 679           * Params  :
 680           * Returns :
 681           * Note    :
 682           *--------------------------------------------------------------------------------
 683           */
 684          U8_T dhcps_FindIpPoolByIpAddr(U32_T ipAddr)
 685          {
 686   1              U8_T    index;
 687   1      
 688   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 689   1              {
 690   2                      if (dhcps_IpPoolTable[index].Occupy != 0 && (dhcps_IpPoolTable[index].IpAddr == ipAddr))
 691   2                              return index;
 692   2              }
 693   1      
 694   1              return 0xFF;
 695   1      } /* End of dhcps_FindIpPoolByIpAddr() */
 696          
 697          /*
 698           *--------------------------------------------------------------------------------
 699           * Function Name: dhcps_FindIpPoolByMacAddr
 700           * Purpose :
 701           * Params  :
 702           * Returns :
 703           * Note    :
 704           *--------------------------------------------------------------------------------
 705           */
 706          U8_T dhcps_FindIpPoolByMacAddr(U8_T* pMacAddr)
 707          {
 708   1              U8_T index;
 709   1      
 710   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 711   1              {
 712   2                      if (dhcps_IpPoolTable[index].Occupy != 0 &&
 713   2                  !memcmp((char *)dhcps_IpPoolTable[index].MacAddr, (char *)pMacAddr, DHCPS_MAC_ADDRESS_LEN))
 714   2                  return index;
 715   2              }
 716   1      
 717   1              return 0xFF;
 718   1      } /* End of dhcps_FindIpPoolByMacAddr() */
 719          
 720          /*
 721           *--------------------------------------------------------------------------------
 722           * Function Name: dhcps_CreateNewElementToIpPool
 723           * Purpose :
 724           * Params  :
 725           * Returns :
 726           * Note    :
 727           *--------------------------------------------------------------------------------
 728           */
 729          U8_T dhcps_CreateNewElementToIpPool(U32_T ipAddr, U8_T* pMacAddr)
 730          {
 731   1          U8_T index, wrapCnt;
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 13  

 732   1      
 733   1          wrapCnt = 0;
 734   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 735   1              {
 736   2                      if (dhcps_IpPoolTable[index].Occupy == 0)
 737   2                      {
 738   3                              if (ipAddr != 0)
 739   3                              {
 740   4                                      dhcps_IpPoolTable[index].IpAddr = ipAddr;
 741   4                              }
 742   3                              else
 743   3                              {
 744   4                      do 
 745   4                      {
 746   5                                          dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset++;
 747   5                          /* skip xxx.xxx.xxx.0 and xxx.xxx.xxx.255 */
 748   5                          if (!(dhcps_IpPoolTable[index].IpAddr & 0x000000FF))
 749   5                          {
 750   6                              dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset++;
 751   6                          }
 752   5                          else if ((dhcps_IpPoolTable[index].IpAddr & 0x000000FF) == 0x000000FF)
 753   5                          {
 754   6                             dhcps_StartIpOffset += 2;
 755   6                             dhcps_IpPoolTable[index].IpAddr = DHCPS_IpPoolStartAddr + dhcps_StartIpOffset;
 756   6                          }
 757   5                          /* Wrapped */
 758   5                          if (dhcps_StartIpOffset >= dhcps_MaxIpPool)
 759   5                          {
 760   6                              wrapCnt++;
 761   6                              dhcps_StartIpOffset = 0;
 762   6                          }
 763   5      
 764   5                      } while (wrapCnt < 2 && dhcps_FindIpPoolByIpAddr(dhcps_IpPoolTable[index].IpAddr) != 0xFF)
             -;
 765   4                              }
 766   3      
 767   3                  dhcps_IpPoolTable[index].Lease = DHCPS_LeaseTime * 60 * SWTIMER_COUNT_SECOND;
 768   3                              dhcps_IpPoolTable[index].Occupy = 1;
 769   3                  memcpy(dhcps_IpPoolTable[index].MacAddr, pMacAddr, DHCPS_MAC_ADDRESS_LEN);
 770   3      
 771   3                              return index;
 772   3                      }
 773   2              }
 774   1      
 775   1              return 0xFF;
 776   1      } /* End of dhcps_CreateNewElementToIpPool() */
 777          
 778          /*
 779           *--------------------------------------------------------------------------------
 780           * Function Name: DHCPS_StateCheck
 781           * Purpose :
 782           * Params  :
 783           * Returns :
 784           * Note    :
 785           *--------------------------------------------------------------------------------
 786           */
 787          void DHCPS_ConnsCheck(void)
 788          {
 789   1              U8_T    index;
 790   1              U32_T   elapse, timeoutTick;
 791   1      
 792   1              if (!dhcps_Init || !DHCPS_EnableFlag)
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 14  

 793   1          {
 794   2              dhcps_LastTimeTick = SWTIMER_Tick();
 795   2                      return;
 796   2          }
 797   1      
 798   1          timeoutTick = SWTIMER_Tick();
 799   1          if (timeoutTick >= dhcps_LastTimeTick)
 800   1              elapse = timeoutTick - dhcps_LastTimeTick;
 801   1          else
 802   1              elapse = (0xFFFFFFFF - dhcps_LastTimeTick) + timeoutTick;
 803   1      
 804   1          dhcps_LastTimeTick = timeoutTick;
 805   1      
 806   1              for (index = 0; index < DHCPS_MAX_STA_CONNS; index++)
 807   1              {
 808   2                      if (dhcps_ConnsInfo[index].State == DHCPS_STATE_IDLE)
 809   2                              continue;
 810   2      
 811   2                      if (elapse > dhcps_ConnsInfo[index].Timer)
 812   2              {
 813   3                  dhcps_ConnsInfo[index].Timer = 0;
 814   3                              dhcps_ConnsInfo[index].State = DHCPS_STATE_IDLE;
 815   3              }
 816   2              else
 817   2              {
 818   3                  dhcps_ConnsInfo[index].Timer -= elapse;
 819   3              }
 820   2              }
 821   1      
 822   1          /* mantain the allocated IP table */
 823   1              for (index = 0; index < dhcps_MaxIpPool; index++)
 824   1              {
 825   2                      if (dhcps_IpPoolTable[index].Occupy != 0)
 826   2                      {
 827   3                  if (elapse > dhcps_IpPoolTable[index].Lease)
 828   3                  {
 829   4                      dhcps_IpPoolTable[index].Lease = 0;
 830   4                                  dhcps_IpPoolTable[index].Occupy = 0;
 831   4                  }
 832   3                  else
 833   3                      dhcps_IpPoolTable[index].Lease -= elapse;
 834   3                      }
 835   2              }
 836   1      
 837   1      } /* End of DHCPS_StateCheck() */
 838          
 839          #endif /* INCLUDE_DHCP_SERVER */
 840          
 841          /* End of dhcpc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6541    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    953     135
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.01   DHCPS                                                                 03/08/2012 11:01:12 PAGE 15  

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
