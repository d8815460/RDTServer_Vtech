C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MWIOCTL
OBJECT MODULE PLACED IN .\mwioctl.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mwif\mwioctl.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(
                    -..\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mpin
                    -g;..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\
                    -mhttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug) DEFINE(RuntimeCodeAt32KH
                    -) VARBANKING DEBUG PRINT(.\mwioctl.lst) OBJECT(.\mwioctl.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2010       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: wioctl.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: wioctl.c,v $
  18           *=============================================================================
  19           */
  20          
  21          /* INCLUDE FILE DECLARATIONS */
  22          #include "ax22000.h"
  23          #include "mwioctl.h"
  24          #include <string.h>
  25          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
  26          #include "uart0.h"
  27          #include "printd.h"
  28          #include "mcpu.h"
  29          #include "stoe.h"
  30          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              #include <stdio.h>
              #include "uart.h"
              #include "wcpu.h"
              #include "mac.h"
              #include "hw.h"
              #include "pcib.h"
              #include "mgr.h"
              #include "wifi.h"
              #include "wpsave.h"
              #include "supplicant.h"
              #include "delay.h"
              #endif                  /***** End of IO_CPU_TYPE macro *****/
  43          
  44          #if IO_CPU_TYPE
  45            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
  46              #define IO_SHOWCMD                                          0       // show the command detail byte by byte
  47          
  48                  #include "mwifapp.h"
  49            #else
                  #define IO_SHOWCMD                                          0       // always 0  
                #endif
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 2   

  52          #else /* for WiFi CPU */
                  #define IO_SHOWCMD                                          0
              #endif
  55          
  56          /* GLOBAL VARIABLES DECLARATIONS */
  57          U8_T XDATA      IO_RxBuf[MAX_IO_RX_BUFFER_SIZE] = {0};
  58          U16_T XDATA     IO_RxHead;
  59          U16_T XDATA     IO_RxTail;
  60          //U8_T XDATA    IO_CmdFlag = 0;
  61          
  62          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
  63            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
  64          U8_T XDATA      IO_WifiRFEnable = 0;
  65          U8_T XDATA      IO_WifiBasebandMode = 1; /* 802.11b+g mode*/
  66          U8_T XDATA      IO_WifiNetworkMode = 1; /* 802.11 ad hoc mode */
  67          U8_T const FAR  IO_WiFiSupportedCh[] =
  68          {0/*auto*/,1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,149,153,157,161,165};
  69          U8_T XDATA      IO_WiFiSupportedChBufSize = sizeof (IO_WiFiSupportedCh);
  70          U8_T XDATA      IO_WifiChannel = 11; /* channel = 11 */
  71          U8_T XDATA      IO_WiFiSsid[33] = {'A','X','2','2','0','x','x',' ','D','e','m','o',' ','F','i','r','m','w','a',
             -'r','e'};
  72          U8_T XDATA      IO_WifiSsidLen = 21;
  73          U8_T XDATA      IO_WiFiTxRate = 0; /* auto */
  74          U8_T const FAR  IO_WiFiSupportTxRate[] =
  75          {0/*auto*/,2/*1M*/,4/*2M*/,11/*5.5M*/,22/*11M*/,12/*6M*/,18,24,36,48,72,96,108};
  76          U8_T XDATA      IO_WiFiTxPowerLevel = 0; /* default 100% */
  77          U8_T XDATA      IO_GBProtection = 0; /* auto */
  78          U8_T XDATA      IO_PreambleMode = 0; /* auto */
  79          U16_T XDATA     IO_BcnInterval = 100; /* 100 ms */
  80          U16_T XDATA     IO_RtsThreshold = 2432; /* bytes */
  81          U8_T XDATA      IO_AutoPowerCtrl = 1; /* on */
  82          SISRVY_T XDATA  IO_SiteSurveyTable[20]; /* max num = 20 */
  83          U8_T XDATA      IO_FoundBssNum = 0;
  84          U8_T XDATA      IO_JbssIndex = 0xff;
  85          U8_T XDATA      IO_SiteSurveyStatusFlag = 0; /*0:nothing, 1:to start sisrvy, 1:had finish*/
  86          U8_T XDATA      IO_EncryptMode = 0; /* 0:disable, 1:wep64, 2:wep128, 3:tkip, 4:aes */
  87          U8_T XDATA      IO_WepKeyIndex = 0;
  88          U8_T XDATA      IO_WepKeyLength = 0; /* 0:64 bits, 1:128 bits*/
  89          U8_T XDATA      IO_Wep64Key[4][5] = {0x12,0x34,0x56,0x78,0x90, 0x09,0x87,0x65,0x43,0x21,
  90          0xA1,0xB2,0xC3,0xD4,0xE5,0x01, 0x23,0x45,0x67,0x89};
  91          U8_T XDATA      IO_Wep128Key[4][13] = {
  92          0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
  93          0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
  94          0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
  95          0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34};
  96          U8_T XDATA      IO_PreShareKey[64] = {'1','2','3','4','5','6','7','8'};
  97          U8_T XDATA      IO_PreShareKeyLen = 8;
  98            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
  99          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              U8_T XDATA      IO_SiteSurveyFromMcpu = 0;
              U8_T XDATA      IO_ScanFromMcpu = 0;
              #endif                  /***** End of IO_CPU_TYPE macro *****/
 103          
 104          /* LOCAL VARIABLES DECLARATIONS */
 105          static U8_T     XDATA   io_TxBuf[MAX_IO_TX_BUFFER_SIZE] = {0};
 106          
 107          /************************************************************/
 108          /* LOCAL SUBPROGRAM DECLARATIONS */
 109          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
 110            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
 111          static void io_ScanReportAck(void);
 112          static void io_SensitivityTestReportACK(void);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 3   

 113          static void io_WlanDebug1Resp(void);
 114            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
 115          #else                   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              static void io_ResetAck(void);
              static void io_ScanAck(void);
              static void io_SiteSurveyAck(void);
              static void io_JoinBssAck(void);
              static void io_SsidAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_OperateModeAckRW(U8_T type, U8_T value);
              static void io_ChannelAckRW(U8_T type, U8_T value);
              static void io_NetworkModeAckRW(U8_T type, U8_T value);
              static void io_SetMulticastMacAck(void);
              static void io_WiFiMacAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_RadioOnOffAck(U8_T state);
              static void io_BgProtectionRespRW(U8_T rw, U8_T state);
              static void io_EncryptionAckRW(U8_T type, U8_T value);
              static void io_OpenSysAckRW(U8_T type, U8_T value);
              static void io_Wep64KeyAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_Wep128KeyAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_WepKeyIndexKeyRW(U8_T type, U8_T value);
              static void io_TkipAesAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_FragmentThresholdAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_RtsIntervalAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_PreambleAckRW(U8_T type, U8_T value);
              static void io_TxGainRW(U8_T rw, U8_T txGain);
              static void io_BeaconIntervalAckRW(U8_T type, U8_T* pValue);
              static void io_CountryRegionAckRW(U8_T type, U16_T value);
              static void io_AtimIntervalAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_TxDataRateRW(U8_T rw, U8_T txRate);
              static void io_AutoPowerCtrlRW(U8_T rw, U8_T state);
              static void io_AutoPowerCtrlDetailW(void);
              static void io_RoamingRW(U8_T rw, U8_T state);
              static void io_WifiMultimediaSetRW(U8_T rw, U8_T value);
              static void io_ListenIntervalRW(U8_T rw, U16_T value);
              static void io_MinContentionWindowRW(U8_T rw, U16_T value);
              static void io_MaxContentionWindowRW(U8_T rw, U16_T value);
              static void io_ShowRssiResp(U8_T rssi);
              static void io_PayloadLenAddInWifiRW(U8_T rw, U8_T value);
              static void io_RetainLlcInWifiRW(U8_T rw, U8_T value);
              static void io_2LlcInWiFiVlanPacketRW(U8_T rw, U8_T value);
              static void io_TrafficProfileRW(U8_T rw, U8_T state);
              static void io_TxDefaultPowerLevelRW(U8_T rw, U8_T level);
              static void io_QueuePrioritySetRW(U8_T rw, U8_T priority);
              static void io_SelfCtsRW(U8_T rw, U8_T value);
              static void io_BssidR(U8_T *bssid);
              static void io_WifiIpR(U8_T *wifiIp);
              static void io_WifiDriverVerR(U8_T *pVer);
              #if MASS_PRODUCTION
              static void io_ContinuousTxAck(U8_T mode);
              static void io_SensitivityTestAck(U8_T *ptr);
              static void io_SensitivityTestReportAck(void);
              #endif
              static U8_T io_SfrIO(U8_T rw, U8_T index, U8_T XDATA* pValue);
              static void io_SfrAckRW(U8_T type, U8_T value);
              static void io_WcpuIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_MiibIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_PcibIndirectRegAckRW(U8_T type, U8_T len, U8_T XDATA* pReg);
              static void io_PciConfigAckRW(U8_T type, U8_T XDATA* pReg);
              static void io_WiFiRegAckRW(U8_T type, U8_T XDATA* pValue);
              static void io_WlanPktFilterAckRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid);
              static void io_SynthesizerSetAck(void);
              static void io_RetryAckRW(U8_T type, U8_T value);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 4   

              static void io_Gpio0RW(U8_T rw, U8_T value);
              static void io_Gpio1RW(U8_T rw, U8_T value);
              static void io_Gpio2RW(U8_T rw, U8_T value);
              static void io_Gpio3RW(U8_T rw, U8_T value);
              static U8_T io_WifiRegIO(U8_T rw, U16_T index, U32_T XDATA* pValue);
              #endif                  /***** End of IO_CPU_TYPE macro *****/
 181          #if IO_SHOWCMD
              static void io_ShowCmd(U8_T TxRx, U8_T XDATA* pReg);
              #endif
 184          
 185          /*
 186           * ----------------------------------------------------------------------------
 187           * Function Name: IO_Init
 188           * Purpose: To initiate "MCPU / WCPU interface" module
 189           * Params: none
 190           * Returns: none
 191           * Note: none
 192           * ----------------------------------------------------------------------------
 193           */
 194          void IO_Init(void)
 195          {
 196   1              IO_RxHead = 0;
 197   1              IO_RxTail = 0;
 198   1      #if MWIF_TASK_HOOKUP
 199   1          MWIFAPP_TaskInit();
 200   1      #endif
 201   1      }
 202          
 203          /*
 204           * ----------------------------------------------------------------------------
 205           * Function Name: IO_CmdError
 206           * Purpose: To send a error message to MCPU when MCPU sent a wrong command
 207           * Params: none
 208           * Returns: none
 209           * Note: none
 210           * ----------------------------------------------------------------------------
 211           */
 212          void IO_CmdError(void)
 213          {
 214   1              MWIF_Send(IO_ERROR_COMMAND, NULL, 0);
 215   1              
 216   1      }       /* End of IO_CmdError */
 217          
 218          /************************************************************************/
 219          #if IO_CPU_TYPE /***** Begin of IO_CPU_TYPE, Below are for MCPU use *****/
 220            #if (MAC_ARBIT_MODE & MAC_ARBIT_WIFI)
 221          /*
 222           * ----------------------------------------------------------------------------
 223           * Function Name: IO_CmdParsing
 224           * Purpose: To parse the command it gets and do the reaction
 225           * Params: none
 226           * Returns: 0x00 - IO_COMMAND_DONE
 227           *          0xFF - IO_COMMAND_ERROR
 228           * Note: none
 229           * ----------------------------------------------------------------------------
 230           */
 231          U8_T IO_CmdParsing(U8_T* pbuf)
 232          {
 233   1              U8_T XDATA      i, temp;
 234   1      
 235   1              if ((pbuf[0] + pbuf[1]) != 0xFF)
 236   1                      return IO_COMMAND_ERROR;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 5   

 237   1              {
 238   2                      switch (pbuf[0])
 239   2                      {
 240   3                      case IO_MCPU_WCPU_READY:
 241   3                              MCPU_WcpuReady = 1;
 242   3                              IO_NoticeWcpu(IO_MCPU_WCPU_READY_ACK, NULL, 0);
 243   3                              printd ("Rcv WCPU Ready Command.\n");
 244   3                              break;
 245   3                      case IO_MCPU_WCPU_READY_ACK:
 246   3                              MCPU_WcpuReady = 1;
 247   3                              printd ("Rcv MCPU Ready ACK Command.\n");
 248   3                              break;
 249   3                      case IO_WCPU_RESET_ACK:
 250   3                              printd ("Rcv WCPU Reset ACK Command.\n");
 251   3                              // need to add reset wcpu function.........
 252   3                              break;
 253   3                      case IO_MCPU_WCPU_CONNECT:
 254   3                              STOE_ConnectState |= STOE_WIRELESS_LINK;
 255   3                              IO_NoticeWcpu(IO_MCPU_WCPU_CONNECT_ACK, NULL, 0);
 256   3                              printd ("Rcv WiFi Connect Command.\n");
 257   3      
 258   3                              MWIFAPP_TaskIOWiFiConnect();
 259   3                              break;
 260   3                      case IO_MCPU_WCPU_DISCONNECT:
 261   3                              STOE_ConnectState &= ~STOE_WIRELESS_LINK;
 262   3                              temp = 1;
 263   3                              IO_NoticeWcpu(IO_MCPU_WCPU_DISCONNECT_RESP, &temp, 1);
 264   3                              printd ("Rcv WiFi Disconnect Command.\n");
 265   3                              break;
 266   3                      case IO_SCAN_ACK:
 267   3                              if (pbuf[2])
 268   3                                      return IO_COMMAND_ERROR;
 269   3                              break;
 270   3                      case IO_SCAN_REPORT:
 271   3                              if (!pbuf[2])
 272   3                                      return IO_COMMAND_ERROR;
 273   3                              if (pbuf[3] == 1)
 274   3                              {
 275   4                                      printd ("Start a new IBSS\n\r");
 276   4                              }
 277   3                              else if (pbuf[3] == 2)
 278   3                              {
 279   4                                      printd ("Rescan\n\r");
 280   4                              }
 281   3                              else if (pbuf[3] == 3)
 282   3                              {
 283   4                                      printd ("BSS is found:");
 284   4                                      for (i = 0; i < 72; i++)
 285   4                                      {
 286   5                                              if ((i%16) == 0)
 287   5                                              {
 288   6                                                      printd ("\n\r%2bx ", pbuf[i + 4]);
 289   6                                              }
 290   5                                              else
 291   5                                              {
 292   6                                                      printd ("%2bx ", pbuf[i + 4]);
 293   6                                              }
 294   5                                      }
 295   4                                      printd ("\n\r");
 296   4                              }
 297   3                              else
 298   3                              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 6   

 299   4                                      return IO_COMMAND_ERROR;
 300   4                              }
 301   3                              io_ScanReportAck();
 302   3                              break;
 303   3                      case IO_SITE_SURVEY_ACK:
 304   3                              if (pbuf[2])
 305   3                                      return IO_COMMAND_ERROR;
 306   3                              break;
 307   3                      case IO_SITE_SURVEY_REPORT:
 308   3                              if (!pbuf[2])
 309   3                                      return IO_COMMAND_ERROR;
 310   3                              if (pbuf[2] == 1)
 311   3                              {
 312   4                                      if (pbuf[3] == 0)
 313   4                                              printd ("\n\rIt can not find any BSS.\n\r");
 314   4                                      else
 315   4                                              return IO_COMMAND_ERROR;
 316   4                              }
 317   3                              else
 318   3                              {
 319   4                                      U8_T XDATA*             point;
 320   4      
 321   4                                      if (pbuf[2] < 11)
 322   4                                      {
 323   5                                              return IO_COMMAND_ERROR;
 324   5                                      }
 325   4      
 326   4                                      if (pbuf[3] == 0)
 327   4                                      {
 328   5                                              printd ("\nid BSSID             SSID                             TYPE CH  RSSI SECURITY\n\r");
 329   5                                      }
 330   4                                      printd ("\r%02bx %02bx-%02bx-%02bx-%02bx-%02bx-%02bx ", pbuf[3], pbuf[4], pbuf[5],
 331   4                                                      pbuf[6], pbuf[7], pbuf[8], pbuf[9]);
 332   4                                      temp = pbuf[2] - 12;
 333   4      
 334   4                                      IO_FoundBssNum = pbuf[3];
 335   4                                      point = IO_SiteSurveyTable[IO_FoundBssNum].Bssid;
 336   4                                      point[0] = pbuf[4];
 337   4                                      point[1] = pbuf[5];
 338   4                                      point[2] = pbuf[6];
 339   4                                      point[3] = pbuf[7];
 340   4                                      point[4] = pbuf[8];
 341   4                                      point[5] = pbuf[9];
 342   4      
 343   4                                      IO_SiteSurveyTable[IO_FoundBssNum].SsidLen = temp;
 344   4                                      point = IO_SiteSurveyTable[IO_FoundBssNum].Ssid;
 345   4                                      
 346   4                                      if (pbuf[15])
 347   4                                      {
 348   5                                              for (i = 0; i < temp; i++)
 349   5                                              {
 350   6                                                      printd ("%c", pbuf[15 + i]);
 351   6                                                      point[i] = pbuf[15 + i];
 352   6                                              }
 353   5                                              
 354   5                                              temp = 33 - temp;
 355   5                                              for (i = 0; i < temp; i++)
 356   5                                              {
 357   6                                                      printd (" ");
 358   6                                              }
 359   5                                      }
 360   4                                      else
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 7   

 361   4                                      {
 362   5                                              printd ("                                 ");
 363   5                                      }
 364   4      
 365   4                                      if (pbuf[10])
 366   4                                      {
 367   5                                              printd ("ap   %03bu %02bx   %s\n\r", pbuf[11], pbuf[12], pbuf[13] ? "yes":"no");
 368   5                                      }
 369   4                                      else
 370   4                                      {
 371   5                                              printd ("sta  %03bu %02bx   %s\n\r", pbuf[11], pbuf[12], pbuf[13] ? "yes":"no");
 372   5                                      }
 373   4      
 374   4                                      IO_SiteSurveyTable[IO_FoundBssNum].InfraMode = pbuf[10];
 375   4                                      IO_SiteSurveyTable[IO_FoundBssNum].Channel = pbuf[11];
 376   4                                      IO_SiteSurveyTable[IO_FoundBssNum].Rssi = pbuf[12];
 377   4                                      IO_SiteSurveyTable[IO_FoundBssNum].SecurFlag = pbuf[13];
 378   4                                      IO_FoundBssNum++;
 379   4      
 380   4                                      IO_SiteSurveyReportAck();
 381   4      
 382   4                                      if (pbuf[14])
 383   4                                      {
 384   5                                              IO_SiteSurveyStatusFlag = 2;
 385   5                                      }
 386   4                              }
 387   3                              break;
 388   3                      case IO_JOIN_BSS_ACK:
 389   3                              if (pbuf[2])
 390   3                                      return IO_COMMAND_ERROR;
 391   3                              printd ("\r BSS joined              \n\r");
 392   3                              break;
 393   3                      case IO_SSID_READ_RESP:
 394   3                              if (pbuf[2] > 32)
 395   3                                      return IO_COMMAND_ERROR;
 396   3                              printd ("\r Read SSID: ");
 397   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 398   3                              {
 399   4                                      printd ("%c", pbuf[temp]);
 400   4                              }
 401   3                              if (temp < 15)
 402   3                                      printd ("          \n\r");
 403   3                              else
 404   3                                      printd ("\n\r");
 405   3                              break;
 406   3                      case IO_SSID_WRITE_ACK:
 407   3                              if (pbuf[2])
 408   3                                      return IO_COMMAND_ERROR;
 409   3                              break;
 410   3                      case IO_OPERATE_MODE_RESP:
 411   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 412   3                              {
 413   4                                      if (pbuf[2] != 1)
 414   4                                              return IO_COMMAND_ERROR;
 415   4      
 416   4                                      IO_SiteSurveyStatusFlag = 1;
 417   4                              }
 418   3                              else if (!pbuf[3])
 419   3                              {
 420   4                                      if (pbuf[2] != 2)
 421   4                                              return IO_COMMAND_ERROR;
 422   4                                      printd ("\r Read Baseband Mode: %bd", pbuf[4]);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 8   

 423   4                                      switch (pbuf[4])
 424   4                                      {
 425   5                                              case 1:
 426   5                                                      printd (" (802.11b/g mixed mode)\n\r");
 427   5                                                      break;
 428   5                                              case 2:
 429   5                                                      printd (" (Pure 802.11g mode)\n\r");
 430   5                                                      break;
 431   5                                              case 3:
 432   5                                                      printd (" (Pure 802.11b mode)\n\r");
 433   5                                                      break;
 434   5                                              case 4:
 435   5                                                      printd (" (Pure 802.11a mode)\n\r");
 436   5                                                      break;
 437   5                                              default:
 438   5                                                      printd ("\n Not the correct baseband Mode!\n\r");
 439   5                                                      return IO_COMMAND_ERROR;
 440   5                                      }
 441   4                              }
 442   3                              else
 443   3                                      return IO_COMMAND_ERROR;
 444   3                              break;
 445   3                      case IO_CHANNEL_RESP:
 446   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 447   3                              {
 448   4                                      if (pbuf[2] != 1)
 449   4                                              return IO_COMMAND_ERROR;
 450   4                              }
 451   3                              else if (!pbuf[3])
 452   3                              {
 453   4                                      if (pbuf[2] != 2)
 454   4                                              return IO_COMMAND_ERROR;
 455   4                                      printd ("\r Read Current Channel: %bu\n\r", pbuf[4]);
 456   4      
 457   4                                      MWIFAPP_TaskIOReadChannel(pbuf);
 458   4                              }
 459   3                              else
 460   3                                      return IO_COMMAND_ERROR;
 461   3                              break;
 462   3                      case IO_NETWORK_MODE_RESP:
 463   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 464   3                              {
 465   4                                      if (pbuf[2] != 1)
 466   4                                              return IO_COMMAND_ERROR;
 467   4                              }
 468   3                              else if (!pbuf[3])
 469   3                              {
 470   4                                      if (pbuf[2] != 2)
 471   4                                              return IO_COMMAND_ERROR;
 472   4                                      printd ("\r Read Network Type: %bu    \n\r", pbuf[4]);
 473   4                              }
 474   3                              else
 475   3                                      return IO_COMMAND_ERROR;
 476   3                              break;
 477   3                      case IO_MULTICAST_SET_ACK:
 478   3                              if (pbuf[2])
 479   3                                      return IO_COMMAND_ERROR;
 480   3                              break;
 481   3                      case IO_WIFI_MAC_ADDR_SET_RESP: // 0xB6
 482   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 483   3                              {
 484   4                                      if (pbuf[2] != 1)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 9   

 485   4                                              return IO_COMMAND_ERROR;
 486   4                              }
 487   3                              else if (!pbuf[3])
 488   3                              {
 489   4                                      if (pbuf[2] != 7)
 490   4                                              return IO_COMMAND_ERROR;
 491   4                                      printd ("\r Read WiFi MAC address: ");
 492   4                                      for (temp = 4; temp < 10; temp++)
 493   4                                              printd (" %02bx", pbuf[temp]);
 494   4                                      printd ("\n\r");
 495   4      
 496   4                                  MWIFAPP_TaskIOWiFiMacAddrSet(pbuf);
 497   4                              }
 498   3                              break;
 499   3                      case IO_WIFI_RADIO_ON_OFF_ACK:
 500   3                              if (pbuf[3] == 0)
 501   3                              {
 502   4                                      IO_WifiRFEnable = 0;
 503   4                                      printd("\r Disable RF.                       \n");
 504   4                              }
 505   3                              else if (pbuf[3] == 1)
 506   3                              {
 507   4                                      IO_WifiRFEnable = 1;
 508   4                                      printd("\r Enble RF.                         \n");
 509   4                              }
 510   3                              else if (pbuf[3] == 2)
 511   3                                      printd("\r RF is enabling now.               \n");
 512   3                              else if (pbuf[3] == 3)
 513   3                                      printd("\r RF is disabling now.              \n");
 514   3                              break;
 515   3                      case IO_WIFI_B_G_PROTECTION_RESP:
 516   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 517   3                              {
 518   4                                      if (pbuf[2] != 1)
 519   4                                              return IO_COMMAND_ERROR;
 520   4                              }
 521   3                              else if (!pbuf[3])
 522   3                              {
 523   4                                      if (pbuf[2] != 2)
 524   4                                              return IO_COMMAND_ERROR;
 525   4                                      printd ("\r BG Protection: %s", pbuf[4] ? "auto" : "off");
 526   4                              }
 527   3                              else
 528   3                              {
 529   4                                      return IO_COMMAND_ERROR;
 530   4                              }
 531   3                              break;
 532   3                      case IO_ENCRYPTION_TYPE_RESP:
 533   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 534   3                              {
 535   4                                      if (pbuf[2] != 1)
 536   4                                              return IO_COMMAND_ERROR;
 537   4                              }
 538   3                              else if (!pbuf[3])
 539   3                              {
 540   4                                      if (pbuf[2] != 2)
 541   4                                              return IO_COMMAND_ERROR;
 542   4      
 543   4                                      /* do not know encryption type, be used in web,site survey,jbss case */
 544   4                                      if (IO_EncryptMode == 5)
 545   4                                      {
 546   5                                              switch (pbuf[4])
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 10  

 547   5                                              {
 548   6                                              case 0: /* No encrypt */
 549   6                                                      IO_EncryptMode = 0;
 550   6                                                      break;
 551   6                                              case 1: /* WEP64 */
 552   6                                                      IO_EncryptMode = 1;
 553   6                                                      break;
 554   6                                              case 2: /* TKIP */
 555   6                                                      IO_EncryptMode = 3;
 556   6                                                      break;
 557   6                                              case 4: /* WPA/WPA2 */
 558   6                                                      IO_EncryptMode = 4;
 559   6                                                      break;
 560   6                                              case 5: /* WEP128 */
 561   6                                                      IO_EncryptMode = 2;
 562   6                                                      break;
 563   6                                              default:
 564   6                                                      return IO_COMMAND_ERROR;
 565   6                                              }
 566   5      
 567   5                                              MWIFAPP_TaskIOReadEncryptType();
 568   5                                      }
 569   4                                      else
 570   4                                      {
 571   5                                              printd ("\r Read Encryption Type: %bd", pbuf[4]);
 572   5                                              switch (pbuf[4])
 573   5                                              {
 574   6                                              case 0:
 575   6              
 576   6                                                      IO_EncryptMode = 0;
 577   6                                                      printd (" (No encrypt)\n\r");
 578   6                                                      break;
 579   6                                              case 1:
 580   6                                                      IO_EncryptMode = 1;
 581   6                                                      printd (" (WEP64)\n\r");
 582   6                                                      break;
 583   6                                              case 2:
 584   6                                                      IO_EncryptMode = 3;
 585   6                                                      printd (" (TKIP)\n\r");
 586   6                                                      break;
 587   6                                              case 4:
 588   6                                                      IO_EncryptMode = 4;
 589   6                                                      printd (" (AES)\n\r");
 590   6                                                      break;
 591   6                                              case 5:
 592   6                                                      IO_EncryptMode = 2;
 593   6                                                      printd (" (WEP128)\n\r");
 594   6                                                      break;
 595   6                                              default:
 596   6                                                      printd ("\n Not the correct encryption type!\n\r");
 597   6                                                      return IO_COMMAND_ERROR;
 598   6                                              }
 599   5                                      }
 600   4                              }
 601   3                              else
 602   3                              {
 603   4                                      return IO_COMMAND_ERROR;
 604   4                              }
 605   3                              break;
 606   3                      case IO_OPEN_SYSTEM_RESP:
 607   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 608   3                              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 11  

 609   4                                      if (pbuf[2] != 1)
 610   4                                              return IO_COMMAND_ERROR;
 611   4                              }
 612   3                              else if (!pbuf[3])
 613   3                              {
 614   4                                      if (pbuf[2] != 2)
 615   4                                              return IO_COMMAND_ERROR;
 616   4                                      printd ("\r Read Authentication Algorithm: %bd", pbuf[4]);
 617   4                                      switch (pbuf[4])
 618   4                                      {
 619   5                                              case 0:
 620   5                                                      printd (" (Open system)\n\r");
 621   5                                                      break;
 622   5                                              case 1:
 623   5                                                      printd (" (Shared key)\n\r");
 624   5                                                      break;
 625   5                                              case 2:
 626   5                                                      printd (" (WPA1WPA2 only)\n\r");
 627   5                                                      break;
 628   5                                              case 3:
 629   5                                                      printd (" (WPA1WPA2 mixed)\n\r");
 630   5                                                      break;
 631   5                                              default:
 632   5                                                      printd ("\n Not the correct Authentication Algorithm!\n\r");
 633   5                                                      return IO_COMMAND_ERROR;
 634   5                                      }
 635   4                              }
 636   3                              else
 637   3                              {
 638   4                                      return IO_COMMAND_ERROR;
 639   4                              }
 640   3                              break;
 641   3                      case IO_WEP64_KEY_READ_RESP:
 642   3                              if (pbuf[2] != 5)
 643   3                                      return IO_COMMAND_ERROR;
 644   3                              printd ("\r");
 645   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 646   3                              {
 647   4                                      printd (" %02bx", pbuf[temp]);
 648   4                              }
 649   3                              printd ("               \n\r");
 650   3                              break;
 651   3                      case IO_WEP64_KEY_WRITE_ACK:
 652   3                              if (pbuf[2])
 653   3                                      return IO_COMMAND_ERROR;
 654   3                              break;
 655   3                      case IO_WEP128_KEY_READ_RESP:
 656   3                              if (pbuf[2] != 13)
 657   3                                      return IO_COMMAND_ERROR;
 658   3                              printd ("\r");
 659   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 660   3                              {
 661   4                                      printd (" %02bx", pbuf[temp]);
 662   4                              }
 663   3                              printd ("\n\r");
 664   3                              break;
 665   3                      case IO_WEP128_KEY_WRITE_ACK:
 666   3                              if (pbuf[2])
 667   3                                      return IO_COMMAND_ERROR;
 668   3                              break;
 669   3                      case IO_WEP_KEY_INDEX_RESP:
 670   3                              if (pbuf[3] == IO_COMMAND_WRITE)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 12  

 671   3                              {
 672   4                                      if (pbuf[2] != 1)
 673   4                                              return IO_COMMAND_ERROR;
 674   4                              }
 675   3                              else if (!pbuf[3])
 676   3                              {
 677   4                                      if (pbuf[2] != 2)
 678   4                                              return IO_COMMAND_ERROR;
 679   4                                      printd("\r Read Key index: %bd          \n\r", pbuf[4]);
 680   4                              }
 681   3                              else
 682   3                                      return IO_COMMAND_ERROR;
 683   3                              break;
 684   3                      case IO_TKIP_AES_PASSPHASE_STRING_READ_RESP:
 685   3                              if (!pbuf[2] || pbuf[2] > 64)
 686   3                                      return IO_COMMAND_ERROR;
 687   3                              printd ("\r Read tkip aes Passphrase: ");
 688   3                              for (temp = 3; temp < (pbuf[2] + 3); temp++)
 689   3                              {
 690   4                                      printd ("%c", pbuf[temp]);
 691   4                              }
 692   3                              printd ("\n\r");
 693   3                              break;
 694   3                      case IO_TKIP_AES_PASSPHASE_STRING_WRITE_ACK:
 695   3                              if (pbuf[2])
 696   3                                      return IO_COMMAND_ERROR;
 697   3                              break;
 698   3                      case IO_ERROR_COMMAND:  // 0x0B
 699   3                              if (pbuf[2])
 700   3                                      return IO_COMMAND_ERROR;
 701   3                              printd("Drop bad command\n\r");
 702   3                              break;
 703   3                      case IO_FRAGMENT_THRESHOLD_READ_RESP:
 704   3                              if (pbuf[2] != 2)
 705   3                                      return IO_COMMAND_ERROR;
 706   3                              printd ("\r Read Fragment threshold: %u\n", *((U16_T XDATA*)&pbuf[3]));
 707   3                              break;
 708   3                      case IO_FRAGMENT_THRESHOLD_WRITE_ACK:
 709   3                              if (pbuf[2])
 710   3                                      return IO_COMMAND_ERROR;
 711   3                              break;
 712   3                      case IO_RTS_THRESHOLD_READ_RESP:
 713   3                              if (pbuf[2] != 2)
 714   3                                      return IO_COMMAND_ERROR;
 715   3                              printd ("\r Read RTS threshold: %u\n", *((U16_T XDATA*)&pbuf[3]));
 716   3                              break;
 717   3                      case IO_RTS_THRESHOLD_WRITE_ACK:
 718   3                              if (pbuf[2])
 719   3                                      return IO_COMMAND_ERROR;
 720   3                              break;
 721   3                      case IO_PREAMBLE_RESP:
 722   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 723   3                              {
 724   4                                      if (pbuf[2] != 1)
 725   4                                              return IO_COMMAND_ERROR;
 726   4                              }
 727   3                              else if (!pbuf[3])
 728   3                              {
 729   4                                      if (pbuf[2] != 2)
 730   4                                              return IO_COMMAND_ERROR;
 731   4                                      printd ("\r Read Preamble mode: %bd", pbuf[4] >> 5);
 732   4                                      switch (pbuf[4])
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 13  

 733   4                                      {
 734   5                                      case 0:
 735   5                                              printd (" (Long)\n\r");
 736   5                                              break;
 737   5                                      case BIT5:
 738   5                                              printd (" (Short)\n\r");
 739   5                                              break;
 740   5                                      default:
 741   5                                              printd ("\n Not the correct mode!\n\r");
 742   5                                              return IO_COMMAND_ERROR;
 743   5                                      }
 744   4                              }
 745   3                              else
 746   3                                      return IO_COMMAND_ERROR;
 747   3                              break;
 748   3                      case IO_TX_POWER_LEVEL_READ_RESP:
 749   3                              if (pbuf[2] != 1)
 750   3                                      return IO_COMMAND_ERROR;
 751   3                              printd ("\r Read Tx power gain: 0x%02bx\n\r", pbuf[3]);
 752   3                              break;
 753   3                      case IO_TX_POWER_LEVEL_WRITE_ACK:
 754   3                              if (pbuf[2])
 755   3                                      return IO_COMMAND_ERROR;
 756   3                              break;
 757   3                      case IO_BEACON_INTERVAL_READ_RESP:
 758   3                              if (pbuf[2] != 2)
 759   3                                      return IO_COMMAND_ERROR;
 760   3                              IO_BcnInterval = *((U16_T XDATA*)&pbuf[3]);
 761   3                              printd ("\r Read Beacon Interval: %u ms\n\r", IO_BcnInterval);
 762   3      
 763   3                              MWIFAPP_TaskIOReadBeaconInterval();
 764   3      
 765   3                              break;
 766   3                      case IO_BEACON_INTERVAL_WRITE_ACK:
 767   3                              if (pbuf[2])
 768   3                                      return IO_COMMAND_ERROR;
 769   3                              break;
 770   3                      case IO_COUNTRY_REGION_RESP:
 771   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 772   3                              {
 773   4                                      if (pbuf[2] != 1)
 774   4                                              return IO_COMMAND_ERROR;
 775   4                              }
 776   3                              else if (!pbuf[3])
 777   3                              {
 778   4                                      if (pbuf[2] != 3)
 779   4                                              return IO_COMMAND_ERROR;
 780   4                                      printd ("\r Read Country Region: 0x%02bX%02bX", pbuf[4], pbuf[5]);
 781   4                                      switch (*((U16_T XDATA *)(&pbuf[4])))
 782   4                                      {
 783   5                                      case 0x0010:
 784   5                                              printd (" (USA)\n\r");
 785   5                                              break;
 786   5                                      case 0x0020:
 787   5                                              printd (" (Canada)\n\r");
 788   5                                              break;
 789   5                                      case 0x0030:
 790   5                                              printd (" (Most of Europe1)\n\r");
 791   5                                              break;
 792   5                                      case 0x0083:
 793   5                                              printd (" (Most of Europe2)\n\r");
 794   5                                              break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 14  

 795   5                                      case 0x0031:
 796   5                                              printd (" (Spain)\n\r");
 797   5                                              break;
 798   5                                      case 0x0032:
 799   5                                              printd (" (France1)\n\r");
 800   5                                              break;
 801   5                                      case 0x0084:
 802   5                                              printd (" (France2)\n\r");
 803   5                                              break;
 804   5                                      case 0x0040:
 805   5                                              printd (" (Japan1)\n\r");
 806   5                                              break;
 807   5                                      case 0x0041:
 808   5                                              printd (" (Japan2)\n\r");
 809   5                                              break;
 810   5                                      case 0x0049:
 811   5                                              printd (" (Japan3)\n\r");
 812   5                                              break;
 813   5                                      case 0x0043:
 814   5                                              printd (" (China)\n\r");
 815   5                                              break;
 816   5                                      case 0x0048:
 817   5                                              printd (" (Taiwan)\n\r");
 818   5                                              break;
 819   5                                      case 0x0000:
 820   5                                              printd (" (All areas)\n\r");
 821   5                                              break;
 822   5                                      default:
 823   5                                              printd ("\n Not the correct Country Region number!\n\r");
 824   5                                              break;
 825   5                                      }
 826   4                              }
 827   3                              else
 828   3                              {
 829   4                                      return IO_COMMAND_ERROR;
 830   4                              }
 831   3                              break;
 832   3                      case IO_ATIM_INTERVAL_READ_RESP:
 833   3                              if (pbuf[2] != 2)
 834   3                                      return IO_COMMAND_ERROR;
 835   3                              printd ("\r Read ATIM Windows: %u ms\n\r", *((U16_T XDATA*)&pbuf[3]));
 836   3                              break;
 837   3                      case IO_ATIM_INTERVAL_WRITE_ACK:
 838   3                              if (pbuf[2])
 839   3                                      return IO_COMMAND_ERROR;
 840   3                              break;
 841   3                      case IO_TX_DATA_RATE_RESP:
 842   3                              if (pbuf[3] == IO_COMMAND_WRITE)        // write
 843   3                              {
 844   4                                      if (pbuf[2] != 1)
 845   4                                              return IO_COMMAND_ERROR;
 846   4                              }
 847   3                              else if (!pbuf[3])
 848   3                              {
 849   4                                      if (pbuf[2] != 2)
 850   4                                              return IO_COMMAND_ERROR;
 851   4                                      printd ("\r Read current Tx data rate: %2bx", pbuf[4]);
 852   4                                      switch (pbuf[4])
 853   4                                      {
 854   5                                      case 0:
 855   5                                              printd (" (Auto)\n\r");
 856   5                                              break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 15  

 857   5                                      case 0x02:
 858   5                                              printd (" (1M)\n\r");
 859   5                                              break;
 860   5                                      case 0x04:
 861   5                                              printd (" (2M)\n\r");
 862   5                                              break;
 863   5                                      case 0x0B:
 864   5                                              printd (" (5.5M)\n\r");
 865   5                                              break;
 866   5                                      case 0x0C:
 867   5                                              printd (" (6M)\n\r");
 868   5                                              break;
 869   5                                      case 0x12:
 870   5                                              printd (" (9M)\n\r");
 871   5                                              break;
 872   5                                      case 0x16:
 873   5                                              printd (" (11M)\n\r");
 874   5                                              break;
 875   5                                      case 0x18:
 876   5                                              printd (" (12M)\n\r");
 877   5                                              break;
 878   5                                      case 0x24:
 879   5                                              printd (" (18M)\n\r");
 880   5                                              break;
 881   5                                      case 0x30:
 882   5                                              printd (" (24M)\n\r");
 883   5                                              break;
 884   5                                      case 0x48:
 885   5                                              printd (" (36M)\n\r");
 886   5                                              break;
 887   5                                      case 0x60:
 888   5                                              printd (" (48M)\n\r");
 889   5                                              break;
 890   5                                      case 0x6C:
 891   5                                              printd (" (54M)\n\r");
 892   5                                              break;
 893   5                                      default:
 894   5                                              printd ("\n Not the correct Tx data rate!\n\r");
 895   5                                              break;
 896   5                                      }
 897   4                              }
 898   3                              else
 899   3                                      return IO_COMMAND_ERROR;
 900   3                              break;
 901   3                      case IO_AUTO_POWER_CONTROL_RESP:
 902   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 903   3                              {
 904   4                                      if (pbuf[2] != 1)
 905   4                                              return IO_COMMAND_ERROR;
 906   4                                      printd ("successfully!!\n\r");
 907   4                              }
 908   3                              else if (!pbuf[3])
 909   3                              {
 910   4                                      if (pbuf[2] != 2)
 911   4                                              return IO_COMMAND_ERROR;
 912   4                                      if (pbuf[4])
 913   4                                      {
 914   5                                              printd("Enable auto power control.\n\r");
 915   5                                      }
 916   4                                      else
 917   4                                      {
 918   5                                              printd("Disable auto power control.\n\r");
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 16  

 919   5                                      }
 920   4                              }
 921   3                              else
 922   3                                      return IO_COMMAND_ERROR;
 923   3                              break;
 924   3                      case IO_WIFI_ROAMING_RESP:
 925   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 926   3                              {
 927   4                                      if (pbuf[2] != 1)
 928   4                                              return IO_COMMAND_ERROR;
 929   4                              }
 930   3                              else if (!pbuf[3])
 931   3                              {
 932   4                                      if (pbuf[2] != 2)
 933   4                                              return IO_COMMAND_ERROR;
 934   4                                      if (pbuf[4])
 935   4                                      {
 936   5                                              printd("Enable roaming.\n\r");
 937   5                                      }
 938   4                                      else
 939   4                                      {
 940   5                                              printd("Disable roaming.\n\r");
 941   5                                      }
 942   4                              }
 943   3                              else
 944   3                                      return IO_COMMAND_ERROR;
 945   3                              break;
 946   3                      case IO_WIFI_MULTIMEDIA_SET_RESP:
 947   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 948   3                              {
 949   4                                      if (pbuf[2] != 1)
 950   4                                              return IO_COMMAND_ERROR;
 951   4                              }
 952   3                              else if (!pbuf[3])
 953   3                              {
 954   4                                      if (pbuf[2] != 2)
 955   4                                              return IO_COMMAND_ERROR;
 956   4                                      if (pbuf[4])
 957   4                                      {
 958   5                                              printd("Enable WMM.\n\r");
 959   5                                      }
 960   4                                      else
 961   4                                      {
 962   5                                              printd("Disable WMM.\n\r");
 963   5                                      }
 964   4                              }
 965   3                              else
 966   3                                      return IO_COMMAND_ERROR;
 967   3                              break;
 968   3                      case IO_LISTEN_INTERVAL_RESP:
 969   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 970   3                              {
 971   4                                      if (pbuf[2] != 1)
 972   4                                              return IO_COMMAND_ERROR;
 973   4                              }
 974   3                              else if (!pbuf[3])
 975   3                              {
 976   4                                      if (pbuf[2] != 3)
 977   4                                              return IO_COMMAND_ERROR;
 978   4                                      printd("Listen Interval: %d.\n\r", *((U16_T*)&pbuf[4]));
 979   4                              }
 980   3                              else
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 17  

 981   3                                      return IO_COMMAND_ERROR;
 982   3                              break;
 983   3                      case IO_MINIMUM_CONTENTION_WINDOW:
 984   3                              if (pbuf[3] == IO_COMMAND_WRITE)
 985   3                              {
 986   4                                      if (pbuf[2] != 1)
 987   4                                              return IO_COMMAND_ERROR;
 988   4                              }
 989   3                              else if (!pbuf[3])
 990   3                              {
 991   4                                      if (pbuf[2] != 3)
 992   4                                              return IO_COMMAND_ERROR;
 993   4                                      printd("Minimum contention window: %d.\n\r", *((U16_T*)&pbuf[4]));
 994   4                              }
 995   3                              else
 996   3                                      return IO_COMMAND_ERROR;
 997   3                              break;
 998   3                      case IO_MAXIMUM_CONTENTION_WINDOW:
 999   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1000   3                              {
1001   4                                      if (pbuf[2] != 1)
1002   4                                              return IO_COMMAND_ERROR;
1003   4                              }
1004   3                              else if (!pbuf[3])
1005   3                              {
1006   4                                      if (pbuf[2] != 3)
1007   4                                              return IO_COMMAND_ERROR;
1008   4                                      printd("Maximum contention window: %d.\n\r", *((U16_T*)&pbuf[4]));
1009   4                              }
1010   3                              else
1011   3                                      return IO_COMMAND_ERROR;
1012   3                              break;
1013   3                      case IO_SHOW_RSSI_RESP:
1014   3                              if (pbuf[2] != 1)
1015   3                                      return IO_COMMAND_ERROR;
1016   3                              printd ("\r Read RSSI value: %bx    \n\r", pbuf[3]);
1017   3                              break;
1018   3                      case IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET_RESP:
1019   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1020   3                              {
1021   4                                      if (pbuf[2] != 1)
1022   4                                              return IO_COMMAND_ERROR;
1023   4                              }
1024   3                              else if (!pbuf[3])
1025   3                              {
1026   4                                      if (pbuf[2] != 2)
1027   4                                              return IO_COMMAND_ERROR;
1028   4                                      if (pbuf[4])
1029   4                                      {
1030   5                                              printd("Attach payload length in WiFi packet.\n\r");
1031   5                                      }
1032   4                                      else
1033   4                                      {
1034   5                                              printd("Don't attach payload length in WiFi packet.\n\r");
1035   5                                      }
1036   4                              }
1037   3                              else
1038   3                                      return IO_COMMAND_ERROR;
1039   3                              break;
1040   3                      case IO_RETAIN_LLC_IN_WIFI_PACKET_RESP:
1041   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1042   3                              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 18  

1043   4                                      if (pbuf[2] != 1)
1044   4                                              return IO_COMMAND_ERROR;
1045   4                              }
1046   3                              else if (!pbuf[3])
1047   3                              {
1048   4                                      if (pbuf[2] != 2)
1049   4                                              return IO_COMMAND_ERROR;
1050   4                                      if (pbuf[4])
1051   4                                      {
1052   5                                              printd("Retain LLC in WiFi packet.\n\r");
1053   5                                      }
1054   4                                      else
1055   4                                      {
1056   5                                              printd("Don't retain LLC in WiFi packet.\n\r");
1057   5                                      }
1058   4                              }
1059   3                              else
1060   3                                      return IO_COMMAND_ERROR;
1061   3                              break;
1062   3                      case IO_2_LLC_IN_WIFI_VLAN_PACKET_RESP:
1063   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1064   3                              {
1065   4                                      if (pbuf[2] != 1)
1066   4                                              return IO_COMMAND_ERROR;
1067   4                              }
1068   3                              else if (!pbuf[3])
1069   3                              {
1070   4                                      if (pbuf[2] != 2)
1071   4                                              return IO_COMMAND_ERROR;
1072   4                                      if (pbuf[4])
1073   4                                      {
1074   5                                              printd("Add 2 LLC in WiFi VLAN packet.\n\r");
1075   5                                      }
1076   4                                      else
1077   4                                      {
1078   5                                              printd("Don't add 2 LLC in WiFi VLAN packet.\n\r");
1079   5                                      }
1080   4                              }
1081   3                              else
1082   3                                      return IO_COMMAND_ERROR;
1083   3                              break;
1084   3                      case IO_TRAFFIC_PROFILE_RESP:
1085   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1086   3                              {
1087   4                                      if (pbuf[2] != 1)
1088   4                                              return IO_COMMAND_ERROR;
1089   4                                      printd("Set traffic profile successful!\n\r");
1090   4                              }
1091   3                              else if (!pbuf[3])
1092   3                              {
1093   4                                      if (pbuf[2] != 2)
1094   4                                              return IO_COMMAND_ERROR;
1095   4                                      switch (pbuf[4])
1096   4                                      {
1097   5                                              case 0:
1098   5                                                      printd("Traffic profile is VOICE.\n\r");
1099   5                                                      break;
1100   5                                              case 1:
1101   5                                                      printd("Traffic profile is VIDEO.\n\r");
1102   5                                                      break;
1103   5                                              case 2:
1104   5                                                      printd("Traffic profile is BEST_EFFORT.\n\r");
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 19  

1105   5                                                      break;
1106   5                                              case 3:
1107   5                                                      printd("Traffic profile is BACK_GROUND.\n\r");
1108   5                                                      break;
1109   5                                              case 4:
1110   5                                                      printd("Traffic profile is DEFAULT.\n\r");
1111   5                                                      break;
1112   5                                              default:
1113   5                                                      printd("Incorrect profile number !!\n\r");
1114   5                                                      break;
1115   5                                      }
1116   4                              }
1117   3                              break;
1118   3                      case IO_TX_DEFAULT_POWER_LEVEL_RESP:
1119   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1120   3                              {
1121   4                                      if (pbuf[2] != 2)
1122   4                                              return IO_COMMAND_ERROR;
1123   4                                      if (pbuf[4] == 0)
1124   4                                      {
1125   5                                              printd("Current power level: 100%%\n\r");
1126   5                                      }
1127   4                                      else if (pbuf[4] == 1)
1128   4                                      {
1129   5                                              printd("Current power level: 50%%\n\r");
1130   5                                      }
1131   4                                      else if (pbuf[4] == 2)
1132   4                                      {
1133   5                                              printd("Current power level: 25%%\n\r");
1134   5                                      }
1135   4                                      else if (pbuf[4] == 3)
1136   4                                      {
1137   5                                              printd("Current power level: 12.5%%\n\r");
1138   5                                      }
1139   4                                      else if (pbuf[4] == 4)
1140   4                                      {
1141   5                                              printd("Current power level: 6.25%%\n\r");
1142   5                                      }
1143   4                                      else if (pbuf[4] == 0xff)
1144   4                                      {
1145   5                                              printd("Power level is the same!!\n\r");
1146   5                                      }
1147   4                                      else
1148   4                                      {
1149   5                                              printd("Not the correct Power level!!\n\r");
1150   5                                              return IO_COMMAND_ERROR;
1151   5                                      }
1152   4                              }
1153   3                              else if (!pbuf[3])
1154   3                              {
1155   4                                      if (pbuf[2] != 2)
1156   4                                              return IO_COMMAND_ERROR;
1157   4                                      if (pbuf[4] == 0)
1158   4                                      {
1159   5                                              printd("Current power level: 100%%\n\r");
1160   5                                      }
1161   4                                      else if (pbuf[4] == 1)
1162   4                                      {
1163   5                                              printd("Current power level: 50%%\n\r");
1164   5                                      }
1165   4                                      else if (pbuf[4] == 2)
1166   4                                      {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 20  

1167   5                                              printd("Current power level: 25%%\n\r");
1168   5                                      }
1169   4                                      else if (pbuf[4] == 3)
1170   4                                      {
1171   5                                              printd("Current power level: 12.5%%\n\r");
1172   5                                      }
1173   4                                      else if (pbuf[4] == 4)
1174   4                                      {
1175   5                                              printd("Current power level: 6.25%%\n\r");
1176   5                                      }
1177   4                                      else
1178   4                                      {
1179   5                                              printd("Not the correct Power level!!\n\r");
1180   5                                              return IO_COMMAND_ERROR;
1181   5                                      }
1182   4                              }
1183   3                              else
1184   3                                      return IO_COMMAND_ERROR;
1185   3                              break;
1186   3                      case IO_QUEUE_PRIORITY_SET_RESP:
1187   3                              break;
1188   3                      case IO_SELF_CTS_RESP:
1189   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1190   3                              {
1191   4                                      if (pbuf[2] != 1)
1192   4                                              return IO_COMMAND_ERROR;
1193   4                                      printd ("Success to set!!\r\n");
1194   4                              }
1195   3                              else if (!pbuf[3])
1196   3                              {
1197   4                                      if (pbuf[2] != 2)
1198   4                                              return IO_COMMAND_ERROR;
1199   4                                      if (pbuf[4] == 0)
1200   4                                      {
1201   5                                              printd ("Self-CTS disabled in OFDM\r\n");
1202   5                                      }
1203   4                                      else if (pbuf[4] == 1)
1204   4                                      {
1205   5                                              printd ("Self-CTS enable in OFDM\r\n");
1206   5                                      }
1207   4                              }
1208   3                              else
1209   3                                      return IO_COMMAND_ERROR;
1210   3                              break;
1211   3                      case IO_BSSID_RESP:
1212   3                              if (pbuf[3] == IO_COMMAND_READ)
1213   3                              {
1214   4                                      if (pbuf[2] != 7)
1215   4                                              return IO_COMMAND_ERROR;
1216   4                                      
1217   4                                      if ((pbuf[4] == 0) && (pbuf[5] == 0) && (pbuf[6] == 0) && (pbuf[7] == 0) && (pbuf[8] == 0) && (pbuf[9]
             - == 0))
1218   4                                      {
1219   5                                              printd ("BSSID: 00 00 00 00 00 00, wireless does not connect.\r\n");
1220   5                                      }
1221   4                                      else
1222   4                                      {
1223   5                                              printd ("BSSID: %02bX %02bX %02bX %02bX %02bX %02bX\r\n", pbuf[4], pbuf[5], pbuf[6], pbuf[7], pbuf[8]
             -, pbuf[9]);
1224   5                                      }
1225   4                              }
1226   3                              else
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 21  

1227   3                                      return IO_COMMAND_ERROR;
1228   3                              break;
1229   3                      case IO_WIFI_IP_READ_RESP:
1230   3                              if (pbuf[2] != 4)
1231   3                                      return IO_COMMAND_ERROR;
1232   3                              printd ("Wifi IP: %02bu.%02bu.%02bu.%02bu\r\n", pbuf[3], pbuf[4], pbuf[5], pbuf[6]);
1233   3                              break;
1234   3                      case IO_WIFI_DRIVER_VER_READ_RESP:
1235   3                              if (pbuf[2] == 0)
1236   3                                      return IO_COMMAND_ERROR;
1237   3                              printd ("WCPU driver version: %s\n\r", &pbuf[3]);
1238   3      
1239   3                  MWIFAPP_TaskIOWiFiDriverVer(pbuf);
1240   3                              break;
1241   3      #if MASS_PRODUCTION
                              case IO_CONTINUOUS_TX_ACK:      // 0xC0
                                      if (pbuf[3] == 0)
                                              printd("\r Stop ct command !!                \n");
                                      else if (pbuf[3] == 1)
                                              printd("\r Launch continuous tx with CCK ... \n");
                                      else if (pbuf[3] == 2)
                                              printd("\r Launch continuous tx with OFDM ...\n");
                                      else if (pbuf[3] == 3)
                                              printd("\r Launch single tone ...            \n");
                                      else if (pbuf[3] == 4)
                                              printd("\r Launch tx suppression ...         \n");
                                      else if (pbuf[3] == 5)
                                              printd("\r Launch burst CCK ...              \n");
                                      break;
                              case IO_SENSITIVITY_TEST_ACK:
                                      if (pbuf[2] == 2)
                                      {
                                              printd("\r Total received frames should be %05u\n", *((U16_T *)&pbuf[3]));
                                              printd("\r Start sensitivity test ...        \n");
                                      }
                                      break;
                              case IO_SENSITIVITY_TEST_REPORT_ACK:
                                      if (pbuf[2])
                                      {
                                              printd("\r");
                                              temp = pbuf[2];
                                              for (i = 0; i < temp; i++)
                                              {
                                                      printd("%c", pbuf[i + 3]);
                                              }
                                              printd("    \n");
                                      }
                                      break;
              #endif
1276   3                      case IO_DBG_WCPU_SFR_READ_RESP:
1277   3                              if (pbuf[2] != 1)
1278   3                                      return IO_COMMAND_ERROR;
1279   3                              printd ("\rvalue = %bx              \n", pbuf[3]);
1280   3                              break;
1281   3                      case IO_DBG_WCPU_SFR_WRITE_ACK:
1282   3                              if (pbuf[2])
1283   3                                      return IO_COMMAND_ERROR;
1284   3                              break;
1285   3                      case IO_DBG_WCPU_SUB_SYS_REG_READ_RESP:
1286   3                              if (pbuf[2] < 1)
1287   3                                      return IO_COMMAND_ERROR;
1288   3                              printd ("\r");
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 22  

1289   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1290   3                              {
1291   4                                      printd (" %02bx", pbuf[temp]);
1292   4                              }
1293   3                              printd ("                       \n");
1294   3                              break;
1295   3                      case IO_DBG_WCPU_SUB_SYS_REG_WRITE_RESP:        // 0xD3
1296   3                              if (pbuf[2])
1297   3                                      return IO_COMMAND_ERROR;
1298   3                              break;
1299   3                      case IO_DBG_WCPU_MIIB_REG_READ_RESP:
1300   3                              if (pbuf[2] < 1)
1301   3                                      return IO_COMMAND_ERROR;
1302   3                              printd ("\r");
1303   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1304   3                              {
1305   4                                      printd (" %02bx", pbuf[temp]);
1306   4                              }
1307   3                              printd ("                         \n");
1308   3                              break;
1309   3                      case IO_DBG_WCPU_MIIB_REG_WRITE_ACK:
1310   3                              if (pbuf[2])
1311   3                                      return IO_COMMAND_ERROR;
1312   3                              break;
1313   3                      case IO_DBG_WCPU_PCIB_REG_READ_RESP:
1314   3                              if (pbuf[2] < 1)
1315   3                                      return IO_COMMAND_ERROR;
1316   3                              printd ("\r");
1317   3                              for (temp = 3; temp < (3 + pbuf[2]); temp++)
1318   3                              {
1319   4                                      printd (" %02bx", pbuf[temp]);
1320   4                              }
1321   3                              printd ("                          \n");
1322   3                              break;
1323   3                      case IO_DBG_WCPU_PCIB_REG_WRITE_ACK:
1324   3                              if (pbuf[2])
1325   3                                      return IO_COMMAND_ERROR;
1326   3                              break;
1327   3                      case IO_DBG_PCI_CONFIGURATION_READ_RESP:        // 0xD8
1328   3                              if (pbuf[2] != 4)
1329   3                                      return IO_COMMAND_ERROR;
1330   3                              printd ("\r");
1331   3                              printd ("%08lx", *((U32_T XDATA*)&pbuf[3]));
1332   3                              printd ("                          \n");
1333   3                              break;
1334   3                      case IO_DBG_PCI_CONFIGURATION_WRITE_ACK:        // 0xD9
1335   3                              if (pbuf[2])
1336   3                                      return IO_COMMAND_ERROR;
1337   3                              break;
1338   3                      case IO_DBG_WIFI_REG_READ_RESP:
1339   3                              if (pbuf[2] != 4)
1340   3                                      return IO_COMMAND_ERROR;
1341   3                              printd ("\r");
1342   3                              printd ("%08lx", *((U32_T XDATA*)&pbuf[3]));
1343   3                              printd ("                          \n");
1344   3                              break;
1345   3                      case IO_DBG_WIFI_REG_WRITE_ACK:
1346   3                              if (pbuf[2])
1347   3                                      return IO_COMMAND_ERROR;
1348   3                              break;
1349   3                      case IO_DBG_WIFI_PACKET_FILTERING_WRITE_ACK:
1350   3                              if (pbuf[2])
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 23  

1351   3                                      return IO_COMMAND_ERROR;
1352   3                              printd("\n Set packet filtering successful!!\n");
1353   3                              break;
1354   3                      case IO_DBG_WIFI_PACKET_FILTERING_READ_RESP:
1355   3                              if (pbuf[2] != 9)
1356   3                                      return IO_COMMAND_ERROR;
1357   3                              if (!(pbuf[3] & 0x07))
1358   3                              {
1359   4                                      printd ("\n No filtering!!!\n");
1360   4                                      break;
1361   4                              }
1362   3                              if (pbuf[3] & BIT0)
1363   3                              {
1364   4                                      printd ("\n Filtering type:\n");
1365   4                                      printd (" 1.Filter management frame.\n");
1366   4                                      if (pbuf[5] & BIT0)
1367   4                                              printd ("\tFilter Association request.\n");
1368   4                                      if (pbuf[5] & BIT1)
1369   4                                              printd ("\tFilter Association response.\n");
1370   4                                      if (pbuf[5] & BIT2)
1371   4                                              printd ("\tFilter Re-associate request.\n");
1372   4                                      if (pbuf[5] & BIT3)
1373   4                                              printd ("\tFilter Re-associate response.\n");
1374   4                                      if (pbuf[5] & BIT4)
1375   4                                              printd ("\tFilter Probe request.\n");
1376   4                                      if (pbuf[5] & BIT5)
1377   4                                              printd ("\tFilter Probe response.\n");
1378   4                                      if (pbuf[5] & BIT6)
1379   4                                              printd ("\tFilter Reserve 1.\n");
1380   4                                      if (pbuf[5] & BIT7)
1381   4                                              printd ("\tFilter Reserve 2.\n");
1382   4                                      if (pbuf[4] & BIT0)
1383   4                                              printd ("\tFilter Beacon.\n");
1384   4                                      if (pbuf[4] & BIT1)
1385   4                                              printd ("\tFilter ATIM.\n");
1386   4                                      if (pbuf[4] & BIT2)
1387   4                                              printd ("\tFilter De-associate.\n");
1388   4                                      if (pbuf[4] & BIT3)
1389   4                                              printd ("\tFilter Authentication.\n");
1390   4                                      if (pbuf[4] & BIT4)
1391   4                                              printd ("\tFilter De-authentication.\n");
1392   4                                      if (pbuf[4] & BIT5)
1393   4                                              printd ("\tFilter Action.\n");
1394   4                                      if (pbuf[4] & BIT6)
1395   4                                              printd ("\tFilter Reserve 3.\n");
1396   4                                      if (pbuf[4] & BIT7)
1397   4                                              printd ("\tFilter Reserve 4.\n");
1398   4                              }
1399   3                              if (pbuf[3] & BIT1)
1400   3                                      printd (" 2.Filter data frame.\n");
1401   3                              if (pbuf[3] & BIT2)
1402   3                                      printd (" 3.Filter broadcast/multicast.\n");
1403   3                              printd (" BSSID to filter:\n\t");
1404   3                              for (temp = 6; temp < 12; temp++)
1405   3                                      printd (" %02bx", pbuf[temp]);
1406   3                              printd ("\n");
1407   3                              break;
1408   3                      case IO_DBG_SYNTHESIZER_SET_ACK:
1409   3                              if (pbuf[2])
1410   3                                      return IO_COMMAND_ERROR;
1411   3                              printd("\r Set synthesizer successful!!\n");
1412   3                              break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 24  

1413   3                      case IO_DBG_RETRY_NUMBER_RESP:
1414   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1415   3                              {
1416   4                                      if (pbuf[2] != 1)
1417   4                                              return IO_COMMAND_ERROR;
1418   4                              }
1419   3                              else if (!pbuf[3])
1420   3                              {
1421   4                                      if (pbuf[2] != 2)
1422   4                                              return IO_COMMAND_ERROR;
1423   4                                      printd ("\r Read Max Retry Counter: %bu\n\r", pbuf[4]);
1424   4                              }
1425   3                              else
1426   3                                      return IO_COMMAND_ERROR;
1427   3                              break;
1428   3                      case IO_GPIO_ZERO_RESP:
1429   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1430   3                              {
1431   4                                      if (pbuf[2] != 1)
1432   4                                              return IO_COMMAND_ERROR;
1433   4                              }
1434   3                              else if (!pbuf[3])
1435   3                              {
1436   4                                      if (pbuf[2] != 2)
1437   4                                              return IO_COMMAND_ERROR;
1438   4                                      printd ("P0: %bX\n\r", pbuf[4]);
1439   4                              }
1440   3                              else
1441   3                                      return IO_COMMAND_ERROR;
1442   3                              break;
1443   3                      case IO_GPIO_ONE_RESP:
1444   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1445   3                              {
1446   4                                      if (pbuf[2] != 1)
1447   4                                              return IO_COMMAND_ERROR;
1448   4                              }
1449   3                              else if (!pbuf[3])
1450   3                              {
1451   4                                      if (pbuf[2] != 2)
1452   4                                              return IO_COMMAND_ERROR;
1453   4                                      printd ("P1: %bX\n\r", pbuf[4]);
1454   4                              }
1455   3                              else
1456   3                                      return IO_COMMAND_ERROR;
1457   3                              break;
1458   3                      case IO_GPIO_TWO_RESP:
1459   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1460   3                              {
1461   4                                      if (pbuf[2] != 1)
1462   4                                              return IO_COMMAND_ERROR;
1463   4                              }
1464   3                              else if (!pbuf[3])
1465   3                              {
1466   4                                      if (pbuf[2] != 2)
1467   4                                              return IO_COMMAND_ERROR;
1468   4                                      printd ("P2: %bX\n\r", pbuf[4]);
1469   4                              }
1470   3                              else
1471   3                                      return IO_COMMAND_ERROR;
1472   3                              break;
1473   3                      case IO_GPIO_THREE_RESP:
1474   3                              if (pbuf[3] == IO_COMMAND_WRITE)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 25  

1475   3                              {
1476   4                                      if (pbuf[2] != 1)
1477   4                                              return IO_COMMAND_ERROR;
1478   4                              }
1479   3                              else if (!pbuf[3])
1480   3                              {
1481   4                                      if (pbuf[2] != 2)
1482   4                                              return IO_COMMAND_ERROR;
1483   4                                      printd ("P3: %bX\n\r", pbuf[4]);
1484   4                              }
1485   3                              else
1486   3                                      return IO_COMMAND_ERROR;
1487   3                              break;
1488   3                      case IO_DBG_AUTO_POWER_CONTROL_RESP:
1489   3                              if (pbuf[3] == IO_COMMAND_WRITE)
1490   3                              {
1491   4                                      if (pbuf[2] != 1)
1492   4                                              return IO_COMMAND_ERROR;
1493   4                                      printd ("successfully.\n\r");
1494   4                              }
1495   3                              else
1496   3                                      return IO_COMMAND_ERROR;
1497   3                              break;
1498   3                      default:
1499   3                              return IO_COMMAND_ERROR;
1500   3                      }
1501   2              }
1502   1      
1503   1              return IO_COMMAND_DONE;
1504   1      }
1505          
1506          void io_WlanDebug1Resp(void)
1507          {
1508   1              MWIF_Send(IO_WLAN_DEBUG1_RESP, NULL, 0);
1509   1      
1510   1      } /* End of IO_WlanDebug1 */
1511          
1512          /*
1513           * ----------------------------------------------------------------------------
1514           * Function Name: IO_NoticeWcpu
1515           * Purpose: To management CPU connect, disconnect, and ready commands
1516           * Params: U8_T  type - The type of the command
1517           *         U8_T* pbuf - The start pointer of the payload buffer
1518           *         U8_T  len  - Length of the payload
1519           * Returns: none
1520           * Note: none
1521           * ----------------------------------------------------------------------------
1522           */
1523          void IO_NoticeWcpu(U8_T type, U8_T* pbuf, U8_T len)
1524          {
1525   1              if (MCPU_WcpuReady || type == IO_MCPU_WCPU_READY)
1526   1              {
1527   2                      MWIF_Send(type, pbuf, len);
1528   2              }
1529   1      
1530   1      } /* End of IO_NoticeWcpu() */
1531          
1532          /*
1533           * ----------------------------------------------------------------------------
1534           * Function Name: IO_Reset
1535           * Purpose: To ask WCPU reset itself
1536           * Params: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 26  

1537           * Returns: none
1538           * Note: none
1539           * ----------------------------------------------------------------------------
1540           */
1541          void IO_Reset(void)
1542          {
1543   1              MWIF_Send(IO_WCPU_RESET, NULL, 0);
1544   1      
1545   1      }       /* End of IO_Reset */
1546          
1547          /*
1548           * ----------------------------------------------------------------------------
1549           * Function Name: IO_Scan
1550           * Purpose: To ask WCPU to do scanning
1551           * Params: none
1552           * Returns: none
1553           * Note: none
1554           * ----------------------------------------------------------------------------
1555           */
1556          void IO_Scan(void)
1557          {
1558   1              MWIF_Send(IO_SCAN, NULL, 0);
1559   1      
1560   1      }       /* End of IO_Scan */
1561          
1562          /*
1563           * ----------------------------------------------------------------------------
1564           * Function Name: IO_SiteSurvey
1565           * Purpose: To ask WCPU to do site survey
1566           * Params: none
1567           * Returns: none
1568           * Note: none
1569           * ----------------------------------------------------------------------------
1570           */
1571          void IO_SiteSurvey(void)
1572          {
1573   1              MWIF_Send(IO_SITE_SURVEY, NULL, 0);
1574   1      
1575   1      }       /* End of IO_SiteSurvey */
1576          
1577          /*
1578           * ----------------------------------------------------------------------------
1579           * Function Name: IO_JoinBss
1580           * Purpose: To ask WCPU to join the BSS
1581           * Params: U8_T value - The index of the BSS
1582           * Returns: none
1583           * Note: none
1584           * ----------------------------------------------------------------------------
1585           */
1586          void IO_JoinBss(U8_T value)
1587          {
1588   1              MWIF_Send(IO_JOIN_BSS, &value, 1);
1589   1      
1590   1              MWIFAPP_TaskIOJoinBss(value);
1591   1      
1592   1      }       /* End of IO_JoinBss */
1593          
1594          /*
1595           * ----------------------------------------------------------------------------
1596           * Function Name: IO_SsidRW
1597           * Purpose: To ask WCPU to write SSID string or get the SSID string from WCPU
1598           * Params: U8_T  type - 0: read command 1: write command
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 27  

1599           *         U8_T  len - The length of SSID string
1600           *         U8_T* pReg - Start pointer of the buffer to save SSID string
1601           * Returns: none
1602           * Note: none
1603           * ----------------------------------------------------------------------------
1604           */
1605          void IO_SsidRW(U8_T type, U8_T len, U8_T XDATA* pReg)
1606          {
1607   1              if (type == IO_COMMAND_WRITE)
1608   1              {
1609   2                      MWIF_Send(IO_SSID_WRITE, pReg, len);
1610   2              }
1611   1              else
1612   1              {
1613   2                      MWIF_Send(IO_SSID_READ, NULL, 0);
1614   2              }
1615   1      }       /* End of IO_SsidRW */
1616          
1617          /*
1618           * ----------------------------------------------------------------------------
1619           * Function Name: IO_OperateModeRW
1620           * Purpose: To ask WCPU to set operation mode or get operation mode from WCPU
1621           * Params: U8_T type - 0: read command 1: write command
1622           *         U8_T value - the mode to operate
1623           * Returns: none
1624           * Note: none
1625           * ----------------------------------------------------------------------------
1626           */
1627          void IO_OperateModeRW(U8_T type, U8_T value)
1628          {
1629   1              U8_T    len;
1630   1      
1631   1              if (type == IO_COMMAND_WRITE)
1632   1              {
1633   2                      len = 2;
1634   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1635   2                      io_TxBuf[1] = value;
1636   2              }
1637   1              else
1638   1              {
1639   2                      len = 1;
1640   2                      io_TxBuf[0] = IO_COMMAND_READ;
1641   2              }
1642   1      
1643   1              MWIF_Send(IO_OPERATE_MODE, io_TxBuf, len);
1644   1              
1645   1      }       /* End of IO_OperateModeRW */
1646          
1647          /*
1648           * ----------------------------------------------------------------------------
1649           * Function Name: IO_ChannelRW
1650           * Purpose: To ask WCPU to set channel number or get channel number from WCPU
1651           * Params: U8_T type - 0: read command 1: write command
1652           *         U8_T value - The channel number
1653           * Returns: none
1654           * Note: none
1655           * ----------------------------------------------------------------------------
1656           */
1657          void IO_ChannelRW(U8_T type, U8_T value)
1658          {
1659   1              U8_T    len;
1660   1      
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 28  

1661   1              if (type == IO_COMMAND_WRITE)
1662   1              {
1663   2                      len = 2;
1664   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1665   2                      io_TxBuf[1] = value;
1666   2              }
1667   1              else
1668   1              {
1669   2                      len = 1;
1670   2                      io_TxBuf[0] = IO_COMMAND_READ;
1671   2              }
1672   1      
1673   1              MWIF_Send(IO_CHANNEL, io_TxBuf, len);
1674   1              
1675   1      }       /* End of IO_ChannelRW */
1676          
1677          /*
1678           * ----------------------------------------------------------------------------
1679           * Function Name: IO_NetworkModeRW
1680           * Purpose: To ask WCPU to set network mode or get network mode from WCPU
1681           * Params: U8_T type - 0: read command 1: write command
1682           *         U8_T value - the mode of network
1683           * Returns: none
1684           * Note: none
1685           * ----------------------------------------------------------------------------
1686           */
1687          void IO_NetworkModeRW(U8_T type, U8_T value)
1688          {
1689   1              U8_T    len;
1690   1      
1691   1              if (type == IO_COMMAND_WRITE)
1692   1              {
1693   2                      len = 2;
1694   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1695   2                      io_TxBuf[1] = value;
1696   2              }
1697   1              else
1698   1              {
1699   2                      len = 1;
1700   2                      io_TxBuf[0] = IO_COMMAND_READ;
1701   2              }
1702   1      
1703   1              MWIF_Send(IO_NETWORK_MODE, io_TxBuf, len);
1704   1              
1705   1      }       /* End of IO_NetworkModeRW */
1706          
1707          /*
1708           * ----------------------------------------------------------------------------
1709           * Function Name: IO_SetMulticastMac
1710           * Purpose: To ask WCPU to set multicast MAC support or get Tx data rate from WCPU
1711           * Params: U8_T  rw - 0: read command 1: write command
1712           *         U8_T* pMulticastMac - Start pointer of the buffer to save the multicast
1713           *                               MAC setting
1714           * Returns: none
1715           * Note: none
1716           * ----------------------------------------------------------------------------
1717           */
1718          void IO_SetMulticastMac(U8_T XDATA* pMulticastMac)
1719          {
1720   1              MWIF_Send(IO_MULTICAST_SET, pMulticastMac, 6);
1721   1              
1722   1      }       /* End of IO_SetMulticastMac */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 29  

1723          
1724          /*
1725           * ----------------------------------------------------------------------------
1726           * Function Name: IO_WiFiMacRW
1727           * Purpose: To ask WCPU to set WiFi MAC address or get WiFi MAC address from WCPU
1728           * Params: U8_T  type - 0: read command 1: write command
1729           *         U8_T* pReg - Start pointer of the buffer to WiFi MAC address
1730           * Returns: none
1731           * Note: none
1732           * ----------------------------------------------------------------------------
1733           */
1734          void IO_WiFiMacRW(U8_T type, U8_T XDATA* pReg)
1735          {
1736   1              U8_T    len;
1737   1                      
1738   1              if (type == IO_COMMAND_WRITE)
1739   1              {
1740   2                      len = 7;
1741   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1742   2                      memcpy(&io_TxBuf[1], pReg, 6);
1743   2              }
1744   1              else
1745   1              {
1746   2                      len = 1;
1747   2                      io_TxBuf[0] = IO_COMMAND_READ;
1748   2              }
1749   1      
1750   1              MWIF_Send(IO_WIFI_MAC_ADDR_SET, io_TxBuf, len);
1751   1              
1752   1      }       /* End of IO_WiFiMacRW */
1753          
1754          /*
1755           * ----------------------------------------------------------------------------
1756           * Function Name: IO_RadioOnOff
1757           * Purpose: To ask WCPU to enable or disable the RF or read the state
1758           * Params: U8_T state - 0: disable RF, 1: enable RF
1759           * Returns: none
1760           * Note: none
1761           * ----------------------------------------------------------------------------
1762           */
1763          U8_T IO_RadioOnOff(U8_T state)
1764          {       
1765   1              MWIF_Send(IO_WIFI_RADIO_ON_OFF, &state, 1);
1766   1      
1767   1              return 0;
1768   1      
1769   1      }       /* End of IO_RadioOnOff */
1770          
1771          /*
1772           * ----------------------------------------------------------------------------
1773           * Function Name: IO_BgProtection
1774           * Purpose: To ask WCPU to set the mode of bg protection
1775           * Params: U8_T state - xxxxx
1776           * Returns: none
1777           * Note: none
1778           * ----------------------------------------------------------------------------
1779           */
1780          void IO_BgProtectionRW(U8_T type, U8_T state)
1781          {
1782   1              U8_T    len;
1783   1              
1784   1              if (type == IO_COMMAND_WRITE)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 30  

1785   1              {
1786   2                      len = 2;
1787   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1788   2                      io_TxBuf[1] = state;
1789   2              }
1790   1              else
1791   1              {
1792   2                      len = 1;
1793   2                      io_TxBuf[0] = IO_COMMAND_READ;
1794   2              }
1795   1      
1796   1              MWIF_Send(IO_WIFI_B_G_PROTECTION, io_TxBuf, len);
1797   1      
1798   1      }       /* End of IO_BgProtection */
1799          
1800          /*
1801           * ----------------------------------------------------------------------------
1802           * Function Name: IO_EncryptionRW
1803           * Purpose: To ask WCPU to set encryption status or get encryption status from WCPU
1804           * Params: U8_T type - 0: read command 1: write command
1805           *         U8_T value - 0: disable encryption 1: enable encryption
1806           * Returns: none
1807           * Note: none
1808           * ----------------------------------------------------------------------------
1809           */
1810          void IO_EncryptionRW(U8_T type, U8_T value)
1811          {
1812   1              U8_T    len;
1813   1      
1814   1              if (type == IO_COMMAND_WRITE)
1815   1              {
1816   2                      len = 2;
1817   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1818   2                      io_TxBuf[1] = value;
1819   2              }
1820   1              else
1821   1              {
1822   2                      len = 1;
1823   2                      io_TxBuf[0] = IO_COMMAND_READ;
1824   2              }
1825   1      
1826   1              MWIF_Send(IO_ENCRYPTION_TYPE, io_TxBuf, len);
1827   1              
1828   1      }       /* End of IO_EncryptionRW */
1829          
1830          /*
1831           * ----------------------------------------------------------------------------
1832           * Function Name: IO_OpenSysRW
1833           * Purpose: To ask WCPU to enable/disable open system or get the status of
1834           *          open system from WCPU
1835           * Params: U8_T type - 0: read command 1: write command
1836           *         U8_T value - enable/disable open system
1837           * Returns: none
1838           * Note: none
1839           * ----------------------------------------------------------------------------
1840           */
1841          void IO_OpenSysRW(U8_T type, U8_T value)
1842          {
1843   1              U8_T    len;
1844   1      
1845   1              if (type == IO_COMMAND_WRITE)
1846   1              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 31  

1847   2                      len = 2;
1848   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1849   2                      io_TxBuf[1] = value;
1850   2              }
1851   1              else
1852   1              {
1853   2                      len = 1;
1854   2                      io_TxBuf[0] = IO_COMMAND_READ;
1855   2              }
1856   1      
1857   1              MWIF_Send(IO_OPEN_SYSTEM, io_TxBuf, len);
1858   1              
1859   1      }       /* End of IO_OpenSysRW */
1860          
1861          /*
1862           * ----------------------------------------------------------------------------
1863           * Function Name: IO_Wep64KeyRW
1864           * Purpose: To ask WCPU to write WEP64 key or get the WEP64 key from WCPU
1865           * Params: U8_T  type - 0: read command 1: write command
1866           *         U8_T  index - The index of WEP64 key
1867           *         U8_T* pReg - Start pointer of the buffer to save WEP64 key
1868           * Returns: none
1869           * Note: none
1870           * ----------------------------------------------------------------------------
1871           */
1872          void IO_Wep64KeyRW(U8_T type, U8_T index, U8_T XDATA* pReg)
1873          {
1874   1              io_TxBuf[0] = index;
1875   1              
1876   1              if (type == IO_COMMAND_WRITE)
1877   1              {
1878   2                      memcpy(&io_TxBuf[1], pReg, 5);
1879   2      
1880   2                      MWIF_Send(IO_WEP64_KEY_WRITE, io_TxBuf, 6);
1881   2              }
1882   1              else
1883   1              {
1884   2                      MWIF_Send(IO_WEP64_KEY_READ, io_TxBuf, 1);
1885   2              }
1886   1      }       /* End of IO_Wep64KeyRW */
1887          
1888          /*
1889           * ----------------------------------------------------------------------------
1890           * Function Name: IO_Wep128KeyRW
1891           * Purpose: To ask WCPU to write WEP128 key or get the WEP128 key from WCPU
1892           * Params: U8_T  type - 0: read command 1: write command
1893           *         U8_T  index - The index of WEP128 key
1894           *         U8_T* pReg - Start pointer of the buffer to save WEP128 key
1895           * Returns: none
1896           * Note: none
1897           * ----------------------------------------------------------------------------
1898           */
1899          void IO_Wep128KeyRW(U8_T type, U8_T index, U8_T XDATA* pReg)
1900          {
1901   1              io_TxBuf[0] = index;
1902   1      
1903   1              if (type == IO_COMMAND_WRITE)
1904   1              {
1905   2                      memcpy(&io_TxBuf[1], pReg, 13);
1906   2      
1907   2                      MWIF_Send(IO_WEP128_KEY_WRITE, io_TxBuf, 14);
1908   2              }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 32  

1909   1              else
1910   1              {
1911   2                      MWIF_Send(IO_WEP128_KEY_READ, io_TxBuf, 1);
1912   2              }
1913   1      }       /* End of IO_Wep128KeyRW */
1914          
1915          /*
1916           * ----------------------------------------------------------------------------
1917           * Function Name: IO_WepKeyIndexRW
1918           * Purpose: To ask WCPU to set WEP key index or get WEP key index from WCPU
1919           * Params: U8_T type - 0: read command 1: write command
1920           *         U8_T value - WEP key index
1921           * Returns: none
1922           * Note: none
1923           * ----------------------------------------------------------------------------
1924           */
1925          void IO_WepKeyIndexRW(U8_T type, U8_T value)
1926          {
1927   1              U8_T    len;
1928   1      
1929   1              if (type == IO_COMMAND_WRITE)
1930   1              {
1931   2                      len = 2;
1932   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
1933   2                      io_TxBuf[1] = value;
1934   2              }
1935   1              else
1936   1              {
1937   2                      len = 1;
1938   2                      io_TxBuf[0] = IO_COMMAND_READ;
1939   2              }
1940   1      
1941   1              MWIF_Send(IO_WEP_KEY_INDEX, io_TxBuf, len);
1942   1              
1943   1      }       /* End of IO_WepKeyIndexRW */
1944          
1945          /*
1946           * ----------------------------------------------------------------------------
1947           * Function Name: IO_TkipAesRW
1948           * Purpose: To ask WCPU to write TKIP/AES string or get the TKIP/AES string from WCPU
1949           * Params: U8_T  type - 0: read command 1: write command
1950           *         U8_T  len - The length of TKIP/AES string
1951           *         U8_T* pReg - Start pointer of the buffer to save TKIP/AES string
1952           * Returns: none
1953           * Note: none
1954           * ----------------------------------------------------------------------------
1955           */
1956          void IO_TkipAesRW(U8_T type, U8_T len, U8_T XDATA* pReg)
1957          {
1958   1              if (type == IO_COMMAND_WRITE)
1959   1              {
1960   2                      MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_WRITE, pReg, len);
1961   2              }
1962   1              else
1963   1              {
1964   2                      MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_READ, NULL, 0);
1965   2              }
1966   1      }       /* End of IO_TkipAesRW */
1967          
1968          /*
1969           * ----------------------------------------------------------------------------
1970           * Function Name: IO_FragmentThresholdRW
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 33  

1971           * Purpose: To ask WCPU to set fragment threshold or reply a acknowledgement to WCPU
1972           * Params: U8_T  type - 0: read command 1: write command
1973           *         U8_T* pValue - Start pointer of the buffer to save fragment threshold value
1974           * Returns: none
1975           * Note: none
1976           * ----------------------------------------------------------------------------
1977           */
1978          void IO_FragmentThresholdRW(U8_T type, U8_T XDATA* pValue)
1979          {
1980   1              if (type == IO_COMMAND_WRITE)
1981   1              {
1982   2                      io_TxBuf[0] = *pValue;
1983   2                      io_TxBuf[1] = *(pValue + 1);
1984   2      
1985   2                      MWIF_Send(IO_FRAGMENT_THRESHOLD_WRITE, io_TxBuf, 2);
1986   2              }
1987   1              else
1988   1              {
1989   2                      MWIF_Send(IO_FRAGMENT_THRESHOLD_READ, NULL, 0);
1990   2              }
1991   1      
1992   1      }       /* End of IO_FragmentThresholdRW */
1993          
1994          /*
1995           * ----------------------------------------------------------------------------
1996           * Function Name: IO_RtsThresholdRW
1997           * Purpose: To ask WCPU to set RTS threshold or reply a acknowledgement to WCPU
1998           * Params: U8_T  type - 0: read command 1: write command
1999           *         U8_T* pValue - Start pointer of the buffer to save RTS threshold value
2000           * Returns: none
2001           * Note: none
2002           * ----------------------------------------------------------------------------
2003           */
2004          void IO_RtsThresholdRW(U8_T type, U8_T XDATA* pValue)
2005          {
2006   1              if (type == IO_COMMAND_WRITE)
2007   1              {
2008   2                      io_TxBuf[0] = *pValue;
2009   2                      io_TxBuf[1] = *(pValue + 1);
2010   2      
2011   2                      MWIF_Send(IO_RTS_THRESHOLD_WRITE, io_TxBuf, 2);
2012   2              }
2013   1              else
2014   1              {
2015   2                      MWIF_Send(IO_RTS_THRESHOLD_READ, NULL, 0);
2016   2              }
2017   1      
2018   1      }       /* End of IO_RtsThresholdRW */
2019          
2020          /*
2021           * ----------------------------------------------------------------------------
2022           * Function Name: IO_PreambleRW
2023           * Purpose: To ask WCPU to set long/short preamble or get the preamble status
2024           *          from WCPU
2025           * Params: U8_T type - 0: read command 1: write command
2026           *         U8_T value - long/short preamble
2027           * Returns: none
2028           * Note: none
2029           * ----------------------------------------------------------------------------
2030           */
2031          void IO_PreambleRW(U8_T type, U8_T value)
2032          {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 34  

2033   1              U8_T    len;
2034   1      
2035   1              if (type == IO_COMMAND_WRITE)
2036   1              {
2037   2                      len = 2;
2038   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2039   2                      io_TxBuf[1] = value;
2040   2              }
2041   1              else
2042   1              {
2043   2                      len = 1;
2044   2                      io_TxBuf[0] = IO_COMMAND_READ;
2045   2              }
2046   1      
2047   1              MWIF_Send(IO_PREAMBLE, io_TxBuf, len);
2048   1              
2049   1      }       /* End of IO_PreambleRW */
2050          
2051          /*
2052           * ----------------------------------------------------------------------------
2053           * Function Name: IO_TxGainRW
2054           * Purpose: To ask WCPU to set Tx power gain or get Tx power gain from WCPU
2055           * Params: U8_T rw - 0: read command 1: write command
2056           *         U8_T txGain - the Tx power gain value
2057           * Returns: none
2058           * Note: none
2059           * ----------------------------------------------------------------------------
2060           */
2061          void IO_TxGainRW(U8_T rw, U8_T txGain)
2062          {
2063   1              if (rw == IO_COMMAND_WRITE)
2064   1              {
2065   2                      io_TxBuf[0] = txGain;
2066   2      
2067   2                      MWIF_Send(IO_TX_POWER_LEVEL_WRITE, io_TxBuf, 1);
2068   2              }
2069   1              else
2070   1              {
2071   2                      MWIF_Send(IO_TX_POWER_LEVEL_READ, NULL, 0);
2072   2              }
2073   1      
2074   1      }       /* End of IO_TxGainRW */
2075          
2076          /*
2077           * ----------------------------------------------------------------------------
2078           * Function Name: IO_BeaconIntervalRW
2079           * Purpose: To ask WCPU to set beacon interval or reply a acknowedgement to WCPU
2080           * Params: U8_T  type - 0: read command 1: write command
2081           *         U8_T* pValue - Start pointer of the buffer to save beacon interval value
2082           * Returns: none
2083           * Note: none
2084           * ----------------------------------------------------------------------------
2085           */
2086          void IO_BeaconIntervalRW(U8_T type, U8_T* pValue)
2087          {
2088   1              if (type == IO_COMMAND_WRITE)
2089   1              {
2090   2                      io_TxBuf[0] = *pValue;
2091   2                      io_TxBuf[1] = *(pValue + 1);
2092   2      
2093   2                      MWIF_Send(IO_BEACON_INTERVAL_WRITE, io_TxBuf, 2);
2094   2              }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 35  

2095   1              else
2096   1              {
2097   2                      MWIF_Send(IO_BEACON_INTERVAL_READ, NULL, 0);
2098   2              }
2099   1      
2100   1      }       /* End of IO_BeaconIntervalRW */
2101          
2102          /*
2103           * ----------------------------------------------------------------------------
2104           * Function Name: IO_CountryRegionRW
2105           * Purpose: To ask WCPU to set country region or get country region from WCPU
2106           * Params: U8_T type - 0: read command 1: write command
2107           *         U8_T value - The country region value
2108           * Returns: none
2109           * Note: none
2110           * ----------------------------------------------------------------------------
2111           */
2112          void IO_CountryRegionRW(U8_T type, U16_T value)
2113          {
2114   1              U8_T    len;
2115   1      
2116   1              if (type == IO_COMMAND_WRITE)
2117   1              {
2118   2                      len = 3;
2119   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2120   2                      io_TxBuf[1] = value >> 8;
2121   2                      io_TxBuf[2] = (U8_T)value;
2122   2              }
2123   1              else
2124   1              {
2125   2                      len = 1;
2126   2                      io_TxBuf[0] = IO_COMMAND_READ;
2127   2              }
2128   1      
2129   1              MWIF_Send(IO_COUNTRY_REGION, io_TxBuf, len);
2130   1      
2131   1      }       /* End of IO_CountryRegionRW */
2132          
2133          /*
2134           * ----------------------------------------------------------------------------
2135           * Function Name: IO_AtimIntervalRW
2136           * Purpose: To ask WCPU to set ATIM interval or reply a acknowedgement to WCPU
2137           * Params: U8_T  type - 0: read command 1: write command
2138           *         U8_T* pValue - Start pointer of the buffer to save ATIM interval value
2139           * Returns: none
2140           * Note: none
2141           * ----------------------------------------------------------------------------
2142           */
2143          void IO_AtimIntervalRW(U8_T type, U8_T XDATA* pValue)
2144          {
2145   1              if (type == IO_COMMAND_WRITE)
2146   1              {
2147   2                      io_TxBuf[0] = *pValue;
2148   2                      io_TxBuf[1] = *(pValue + 1);
2149   2      
2150   2                      MWIF_Send(IO_ATIM_INTERVAL_WRITE, io_TxBuf, 2);
2151   2              }
2152   1              else
2153   1              {
2154   2                      MWIF_Send(IO_ATIM_INTERVAL_READ, NULL, 0);
2155   2              }
2156   1      
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 36  

2157   1      }       /* End of IO_AtimIntervalRW */
2158          
2159          /*
2160           * ----------------------------------------------------------------------------
2161           * Function Name: IO_TxDataRateRW
2162           * Purpose: To ask WCPU to set Tx data rate or get Tx data rate from WCPU
2163           * Params: U8_T rw - 0: read command 1: write command
2164           *         U8_T txRate - the Tx data rate
2165           * Returns: U8_T result - 0x00: success 
2166           *                        0xFF: fail
2167           * Note: none
2168           * ----------------------------------------------------------------------------
2169           */
2170          U8_T IO_TxDataRateRW(U8_T rw, U8_T txRate)
2171          {
2172   1              U8_T XDATA result = 0xff;
2173   1              U8_T    len;
2174   1      
2175   1              if (rw == IO_COMMAND_WRITE)
2176   1              {
2177   2                      len = 2;
2178   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2179   2                      switch (txRate)
2180   2                      {
2181   3                      case 0:
2182   3                      case 0x02:
2183   3                      case 0x04:
2184   3                      case 0x0B:
2185   3                      case 0x0C:
2186   3                      case 0x12:
2187   3                      case 0x16:
2188   3                      case 0x18:
2189   3                      case 0x24:
2190   3                      case 0x30:
2191   3                      case 0x48:
2192   3                      case 0x60:
2193   3                      case 0x6C:
2194   3                              io_TxBuf[1] = txRate;
2195   3                              break;
2196   3                      default:
2197   3                              return result;
2198   3                      }
2199   2              }
2200   1              else
2201   1              {
2202   2                      len = 1;
2203   2                      io_TxBuf[0] = IO_COMMAND_READ;
2204   2              }
2205   1              result = 0;
2206   1              
2207   1              MWIF_Send(IO_TX_DATA_RATE,io_TxBuf, len);
2208   1              
2209   1              return result;
2210   1              
2211   1      }       /* End of IO_TxDataRateRW */
2212          
2213          /*
2214           * ----------------------------------------------------------------------------
2215           * Function Name: IO_AutoPowerCtrlRW
2216           * Purpose: To ask WCPU to enable/disable "WiFi Tx auto power control" function
2217           *          or get the status from WCPU
2218           * Params: U8_T type - 0: read command 1: write command
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 37  

2219           *         U8_T OnOff - 0: Off 1: ON
2220           * Returns: none
2221           * Note: none
2222           * ----------------------------------------------------------------------------
2223           */
2224          void IO_AutoPowerCtrlRW(U8_T type, U8_T OnOff)
2225          {
2226   1              U8_T    len;
2227   1              
2228   1              if (type == IO_COMMAND_WRITE)
2229   1              {
2230   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2231   2                      io_TxBuf[1] = OnOff;
2232   2                      switch (OnOff)
2233   2                      {
2234   3                      case 0:
2235   3                      case 1:
2236   3                              len = 2;
2237   3                              break;
2238   3                      }
2239   2              }
2240   1              else
2241   1              {
2242   2                      len = 1;
2243   2                      io_TxBuf[0] = IO_COMMAND_READ;
2244   2              }
2245   1              
2246   1              MWIF_Send(IO_AUTO_POWER_CONTROL, io_TxBuf, len);
2247   1              
2248   1      }       /* End of IO_AutoPowerCtrlRW */
2249          
2250          /*
2251           * ----------------------------------------------------------------------------
2252           * Function Name: IO_AutoPowerCtrlDetailW
2253           * Purpose: To ask WCPU to enable/disable "WiFi Tx auto power control" function
2254           *          or get the status from WCPU
2255           * Params: U8_T value - the set point value
2256           * Returns: none
2257           * Note: none
2258           * ----------------------------------------------------------------------------
2259           */
2260          void IO_AutoPowerCtrlDetailW(U8_T value)
2261          {
2262   1              U8_T    len;
2263   1              
2264   1              io_TxBuf[0] = IO_COMMAND_WRITE;
2265   1              len = 3;
2266   1              io_TxBuf[1] = 2;
2267   1              io_TxBuf[2] = value;
2268   1              
2269   1              MWIF_Send(IO_DBG_AUTO_POWER_CONTROL, io_TxBuf, len);
2270   1              
2271   1      }       /* End of IO_AutoPowerCtrlDetailW */
2272          
2273          /*
2274           * ----------------------------------------------------------------------------
2275           * Function Name: IO_Roaming
2276           * Purpose: To ask WCPU to enable/disable roaming function or get the status from WCPU
2277           * Params: U8_T type - 0: read command 1: write command
2278           *         U8_T value - 0: Off 1: ON
2279           * Returns: none
2280           * Note: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 38  

2281           * ----------------------------------------------------------------------------
2282           */
2283          void IO_Roaming(U8_T type, U8_T value)
2284          {
2285   1              U8_T    len;
2286   1              
2287   1              if (type == IO_COMMAND_WRITE)
2288   1              {
2289   2                      len = 2;
2290   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2291   2                      io_TxBuf[1] = value;
2292   2              }
2293   1              else
2294   1              {
2295   2                      len = 1;
2296   2                      io_TxBuf[0] = IO_COMMAND_READ;
2297   2              }
2298   1              
2299   1              MWIF_Send(IO_WIFI_ROAMING, io_TxBuf, len);
2300   1              
2301   1      }       /* End of IO_Roaming */
2302          
2303          /*
2304           * ----------------------------------------------------------------------------
2305           * Function Name: IO_MultimediaSet
2306           * Purpose: To ask WCPU to enable/disable WiFi Multimedia (WMM) function or get
2307           *          the status from WCPU
2308           * Params: U8_T type - 0: read command 1: write command
2309           *         U8_T value - 0: Off 1: ON
2310           * Returns: none
2311           * Note: none
2312           * ----------------------------------------------------------------------------
2313           */
2314          void IO_WifiMultimediaSet(U8_T type, U8_T value)
2315          {
2316   1              U8_T    len;
2317   1              
2318   1              if (type == IO_COMMAND_WRITE)
2319   1              {
2320   2                      len = 2;
2321   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2322   2                      io_TxBuf[1] = value;
2323   2              }
2324   1              else
2325   1              {
2326   2                      len = 1;
2327   2                      io_TxBuf[0] = IO_COMMAND_READ;
2328   2              }
2329   1              
2330   1              MWIF_Send(IO_WIFI_MULTIMEDIA_SET ,io_TxBuf, len);
2331   1              
2332   1      }       /* End of IO_MultimediaSet */
2333          
2334          /*
2335           * ----------------------------------------------------------------------------
2336           * Function Name: IO_ListenIntervalRW
2337           * Purpose: To ask WCPU to write listen interval value or get
2338           *          the it from WCPU
2339           * Params: U8_T type - 0: read command 1: write command
2340           *         U16_T value - listen interval value
2341           * Returns: none
2342           * Note: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 39  

2343           * ----------------------------------------------------------------------------
2344           */
2345          void IO_ListenIntervalRW(U8_T type, U16_T value)
2346          {
2347   1              U8_T    len;
2348   1      
2349   1              if (type == IO_COMMAND_WRITE)
2350   1              {
2351   2                      len = 3;
2352   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2353   2                      *((U16_T*)&io_TxBuf[1]) = value;
2354   2              }
2355   1              else
2356   1              {
2357   2                      len = 1;
2358   2                      io_TxBuf[0] = IO_COMMAND_READ;
2359   2              }
2360   1              
2361   1              MWIF_Send(IO_LISTEN_INTERVAL, io_TxBuf, len);
2362   1              
2363   1      }       /* End of IO_ListenIntervalRW */
2364          
2365          /*
2366           * ----------------------------------------------------------------------------
2367           * Function Name: IO_MinContentWindowRW
2368           * Purpose: To ask WCPU to write minimum contention window value or get
2369           *          the it from WCPU
2370           * Params: U8_T type - 0: read command 1: write command
2371           *         U16_T value - minimum contention window value
2372           * Returns: none
2373           * Note: none
2374           * ----------------------------------------------------------------------------
2375           */
2376          void IO_MinContentWindowRW(U8_T type, U16_T value)
2377          {
2378   1              U8_T    len;
2379   1              
2380   1              if (type == IO_COMMAND_WRITE)
2381   1              {
2382   2                      len = 3;
2383   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2384   2                      *((U16_T*)&io_TxBuf[1]) = value;
2385   2              }
2386   1              else
2387   1              {
2388   2                      len = 1;
2389   2                      io_TxBuf[0] = IO_COMMAND_READ;
2390   2              }
2391   1              
2392   1              MWIF_Send(IO_MINIMUM_CONTENTION_WINDOW, io_TxBuf, len);
2393   1              
2394   1      }       /* End of IO_MinContentWindowRW */
2395          
2396          /*
2397           * ----------------------------------------------------------------------------
2398           * Function Name: IO_MaxContentWindowRW
2399           * Purpose: To ask WCPU to write maximum contention window value or get
2400           *          the it from WCPU
2401           * Params: U8_T type - 0: read command 1: write command
2402           *         U16_T value - minimum contention window value
2403           * Returns: none
2404           * Note: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 40  

2405           * ----------------------------------------------------------------------------
2406           */
2407          void IO_MaxContentWindowRW(U8_T type, U16_T value)
2408          {
2409   1              U8_T    len;
2410   1      
2411   1              if (type == IO_COMMAND_WRITE)
2412   1              {
2413   2                      len = 3;
2414   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2415   2                      *((U16_T*)&io_TxBuf[1]) = value;
2416   2              }
2417   1              else
2418   1              {
2419   2                      len = 1;
2420   2                      io_TxBuf[0] = IO_COMMAND_READ;
2421   2              }
2422   1              
2423   1              MWIF_Send(IO_MAXIMUM_CONTENTION_WINDOW, io_TxBuf, len);
2424   1              
2425   1      }       /* End of IO_MaxContentWindowRW */
2426          
2427          /*
2428           * ----------------------------------------------------------------------------
2429           * Function Name: IO_ShowRssi
2430           * Purpose: To ask WCPU the RSSI value
2431           * Params: none
2432           * Returns: none
2433           * Note: none
2434           * ----------------------------------------------------------------------------
2435           */
2436          void IO_ShowRssi(void)
2437          {
2438   1              MWIF_Send(IO_SHOW_RSSI, NULL, 0);
2439   1      
2440   1      }       /* End of IO_ShowRssi */
2441          
2442          /*
2443           * ----------------------------------------------------------------------------
2444           * Function Name: IO_PayloadLenAddInWifi
2445           * Purpose: To ask WCPU to enable/disable "Payload Length Attach in WiFi Packet"
2446           *          function or get the status from WCPU
2447           * Params: U8_T type - 0: read command 1: write command
2448           *         U8_T value - 0: Off 1: ON
2449           * Returns: none
2450           * Note: none
2451           * ----------------------------------------------------------------------------
2452           */
2453          void IO_PayloadLenAddInWifi(U8_T type, U8_T value)
2454          {
2455   1              U8_T    len;
2456   1              
2457   1              if (type == IO_COMMAND_WRITE)
2458   1              {
2459   2                      len = 2;
2460   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2461   2                      io_TxBuf[1] = value;
2462   2              }
2463   1              else
2464   1              {
2465   2                      len = 1;
2466   2                      io_TxBuf[0] = IO_COMMAND_READ;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 41  

2467   2              }
2468   1              
2469   1              MWIF_Send(IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET, io_TxBuf, len);
2470   1                      
2471   1      }       /* End of IO_PayloadLenAddInWifi */
2472          
2473          /*
2474           * ----------------------------------------------------------------------------
2475           * Function Name: IO_RetainLlcInWifi
2476           * Purpose: To ask WCPU to enable/disable "Retain LLC in WiFi Packet" function
2477           *          or get the status from WCPU
2478           * Params: U8_T type - 0: read command 1: write command
2479           *         U8_T value - 0: Off 1: ON
2480           * Returns: none
2481           * Note: none
2482           * ----------------------------------------------------------------------------
2483           */
2484          void IO_RetainLlcInWifi(U8_T type, U8_T value)
2485          {
2486   1              U8_T    len;
2487   1      
2488   1              if (type == IO_COMMAND_WRITE)
2489   1              {
2490   2                      len = 2;
2491   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2492   2                      io_TxBuf[1] = value;
2493   2              }
2494   1              else
2495   1              {
2496   2                      len = 1;
2497   2                      io_TxBuf[0] = IO_COMMAND_READ;
2498   2              }
2499   1              
2500   1              MWIF_Send(IO_RETAIN_LLC_IN_WIFI_PACKET, io_TxBuf, len);
2501   1              
2502   1      }       /* End of IO_RetainLlcInWifi */
2503          
2504          /*
2505           * ----------------------------------------------------------------------------
2506           * Function Name: IO_2LlcInWifiVlan
2507           * Purpose: To ask WCPU to enable/disable "2LLC in WiFi VLAN Packet" function
2508           *          or get the status from WCPU
2509           * Params: U8_T type - 0: read command 1: write command
2510           *         U8_T value - 0: Off 1: ON
2511           * Returns: none
2512           * Note: none
2513           * ----------------------------------------------------------------------------
2514           */
2515          void IO_2LlcInWifiVlan(U8_T type, U8_T value)
2516          {
2517   1              U8_T    len;
2518   1              
2519   1              if (type == IO_COMMAND_WRITE)
2520   1              {
2521   2                      len = 2;
2522   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2523   2                      io_TxBuf[1] = value;
2524   2              }
2525   1              else
2526   1              {
2527   2                      len = 1;
2528   2                      io_TxBuf[0] = IO_COMMAND_READ;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 42  

2529   2              }
2530   1              
2531   1              MWIF_Send(IO_2_LLC_IN_WIFI_VLAN_PACKET, io_TxBuf, len);
2532   1              
2533   1      }       /* End of IO_2LlcInWifiVlan */
2534          
2535          /*
2536           * ----------------------------------------------------------------------------
2537           * Function Name: IO_TrafficProfile
2538           * Purpose: To ask WCPU to write traffic profile
2539           *          or get the status from WCPU
2540           * Params: U8_T type - 0: read command 1: write command
2541           *         U8_T value - 0: voice 1: video 2: best effort 3: back ground
2542           * Returns: none
2543           * Note: none
2544           * ----------------------------------------------------------------------------
2545           */
2546          void IO_TrafficProfile(U8_T type, U8_T value)
2547          {
2548   1              U8_T    len;
2549   1              
2550   1              if (type == IO_COMMAND_WRITE)
2551   1              {
2552   2                      len = 2;
2553   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2554   2                      io_TxBuf[1] = value;
2555   2              }
2556   1              else
2557   1              {
2558   2                      len = 1;
2559   2                      io_TxBuf[0] = IO_COMMAND_READ;
2560   2              }
2561   1              
2562   1              MWIF_Send(IO_TRAFFIC_PROFILE, io_TxBuf, len);
2563   1              
2564   1      }       /* End of IO_TrafficProfile */
2565          
2566          /*
2567           * ----------------------------------------------------------------------------
2568           * Function Name: IO_TxDefaultPowerLevelRW
2569           * Purpose: To ask WCPU to set Tx default power level or get Tx default power level from WCPU
2570           * Params: U8_T rw - 0: read command 1: write command
2571           *         U8_T level - 0: 100%, 1: 50%, 2: 25%, 3: 12.5%, 4: 6.25%
2572           * Returns: none
2573           * Note: none
2574           * ----------------------------------------------------------------------------
2575           */
2576          void IO_TxDefaultPowerLevelRW(U8_T rw, U8_T level)
2577          {
2578   1              if (rw == IO_COMMAND_WRITE)
2579   1              {
2580   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2581   2                      io_TxBuf[1] = level;
2582   2      
2583   2                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL, io_TxBuf, 2);
2584   2              }
2585   1              else
2586   1              {
2587   2                      io_TxBuf[0] = IO_COMMAND_READ;
2588   2      
2589   2                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL, io_TxBuf, 1);
2590   2              }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 43  

2591   1      
2592   1      }       /* End of IO_TxDefaultPowerLevelRW */
2593          
2594          /*
2595           * ----------------------------------------------------------------------------
2596           * Function Name: IO_SelfCtsRW
2597           * Purpose: To ask WCPU to set the self-CTS from WCPU
2598           * Params: U8_T  rw - 1: write command 0: read command
2599           *         U8_T  value - 0: OFF, 1: ON
2600           * Returns: none
2601           * Note: none
2602           * ----------------------------------------------------------------------------
2603           */
2604          void IO_SelfCtsRW(U8_T rw, U8_T value)
2605          {
2606   1              U8_T    len;
2607   1              
2608   1              if (rw == IO_COMMAND_WRITE)
2609   1              {
2610   2                      len = 2;
2611   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
2612   2                      io_TxBuf[1] = value;
2613   2              }
2614   1              else
2615   1              {
2616   2                      len = 1;
2617   2                      io_TxBuf[0] = IO_COMMAND_READ;
2618   2              }
2619   1              
2620   1              MWIF_Send(IO_SELF_CTS, io_TxBuf, len);
2621   1              
2622   1      }       /* End of IO_SelfCtsRW */
2623          
2624          /*
2625           * ----------------------------------------------------------------------------
2626           * Function Name: IO_BssidR
2627           * Purpose: To query BSSID from WCPU
2628           * Params: none
2629           * Returns: none
2630           * Note: none
2631           * ----------------------------------------------------------------------------
2632           */
2633          void IO_BssidR(void)
2634          {
2635   1              io_TxBuf[0] = IO_COMMAND_READ;
2636   1              
2637   1              MWIF_Send(IO_BSSID, io_TxBuf, 1);
2638   1              
2639   1      }       /* End of IO_SelfCtsRW */
2640          
2641          /*
2642           * ----------------------------------------------------------------------------
2643           * Function Name: IO_WifiIpR
2644           * Purpose: To query Wifi IP from WCPU
2645           * Params: none
2646           * Returns: none
2647           * Note: none
2648           * ----------------------------------------------------------------------------
2649           */
2650          void IO_WifiIpR(void)
2651          {
2652   1              MWIF_Send(IO_WIFI_IP_READ, io_TxBuf, 0);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 44  

2653   1              
2654   1      }       /* End of IO_WifiIpR */
2655          
2656          #if MASS_PRODUCTION
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_ContinuousTx
               * Purpose: To ask WCPU to enable/disable WiFi continuous Tx function or get
               *          the status from WCPU
               * Params: U8_T mode - 0: Off, 1: CCK, 2: OFDM, 3: CW wave, 4: , 5:
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T IO_ContinuousTx(U8_T mode)
              {
                      if (mode > 5)
                              return IO_COMMAND_ERROR;
              
                      io_TxBuf[0] = mode;
              
                      MWIF_Send(IO_CONTINUOUS_TX, io_TxBuf, 1);
              
                      return IO_COMMAND_DONE;
                      
              }       /* End of IO_ContinuousTx */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SensitivityTest
               * Purpose: To ask WCPU to enable/disable WiFi sensitivity test function or get
               *          the status from WCPU
               * Params: U16_T counts - Amount of the broadcast packet to send
               *         U8_T source - The Golden Unit to send broadcast packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SensitivityTest(U16_T counts, U8_T source)
              {
                      io_TxBuf[0] = (U8_T)(counts >> 8);
                      io_TxBuf[1] = (U8_T)counts;
                      io_TxBuf[2] = source;
              
                      MWIF_Send(IO_SENSITIVITY_TEST, io_TxBuf, 3);
                      
              }       /* End of IO_SensitivityTest */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SensitivityTestReport
               * Purpose: To ask WCPU to report the result of WiFi sensitivity test
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SensitivityTestReport(void)
              {
                      MWIF_Send(IO_SENSITIVITY_TEST_REPORT, NULL, 0);
              
              }       /* End of IO_SensitivityTestReport */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 45  

              #endif
2716          
2717          /*
2718           * ----------------------------------------------------------------------------
2719           * Function Name: IO_SfrRW
2720           * Purpose: To ask WCPU to write SFR or get the SFR value from WCPU
2721           * Params: U8_T type - 0: read command 1: write command
2722           *         U8_T index - The index of SFR
2723           *         U8_T value - The SFR value
2724           * Returns: none
2725           * Note: none
2726           * ----------------------------------------------------------------------------
2727           */
2728          void IO_SfrRW(U8_T type, U8_T index, U8_T XDATA value)
2729          {
2730   1              if (type == IO_COMMAND_WRITE)
2731   1              {
2732   2                      io_TxBuf[0] = index;
2733   2                      io_TxBuf[1] = value;
2734   2      
2735   2                      MWIF_Send(IO_DBG_WCPU_SFR_WRITE, io_TxBuf, 2);
2736   2              }
2737   1              else
2738   1              {
2739   2                      io_TxBuf[0] = index;
2740   2      
2741   2                      MWIF_Send(IO_DBG_WCPU_SFR_READ, io_TxBuf, 1);
2742   2              }
2743   1      }       /* End of IO_SfrRW */
2744          
2745          /*
2746           * ----------------------------------------------------------------------------
2747           * Function Name: IO_WcpuIndirectRW
2748           * Purpose: To ask WCPU to write WCPU indirect register or get WCPU indirect
2749           *          register value from WCPU
2750           * Params: U8_T  type - 0: read command 1: write command
2751           *         U8_T  index - index of WCPU indirect register
2752           *         U8_T* pReg - Start pointer of the buffer to save WCPU indirect register value
2753           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2754           *                 0xFF: IO_COMMAND_ERROR
2755           * Note: none
2756           * ----------------------------------------------------------------------------
2757           */
2758          U8_T IO_WcpuIndirectRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2759          {
2760   1              if (type == IO_COMMAND_WRITE)
2761   1              {
2762   2                      U8_T    len;
2763   2      
2764   2                      io_TxBuf[0] = index;
2765   2                      switch (index)
2766   2                      {
2767   3                      case WCPU_MAIN_CTL_REG:                         // 0x00
2768   3                      case WCPU_WIFI_MAIN_CTL_REG:            // 0x01
2769   3                      case WCPU_DMA_BYTE_COUNT_LOW_REG:       // 0x06
2770   3                      case WCPU_DMA_BYTE_COUNT_CMD_REG:       // 0x07
2771   3                      case WCPU_DMA_CONTROL_REG:                      // 0x08
2772   3                      case WCPU_DMA_INTR_MASK:                        // 0x0B
2773   3                      case WCPU_SWTIMER_TIMER_CTRL:           // 0x0C
2774   3                      case WCPU_SYSTEM_SETTING_REG:           // 0x0D
2775   3                              len = 2;
2776   3                              io_TxBuf[1] = *pReg;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 46  

2777   3                              break;
2778   3                      case WCPU_DMA_SOUR_ADDR_REG:            // 0x02
2779   3                      case WCPU_DMA_TARGET_ADDR_REG:          // 0x04
2780   3                      case WCPU_SWTIMER_TIMER_REG:            // 0x09
2781   3                              len = 3;
2782   3                              io_TxBuf[1] = *pReg;
2783   3                              io_TxBuf[2] = *(pReg + 1);
2784   3                              break;
2785   3                      default:
2786   3                              return IO_COMMAND_ERROR;
2787   3                      }
2788   2      
2789   2                      MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_WRITE, io_TxBuf, len);
2790   2              }
2791   1              else
2792   1              {
2793   2                      io_TxBuf[0] = index;
2794   2      
2795   2                      MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_READ, io_TxBuf, 1);
2796   2              }
2797   1      
2798   1              return IO_COMMAND_DONE;
2799   1      
2800   1      } /* End of IO_WcpuIndirectRW */
2801          
2802          /*
2803           * ----------------------------------------------------------------------------
2804           * Function Name: IO_MiibIndirectRW
2805           * Purpose: To ask WCPU to write MII indirect register or get MII indirect
2806           *          register value from WCPU
2807           * Params: U8_T  type - 0: read command 1: write command
2808           *         U8_T  index - index of MII indirect register
2809           *         U8_T* pReg - Start pointer of the buffer to save MII indirect register value
2810           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2811           *                 0xFF: IO_COMMAND_ERROR
2812           * Note: none
2813           * ----------------------------------------------------------------------------
2814           */
2815          U8_T IO_MiibIndirectRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2816          {
2817   1              if (type == IO_COMMAND_WRITE)
2818   1              {
2819   2                      U8_T    len;
2820   2      
2821   2                      io_TxBuf[0] = index;
2822   2                      switch (index)
2823   2                      {
2824   3                      case MIB_TXMIC_PRIORITY:        // 0x08
2825   3                      case MIB_TX_CONTROL:            // 0x0F
2826   3                      case MIB_RXMIC_PRIORITY:        // 0x18
2827   3                      case MIB_RXMIC_FAIL_CNT:        // 0x19
2828   3                      case MIB_BOUNDARY_SIZE:         // 0x1A
2829   3                              len = 2;
2830   3                              io_TxBuf[1] = *pReg;
2831   3                              break;
2832   3                      case MIB_TX_THRESHOLD:          // 0x09
2833   3                      case MIB_TX_START_ADDR:         // 0x0B
2834   3                      case MIB_TX_END_ADDR:           // 0x0D
2835   3                              len = 3;
2836   3                              io_TxBuf[1] = *pReg;
2837   3                              io_TxBuf[2] = *(pReg + 1);
2838   3                              break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 47  

2839   3                      case MIB_LLC_PATTERN:           // 0x1B
2840   3                              len = 7;
2841   3                              memcpy(&io_TxBuf[1], pReg, 6);
2842   3                              break;
2843   3                      case MIB_TXMIC_KEY:                     // 0x00
2844   3                      case MIB_RXMIC_KEY:                     // 0x10
2845   3                              len = 9;
2846   3                              memcpy(&io_TxBuf[1], pReg, 8);
2847   3                              break;
2848   3                      default:
2849   3                              return IO_COMMAND_ERROR;
2850   3                      }
2851   2      
2852   2                      MWIF_Send(IO_DBG_WCPU_MIIB_REG_WRITE, io_TxBuf, len);
2853   2              }
2854   1              else
2855   1              {
2856   2                      io_TxBuf[0] = index;
2857   2      
2858   2                      MWIF_Send(IO_DBG_WCPU_MIIB_REG_READ, io_TxBuf, 1);
2859   2              }
2860   1      
2861   1              return IO_COMMAND_DONE;
2862   1              
2863   1      }       /* End of IO_MiibIndirectRW */
2864          
2865          /*
2866           * ----------------------------------------------------------------------------
2867           * Function Name: IO_PcibIndirectRegRW
2868           * Purpose: To ask WCPU to write PCI indirect register or get PCI indirect
2869           *          register value from WCPU
2870           * Params: U8_T  type - 0: read command 1: write command
2871           *         U8_T  index - index of PCI indirect register
2872           *         U8_T* pReg - Start pointer of the buffer to save PCI indirect register value
2873           * Returns: U8_T - 0x00: IO_COMMAND_DONE
2874           *                 0xFF: IO_COMMAND_ERROR
2875           * Note: none
2876           * ----------------------------------------------------------------------------
2877           */
2878          U8_T IO_PcibIndirectRegRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2879          {
2880   1              if (type == IO_COMMAND_WRITE)
2881   1              {
2882   2                      U8_T    len;
2883   2      
2884   2                      io_TxBuf[0] = index;
2885   2                      switch (index)
2886   2                      {
2887   3                      case PCIB_RFD_BNDRY_SIZE:       // 0x04
2888   3                      case PCIB_FILTER_CONTROL:       // 0x05
2889   3                              len = 2;
2890   3                              io_TxBuf[1] = pReg[0];
2891   3                              break;
2892   3                      case PCIB_RFD_BASE_ADDR:        // 0x00
2893   3                      case PCIB_RFD_END_ADDR:         // 0x02
2894   3                      case PCIB_FILTER_MANG_FRAME:// 0x06
2895   3                              len = 3;
2896   3                              io_TxBuf[1] = pReg[0];
2897   3                              io_TxBuf[2] = pReg[1];
2898   3                              break;
2899   3                      case PCIB_FILTER_BSSID:         // 0x08
2900   3                              len = 7;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 48  

2901   3                              memcpy(&io_TxBuf[1], pReg, 6);
2902   3                              break;
2903   3                      default:
2904   3                              return IO_COMMAND_ERROR;
2905   3                      }
2906   2      
2907   2                      MWIF_Send(IO_DBG_WCPU_PCIB_REG_WRITE, io_TxBuf, len);
2908   2              }
2909   1              else
2910   1              {
2911   2                      io_TxBuf[0] = index;
2912   2      
2913   2                      MWIF_Send(IO_DBG_WCPU_PCIB_REG_READ, io_TxBuf, 1);
2914   2              }
2915   1      
2916   1              return IO_COMMAND_DONE;
2917   1              
2918   1      }       /* End of IO_PcibIndirectRegRW */
2919          
2920          /*
2921           * ----------------------------------------------------------------------------
2922           * Function Name: IO_PciConfigRW
2923           * Purpose: To ask WCPU to write PCI configuration value or get the PCI
2924           *          configuration value from WCPU
2925           * Params: U8_T  type - 0: read command 1: write command
2926           *         U8_T  index - The index of PCI configuration register
2927           *         U8_T* pReg - Start pointer of the buffer to save PCI configuration value
2928           * Returns: none
2929           * Note: none
2930           * ----------------------------------------------------------------------------
2931           */
2932          void IO_PciConfigRW(U8_T type, U8_T index, U8_T XDATA* pReg)
2933          {
2934   1              if (type == IO_COMMAND_WRITE)
2935   1              {
2936   2                      io_TxBuf[0] = index;
2937   2                      io_TxBuf[1] = pReg[0];
2938   2                      io_TxBuf[2] = pReg[1];
2939   2                      io_TxBuf[3] = pReg[2];
2940   2                      io_TxBuf[4] = pReg[3];
2941   2      
2942   2                      MWIF_Send(IO_DBG_PCI_CONFIGURATION_WRITE, io_TxBuf, 5);
2943   2              }
2944   1              else
2945   1              {
2946   2                      io_TxBuf[0] = index;
2947   2      
2948   2                      MWIF_Send(IO_DBG_PCI_CONFIGURATION_READ, io_TxBuf, 1);
2949   2              }
2950   1      }       /* End of IO_PciConfigRW */
2951          
2952          /*
2953           * ----------------------------------------------------------------------------
2954           * Function Name: IO_WiFiRegRW
2955           * Purpose: To ask WCPU to write WiFi register or get WiFi register value from WCPU
2956           * Params: U8_T  type - 0: read command 1: write command
2957           *         U8_T* pValue - Start pointer of the index of WiFi register
2958           *         U8_T* pReg - Start pointer of the buffer to WiFi register
2959           * Returns: none
2960           * Note: none
2961           * ----------------------------------------------------------------------------
2962           */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 49  

2963          void IO_WiFiRegRW(U8_T type, U8_T XDATA* pValue, U8_T XDATA* pReg)
2964          {
2965   1              if (type == IO_COMMAND_WRITE)
2966   1              {
2967   2                      io_TxBuf[0] = pValue[0];
2968   2                      io_TxBuf[1] = pValue[1];
2969   2                      io_TxBuf[2] = pReg[0];
2970   2                      io_TxBuf[3] = pReg[1];
2971   2                      io_TxBuf[4] = pReg[2];
2972   2                      io_TxBuf[5] = pReg[3];
2973   2      
2974   2                      MWIF_Send(IO_DBG_WIFI_REG_WRITE, io_TxBuf, 6);
2975   2              }
2976   1              else
2977   1              {
2978   2                      io_TxBuf[0] = pValue[0];
2979   2                      io_TxBuf[1] = pValue[1];
2980   2      
2981   2                      MWIF_Send(IO_DBG_WIFI_REG_READ, io_TxBuf, 2);
2982   2              }
2983   1      }       /* End of IO_WiFiRegRW */
2984          
2985          /*
2986           * ----------------------------------------------------------------------------
2987           * Function Name: IO_WlanPktFilterRW
2988           * Purpose: To ask WCPU to set WiFi packet filtering or get WiFi packet filtering
2989           *          status from WCPU
2990           * Params: U8_T  rw - 0: read command 1: write command
2991           *         U8_T  type - The type of WiFi packet (i.e. Data frame, Managment frame, or Control frame)
2992           *         U8_T  subtype - The subtype of WiFi packet (i.e. PS-Pull, association, etc)
2993           *         U8_T* pBssid - Start pointer of the buffer to save BSSID
2994           * Returns: none
2995           * Note: none
2996           * ----------------------------------------------------------------------------
2997           */
2998          void IO_WlanPktFilterRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid)
2999          {
3000   1              if (rw == IO_COMMAND_WRITE)
3001   1              {
3002   2                      io_TxBuf[0] = type;
3003   2                      io_TxBuf[1] = (U8_T)(subtype >> 8);
3004   2                      io_TxBuf[2] = (U8_T)subtype;
3005   2                      io_TxBuf[3] = pBssid[0];
3006   2                      io_TxBuf[4] = pBssid[1];
3007   2                      io_TxBuf[5] = pBssid[2];
3008   2                      io_TxBuf[6] = pBssid[3];
3009   2                      io_TxBuf[7] = pBssid[4];
3010   2                      io_TxBuf[8] = pBssid[5];
3011   2      
3012   2                      MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_WRITE, io_TxBuf, 9);
3013   2              }
3014   1              else
3015   1              {
3016   2                      MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_READ, NULL, 0);
3017   2              }
3018   1      }       /* End of IO_WlanPktFilterRW */
3019          
3020          /*
3021           * ----------------------------------------------------------------------------
3022           * Function Name: IO_SynthesizerSet
3023           * Purpose: To ask WCPU to set the synthesizer
3024           * Params: U8_T* pValue - Start pointer of the buffer to save synthesizer value
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 50  

3025           * Returns: none
3026           * Note: none
3027           * ----------------------------------------------------------------------------
3028           */
3029          void IO_SynthesizerSet(U8_T XDATA* pValue)
3030          {
3031   1              io_TxBuf[0] = *pValue;
3032   1              io_TxBuf[1] = *(pValue + 1);
3033   1              io_TxBuf[2] = *(pValue + 2);
3034   1              io_TxBuf[3] = *(pValue + 3);
3035   1      
3036   1              MWIF_Send(IO_DBG_SYNTHESIZER_SET, io_TxBuf, 4);
3037   1      
3038   1      }       /* End of IO_SynthesizerSet */
3039          
3040          /*
3041           * ----------------------------------------------------------------------------
3042           * Function Name: IO_RetryRW
3043           * Purpose: To ask WCPU to set WiFi packet retry times or get the WiFi packet 
3044           *          retry times from WCPU
3045           * Params: U8_T type - 0: read command 1: write command
3046           *         U8_T value - WiFi packet retry times
3047           * Returns: none
3048           * Note: none
3049           * ----------------------------------------------------------------------------
3050           */
3051          void IO_RetryRW(U8_T type, U8_T value)
3052          {
3053   1              U8_T    len;
3054   1      
3055   1              if (type == IO_COMMAND_WRITE)
3056   1              {
3057   2                      len = 2;
3058   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3059   2                      io_TxBuf[1] = value;
3060   2              }
3061   1              else
3062   1              {
3063   2                      len = 1;
3064   2                      io_TxBuf[0] = IO_COMMAND_READ;
3065   2              }
3066   1      
3067   1              MWIF_Send(IO_DBG_RETRY_NUMBER, io_TxBuf, len);
3068   1              
3069   1      }       /* End of IO_RetryRW */
3070          
3071          /*
3072           * ----------------------------------------------------------------------------
3073           * Function Name: IO_Gpio0RW
3074           * Purpose: To ask WCPU to set GPIO 0 or get the value of GPIO 0
3075           * Params: U8_T type - 0: read command 1: write command
3076           *         U8_T value - value of GPIO 0
3077           * Returns: none
3078           * Note: none
3079           * ----------------------------------------------------------------------------
3080           */
3081          void IO_Gpio0RW(U8_T type, U8_T value)
3082          {
3083   1              U8_T    len;
3084   1      
3085   1              if (type == IO_COMMAND_WRITE)
3086   1              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 51  

3087   2                      len = 2;
3088   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3089   2                      io_TxBuf[1] = value;
3090   2              }
3091   1              else
3092   1              {
3093   2                      len = 1;
3094   2                      io_TxBuf[0] = IO_COMMAND_READ;
3095   2              }
3096   1      
3097   1              MWIF_Send(IO_GPIO_ZERO, io_TxBuf, len);
3098   1              
3099   1      }       /* End of IO_Gpio0RW */
3100          
3101          /*
3102           * ----------------------------------------------------------------------------
3103           * Function Name: IO_Gpio1RW
3104           * Purpose: To ask WCPU to set GPIO 1 or get the value of GPIO 1
3105           * Params: U8_T type - 0: read command 1: write command
3106           *         U8_T value - value of GPIO 1
3107           * Returns: none
3108           * Note: none
3109           * ----------------------------------------------------------------------------
3110           */
3111          void IO_Gpio1RW(U8_T type, U8_T value)
3112          {
3113   1              U8_T    len;
3114   1      
3115   1              if (type == IO_COMMAND_WRITE)
3116   1              {
3117   2                      len = 2;
3118   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3119   2                      io_TxBuf[1] = value;
3120   2              }
3121   1              else
3122   1              {
3123   2                      len = 1;
3124   2                      io_TxBuf[0] = IO_COMMAND_READ;
3125   2              }
3126   1      
3127   1              MWIF_Send(IO_GPIO_ONE , io_TxBuf, len);
3128   1              
3129   1      }       /* End of IO_Gpio1RW */
3130          
3131          /*
3132           * ----------------------------------------------------------------------------
3133           * Function Name: IO_Gpio2RW
3134           * Purpose: To ask WCPU to set GPIO 2 or get the value of GPIO 2
3135           * Params: U8_T type - 0: read command 1: write command
3136           *         U8_T value - value of GPIO 2
3137           * Returns: none
3138           * Note: none
3139           * ----------------------------------------------------------------------------
3140           */
3141          void IO_Gpio2RW(U8_T type, U8_T value)
3142          {
3143   1              U8_T    len;
3144   1      
3145   1              if (type == IO_COMMAND_WRITE)
3146   1              {
3147   2                      len = 2;
3148   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 52  

3149   2                      io_TxBuf[1] = value;
3150   2              }
3151   1              else
3152   1              {
3153   2                      len = 1;
3154   2                      io_TxBuf[0] = IO_COMMAND_READ;
3155   2              }
3156   1      
3157   1              MWIF_Send(IO_GPIO_TWO, io_TxBuf, len);
3158   1              
3159   1      }       /* End of IO_Gpio2RW */
3160          
3161          /*
3162           * ----------------------------------------------------------------------------
3163           * Function Name: IO_Gpio3RW
3164           * Purpose: To ask WCPU to set GPIO 3 or get the value of GPIO 3
3165           * Params: U8_T type - 0: read command 1: write command
3166           *         U8_T value - value of GPIO 3
3167           * Returns: none
3168           * Note: none
3169           * ----------------------------------------------------------------------------
3170           */
3171          void IO_Gpio3RW(U8_T type, U8_T value)
3172          {
3173   1              U8_T    len;
3174   1      
3175   1              if (type == IO_COMMAND_WRITE)
3176   1              {
3177   2                      len = 2;
3178   2                      io_TxBuf[0] = IO_COMMAND_WRITE;
3179   2                      io_TxBuf[1] = value;
3180   2              }
3181   1              else
3182   1              {
3183   2                      len = 1;
3184   2                      io_TxBuf[0] = IO_COMMAND_READ;
3185   2              }
3186   1      
3187   1              MWIF_Send(IO_GPIO_THREE, io_TxBuf, len);
3188   1              
3189   1      }       /* End of IO_Gpio3RW */
3190          
3191          void IO_ZPHYTestW(void)
3192          {
3193   1              MWIF_Send(0x6d, NULL, 0);
3194   1      }
3195          
3196          void IO_WMIBTestW(U8_T XDATA enable)
3197          {
3198   1              MWIF_Send(0x6e, &enable, 1);
3199   1      }
3200          
3201          void IO_APNFTW(void)
3202          {
3203   1              MWIF_Send(0x6f, NULL, 0);
3204   1      }
3205          
3206          void IO_ENCTW(void)
3207          {
3208   1              io_TxBuf[0] = 0x01;
3209   1      
3210   1              MWIF_Send(0x6f, io_TxBuf, 1);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 53  

3211   1      }
3212          
3213          /*
3214           * ----------------------------------------------------------------------------
3215           * Function Name: IO_WifiDriverVer
3216           * Purpose: To read the WCPU firmware version
3217           * Params: none
3218           * Returns: none
3219           * Note: none
3220           * ----------------------------------------------------------------------------
3221           */
3222          void IO_WifiDriverVer(void)
3223          {
3224   1              MWIF_Send(IO_WIFI_DRIVER_VER_READ, NULL, 0);
3225   1              
3226   1      }       /* End of IO_WifiDriverVer */
3227          
3228          /*
3229           * ----------------------------------------------------------------------------
3230           * Function Name: io_ScanReportAck
3231           * Purpose: To reply a scan report acknowedgement to WCPU
3232           * Params: none
3233           * Returns: none
3234           * Note: none
3235           * ----------------------------------------------------------------------------
3236           */
3237          void io_ScanReportAck(void)
3238          {
3239   1              MWIF_Send(IO_SCAN_REPORT_ACK, NULL, 0);
3240   1              
3241   1      }       /* End of io_ScanReportAck */
3242          
3243          /*
3244           * ----------------------------------------------------------------------------
3245           * Function Name: IO_SiteSurveyReportAck
3246           * Purpose: To reply a site survey acknowedgement to WCPU
3247           * Params: none
3248           * Returns: none
3249           * Note: none
3250           * ----------------------------------------------------------------------------
3251           */
3252          void IO_SiteSurveyReportAck(void)
3253          {
3254   1              MWIF_Send(IO_SITE_SURVEY_REPORT_ACK, NULL, 0);
3255   1      
3256   1      }       /* End of IO_SiteSurveyReportAck */
3257          
3258          /*
3259           * ----------------------------------------------------------------------------
3260           * Function Name: io_SensitivityTestReportACK
3261           * Purpose: To reply a sensitivity test report acknowedgement to WCPU
3262           * Params: none
3263           * Returns: none
3264           * Note: none
3265           * ----------------------------------------------------------------------------
3266           */
3267          void io_SensitivityTestReportACK(void)
3268          {
3269   1              MWIF_Send(IO_SENSITIVITY_TEST_REPORT_ACK, NULL, 0);
3270   1      
3271   1      }       /* End of io_SensitivityTestReportACK */
3272          
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 54  

3273          /*
3274           * ----------------------------------------------------------------------------
3275           * Function Name: IO_SetTimerCharCmd
3276           * Purpose: 
3277           * Params:
3278           * Returns:
3279           * Note: Should be removed after debugging.
3280           * ----------------------------------------------------------------------------
3281           */
3282          void IO_SetTimerCharCmd(U8_T num, U8_T mode, U16_T range, U8_T divider)
3283          {
3284   1              io_TxBuf[0] = num;
3285   1              io_TxBuf[1] = mode;
3286   1              io_TxBuf[2] = (U8_T)(range >> 8);
3287   1              io_TxBuf[3] = (U8_T)range;
3288   1              io_TxBuf[4] = divider;
3289   1      
3290   1              MWIF_Send(0x67, io_TxBuf, 5);
3291   1      }
3292          
3293          /*
3294           * ----------------------------------------------------------------------------
3295           * Function Name: IO_SetTimer2CharCmd
3296           * Purpose: 
3297           * Params:
3298           * Returns:
3299           * Note: Should be removed after debugging.
3300           * ----------------------------------------------------------------------------
3301           */
3302          void IO_SetTimer2CharCmd(U8_T mode, U16_T range, U8_T divider)
3303          {
3304   1              io_TxBuf[0] = mode;
3305   1              io_TxBuf[1] = (U8_T)(range >> 8);
3306   1              io_TxBuf[2] = (U8_T)range;
3307   1              io_TxBuf[3] = divider;
3308   1      
3309   1              MWIF_Send(0x68, io_TxBuf, 4);
3310   1      }
3311          
3312          /*
3313           * ----------------------------------------------------------------------------
3314           * Function Name: IO_SetTimerRunCmd
3315           * Purpose: 
3316           * Params:
3317           * Returns:
3318           * Note: Should be removed after debugging.
3319           * ----------------------------------------------------------------------------
3320           */
3321          void IO_SetTimerRunCmd(U8_T timer, U8_T sw)
3322          {
3323   1              io_TxBuf[0] = timer;
3324   1              io_TxBuf[1] = sw;
3325   1      
3326   1              MWIF_Send(0x69, io_TxBuf, 2);
3327   1      }
3328          
3329          /*
3330           * ----------------------------------------------------------------------------
3331           * Function Name: IO_SetTimerInterruptCmd
3332           * Purpose: 
3333           * Params:
3334           * Returns:
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 55  

3335           * Note: Should be removed after debugging.
3336           * ----------------------------------------------------------------------------
3337           */
3338          void IO_SetTimerInterruptCmd(U8_T timer, U8_T run)
3339          {
3340   1              io_TxBuf[0] = timer;
3341   1              io_TxBuf[1] = run;
3342   1      
3343   1              MWIF_Send(0x6a, io_TxBuf, 2);
3344   1      }
3345          
3346          /*
3347           * ----------------------------------------------------------------------------
3348           * Function Name: IO_SetUartCharCmd
3349           * Purpose: 
3350           * Params:
3351           * Returns:
3352           * Note: Should be removed after debugging.
3353           * ----------------------------------------------------------------------------
3354           */
3355          void IO_SetUartCharCmd(U8_T uart, U8_T mode, U8_T timer, U8_T baud, U8_T db, U8_T clkdiv)
3356          {
3357   1              io_TxBuf[0] = uart;
3358   1              io_TxBuf[1] = mode;
3359   1              io_TxBuf[2] = timer;
3360   1              io_TxBuf[3] = baud;
3361   1              io_TxBuf[4] = db;
3362   1              io_TxBuf[5] = clkdiv;
3363   1      
3364   1              MWIF_Send(0x6b, io_TxBuf, 6);
3365   1      }
3366          
3367          /*
3368           * ----------------------------------------------------------------------------
3369           * Function Name: IO_SetUartInterruptCmd
3370           * Purpose: 
3371           * Params:
3372           * Returns:
3373           * Note: Should be removed after debugging.
3374           * ----------------------------------------------------------------------------
3375           */
3376          void IO_SetUartInterruptCmd(U8_T uart, U8_T sw)
3377          {
3378   1              io_TxBuf[0] = uart;
3379   1              io_TxBuf[1] = sw;
3380   1      
3381   1              MWIF_Send(0x6c, io_TxBuf, 2);
3382   1      }
3383          
3384            #endif /* (MAC_ARBIT_MODE & MAC_ARBIT_WIFI) */
3385          /*****************************************************************/
3386          #else   /***** Middle of IO_CPU_TYPE, Below are for WCPU use *****/
              
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: 
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 56  

               */
              U8_T IO_CmdParsing(U8_T* pbuf)
              {
                      U8_T XDATA len, value8;
                      U8_T XDATA reg[64];
                      U16_T value16;
                      U32_T value32;
                      
              #if IO_SHOWCMD
                      io_ShowCmd(0, pbuf);
              #endif
              
                      if ((pbuf[0] | pbuf[1]) != 0xFF)
                              return IO_COMMAND_ERROR;
                      {
                              switch (pbuf[0])
                              {
                              case IO_MCPU_WCPU_READY:
                                      WCPU_McpuReady = 1;
                                      IO_NoticeMcpu(IO_MCPU_WCPU_READY_ACK, NULL, 0);
                                      printf ("Rcv MCPU Ready Command.\n\r");
                                      break;
                              case IO_MCPU_WCPU_READY_ACK:
                                      WCPU_McpuReady = 1;
                                      printf ("Rcv WCPU Ready ACK Command.\n\r");
                                      break;
                              case IO_WCPU_RESET:
                                      io_ResetAck();
                                      printf ("Rcv MCPU Reset Command.\n\r");
                                      break;
                              case IO_MCPU_WCPU_CONNECT_ACK:
                                      printf ("Rcv WiFi Connect Command Ack.\n\r");
                                      break;
                              case IO_MCPU_WCPU_DISCONNECT_RESP:
                                      printf ("Rcv WiFi Disconnect Command Response.\n\r");
                                      break;
                              case IO_SCAN:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      IO_ScanFromMcpu = 1;
                                      MGR_IOScan();
                                      io_ScanAck();
                                      break;
                              case IO_SCAN_REPORT_ACK:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SITE_SURVEY:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      io_SiteSurveyAck();
                                      IO_SiteSurveyFromMcpu = 1;
                                      MGR_IOSiteSurvey();
                                      break;
                              case IO_SITE_SURVEY_REPORT_ACK:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_JOIN_BSS:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      printf ("Join BSS index: %bd\n\r", pbuf[3]);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 57  

                                      io_JoinBssAck();
                                      MGR_IOJoinBss(pbuf[3]);
                                      break;
                              case IO_SSID_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOSsid(IO_COMMAND_READ, reg, &len);
                                      io_SsidAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_SSID_WRITE:
                                      if (pbuf[2] > 32)
                                              return IO_COMMAND_ERROR;
                                      io_SsidAckRW(IO_COMMAND_WRITE, len, reg);
                                      MGR_IOSsid(IO_COMMAND_WRITE, &pbuf[3], &pbuf[2]);
                                      break;
                              case IO_OPERATE_MODE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              io_OperateModeAckRW(IO_COMMAND_WRITE, value8);
                                              MGR_IOBBMode(IO_COMMAND_WRITE, &pbuf[4]);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBBMode(IO_COMMAND_READ, &value8);
                                              io_OperateModeAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_CHANNEL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOChannel(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_ChannelAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOChannel(IO_COMMAND_READ, &value8);
                                              io_ChannelAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_NETWORK_MODE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)        // write
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IONetWorkType(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_NetworkModeAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 58  

                                                      return IO_COMMAND_ERROR;
                                              MGR_IONetWorkType(IO_COMMAND_READ, &value8);
                                              io_NetworkModeAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_MULTICAST_SET:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
                                      WIFI_SetMultiFilter(1, &pbuf[3]);
                                      io_SetMulticastMacAck();
                                      break;
                              case IO_WIFI_MAC_ADDR_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 7)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOMacAddr(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_WiFiMacAckRW(IO_COMMAND_WRITE, reg);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              MGR_IOMacAddr(IO_COMMAND_READ, reg);
                                              io_WiFiMacAckRW(IO_COMMAND_READ, reg);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_RADIO_ON_OFF:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      if (pbuf[3] == 0)
                                      {
                                              io_RadioOnOffAck(HW_RadioOnOff(1, 0));
              #if POWER_SAVING
                                              PS_BusyTimeout = 0xFF;
              #endif
                                              IO_NoticeMcpu(IO_MCPU_WCPU_DISCONNECT, NULL, 0);
                                              MGR_ChangeSetting();
                                              WCPU_LedCtl(LED_UNLINK);
                                      }
                                      else if (pbuf[3] == 1)
                                      {
                                              io_RadioOnOffAck(HW_RadioOnOff(1, 1));
                                              if (MAC_Inform.Mode == MAC_MODE_IBSS_STA)
                                              {
                                                      WCPU_LedCtl(LED_SCAN);
                                              }
                                      }
                                      else if (pbuf[3] == 2)
                                      {
                                              if (HW_RadioOnOff(0, 0))
                                                      io_RadioOnOffAck(2);
                                              else
                                                      io_RadioOnOffAck(3);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_B_G_PROTECTION:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 59  

                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBGProtection(1, &pbuf[4]);
                                              io_BgProtectionRespRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOBGProtection(0, &value8);
                                              io_BgProtectionRespRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_ENCRYPTION_TYPE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOEncryptType(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_EncryptionAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOEncryptType(IO_COMMAND_READ, &value8);
                                              io_EncryptionAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_OPEN_SYSTEM:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOAuthenAlgorithm(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_OpenSysAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOAuthenAlgorithm(IO_COMMAND_READ, &value8);
                                              io_OpenSysAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WEP64_KEY_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep64(IO_COMMAND_READ, pbuf[3], reg);
                                      io_Wep64KeyAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_WEP64_KEY_WRITE:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep64(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 60  

                                      io_Wep64KeyAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_WEP128_KEY_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep128(IO_COMMAND_READ, pbuf[3], reg);
                                      io_Wep128KeyAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_WEP128_KEY_WRITE:
                                      if (pbuf[2] != 14)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOWep128(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      io_Wep128KeyAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_WEP_KEY_INDEX:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOKeyId(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_WepKeyIndexKeyRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOKeyId(IO_COMMAND_READ, &value8);
                                              io_WepKeyIndexKeyRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
              #if SUPPLICANT_SUPPORT
                              case IO_TKIP_AES_PASSPHASE_STRING_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOPassphrase(IO_COMMAND_READ, reg, &len);
                                      io_TkipAesAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_TKIP_AES_PASSPHASE_STRING_WRITE:
                                      if (!pbuf[2] || pbuf[2] > 64)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOPassphrase(IO_COMMAND_WRITE, &pbuf[3], &pbuf[2]);
                                      io_TkipAesAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
              #endif
                              case IO_ERROR_COMMAND:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      printf("Drop bad command\n\r");
                                      break;
                              case IO_FRAGMENT_THRESHOLD_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOFragSize(IO_COMMAND_READ, &value16);
                                      io_FragmentThresholdAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_FRAGMENT_THRESHOLD_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOFragSize(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_FragmentThresholdAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 61  

                                      break;
                              case IO_RTS_THRESHOLD_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IORtsThreshold(IO_COMMAND_READ, &value16);
                                      io_RtsIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_RTS_THRESHOLD_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IORtsThreshold(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_RtsIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_PREAMBLE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOPreamble(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_PreambleAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOPreamble(IO_COMMAND_READ, &value8);
                                              io_PreambleAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TX_POWER_LEVEL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      io_TxGainRW(IO_COMMAND_READ, HW_Read_TxGain());
                                      break;
                              case IO_TX_POWER_LEVEL_WRITE:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      HW_Write_TxGain(pbuf[3]);
                                      io_TxGainRW(IO_COMMAND_WRITE, 0);
                                      break;
                              case IO_BEACON_INTERVAL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOBcnInterval(IO_COMMAND_READ, &value16);
                                      io_BeaconIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_BEACON_INTERVAL_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOBcnInterval(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_BeaconIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_COUNTRY_REGION:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] == 3)
                                              {
                                                      MGR_IOCountryRegion(IO_COMMAND_WRITE, (U16_T XDATA*)(&pbuf[4]));
                                                      io_CountryRegionAckRW(IO_COMMAND_WRITE, value16);
                                              }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 62  

                                              else
                                              {
                                                      return IO_COMMAND_ERROR;
                                              }
                                      }
                                      else if (pbuf[3] == IO_COMMAND_READ)
                                      {
                                              if (pbuf[2] == 1)
                                              {
                                                      MGR_IOCountryRegion(IO_COMMAND_READ, &value16);
                                                      io_CountryRegionAckRW(IO_COMMAND_READ, value16);
                                              }
                                              else
                                              {
                                                      return IO_COMMAND_ERROR;
                                              }
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_ATIM_INTERVAL_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      MGR_IOAtimInterval(IO_COMMAND_READ, &value16);
                                      io_AtimIntervalAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value16);
                                      break;
                              case IO_ATIM_INTERVAL_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      MGR_IOAtimInterval(IO_COMMAND_WRITE, (U16_T XDATA*)&pbuf[3]);
                                      io_AtimIntervalAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value16);
                                      break;
                              case IO_TX_DATA_RATE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              if (0xff == HW_SetTxRate(pbuf[4]))
                                                      return IO_COMMAND_ERROR;
                                              io_TxDataRateRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TxDataRateRW(IO_COMMAND_READ, HW_Inform.FixSpeed);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_AUTO_POWER_CONTROL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] < 2)
                                                      return IO_COMMAND_ERROR;
                                              switch (pbuf[4])
                                              {
                                                      case 0:
                                                              MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 0;
                                                              WIFI_apcNeed = 0;
                                                              WIFI_AutoPowerControl(0, 0, 0, 0);
                                                              break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 63  

                                                      case 1:
                                                              MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 1;
                                                              WIFI_apcNeed = 1;
                                                              break;
                                                      default:
                                                              return IO_COMMAND_ERROR;
                                              }
                                              io_AutoPowerCtrlRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_AutoPowerCtrlRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_ROAMING:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need roaming function...
                                              io_RoamingRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need roaming function...
                                              io_RoamingRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WIFI_MULTIMEDIA_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need WMM function...
                                              io_WifiMultimediaSetRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need WMM function...
                                              io_WifiMultimediaSetRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_LISTEN_INTERVAL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need listen interval function...
                                              io_ListenIntervalRW(IO_COMMAND_WRITE, value16);
                                      }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 64  

                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need listen interval function...
                                              io_ListenIntervalRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                      case IO_MINIMUM_CONTENTION_WINDOW:
                          if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MinContentionWindowRW(IO_COMMAND_WRITE, value16);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MinContentionWindowRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_MAXIMUM_CONTENTION_WINDOW:
                          if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 3)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MaxContentionWindowRW(IO_COMMAND_WRITE, value16);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need contention window function...
                                              io_MaxContentionWindowRW(IO_COMMAND_READ, value16);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SHOW_RSSI:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      value8 = MGR_IORssi();
                                      io_ShowRssiResp(value8);
                                      break;
                              case IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need payload length in WiFi function...
                                              io_PayloadLenAddInWifiRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 65  

                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need payload length in WiFi function...
                                              io_PayloadLenAddInWifiRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_RETAIN_LLC_IN_WIFI_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need retain LLC in WiFi function...
                                              io_RetainLlcInWifiRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need retain LLC in WiFi function...
                                              io_RetainLlcInWifiRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_2_LLC_IN_WIFI_VLAN_PACKET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              //need to add 2 LLC in WiFi VLAN function...
                                              io_2LlcInWiFiVlanPacketRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              //need to add 2 LLC in WiFi VLAN function...
                                              io_2LlcInWiFiVlanPacketRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TRAFFIC_PROFILE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
              
                                              if (pbuf[4] == MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile)
                                              {
                                                      printf("Same as current traffic profile.\n\r");
                                              }
                                              else if (MAC_Inform.State >= MAC_STATE_JOINED)
                                              {
                                                      MAC_SetTrafficProfile(pbuf[4]);
                                              }
                                              else
                                              {
                                                      if (pbuf[4] <= AC_DF)
                                                      {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 66  

                                                              MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile = pbuf[4];
                                                      }
                                                      else
                                                      {
                                                              printf("Incorrect profile number !!\n\r");
                                                      }
                                              }
                                              io_TrafficProfileRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TrafficProfileRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_TX_DEFAULT_POWER_LEVEL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              if (pbuf[4] == MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel)
                                              {
                                                      io_TxDefaultPowerLevelRW(IO_COMMAND_WRITE, 0xff);
                                              }
                                              else
                                              {
                                                      MAC_IOTxPowerLevel(1, pbuf[4]);
                                                      io_TxDefaultPowerLevelRW(IO_COMMAND_WRITE, MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel);
                                              }
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_TxDefaultPowerLevelRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].PowerLevel);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_QUEUE_PRIORITY_SET:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              // please modify the code you need and call "io_QueuePrioritySetRW(U8_T rw, U8_T index, U8_T priority)
             -" function
              #if (QOS_SUPPORT - QOS_ONE_QUEUE)
                                              io_QueuePrioritySetRW(IO_COMMAND_WRITE, MAC_ExchangePriority(1, pbuf[4]));
              #else
                                              io_QueuePrioritySetRW(IO_COMMAND_WRITE, 0xFE);
              #endif
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              // please modify the code you need and call "io_QueuePrioritySetRW(U8_T rw, U8_T index, U8_T priority)
             -" function
              #if (QOS_SUPPORT - QOS_ONE_QUEUE)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 67  

                                              io_QueuePrioritySetRW(IO_COMMAND_READ, MAC_ExchangePriority(0, 0));
              #else
                                              io_QueuePrioritySetRW(IO_COMMAND_READ, 0xFE);
              #endif
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_SELF_CTS:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MAC_CurSet.SwProfile[MAC_UserProfile].SelfCTS = pbuf[4];
                                              io_SelfCtsRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_SelfCtsRW(IO_COMMAND_READ, MAC_CurSet.SwProfile[MAC_UserProfile].SelfCTS);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_BSSID:
                                      if (pbuf[3] == IO_COMMAND_READ)
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IOGetBssid(reg);
                                              io_BssidR(reg);
                                      }
                                      break;
                              case IO_WIFI_IP_READ:
                                      if (pbuf[2] != 0)
                                              return IO_COMMAND_ERROR;
                                      io_WifiIpR(MAC_IOGetSecIp());
                                      break;
                              case IO_WIFI_DRIVER_VER_READ:
                                      if (pbuf[2] != 0)
                                              return IO_COMMAND_ERROR;
                                      io_WifiDriverVerR(MAC_IOGetDriverVer());
                                      break;
              #if MASS_PRODUCTION
                              case IO_CONTINUOUS_TX:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      DBG_ContinuousTx(pbuf[3]);
                                      io_ContinuousTxAck(pbuf[3]);
                                      break;
                              case IO_SENSITIVITY_TEST:
                                      if (!pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      
                                      if (pbuf[5] == 1)
                                      {
                                              dbg_senTestSource = 0; //Inspire
                                      }
                                      else if (pbuf[5] == 2)
                                      {
                                              dbg_senTestSource = 1; //N4010A
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 68  

                                      }
                                      else
                                      {
                                              dbg_senTestSource = 0; //Inspire
                                      }
              
                                      DBG_SensitivityTest(1, *((U16_T *)&pbuf[3]));
                                      io_SensitivityTestAck(&pbuf[3]);
                                      break;
                              case IO_SENSITIVITY_TEST_REPORT:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      DBG_SensitivityTest(0, *((U16_T *)&pbuf[3]));
                                      io_SensitivityTestReportAck();
                                      break;
              #endif
                              case IO_DBG_WCPU_SFR_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_SfrIO(IO_COMMAND_READ, pbuf[3], &value8))
                                              return IO_COMMAND_ERROR;
                                      io_SfrAckRW(IO_COMMAND_READ, value8);
                                      break;
                              case IO_DBG_WCPU_SFR_WRITE:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_SfrIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]))
                                              return IO_COMMAND_ERROR;
                                      io_SfrAckRW(IO_COMMAND_WRITE, value8);
                                      break;
                              case IO_DBG_WCPU_SUB_SYS_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = WCPU_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_WcpuIndirectAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_SUB_SYS_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = WCPU_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_WcpuIndirectAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
                              case IO_DBG_WCPU_MIIB_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = MIB_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_MiibIndirectAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_MIIB_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = MIB_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                              return IO_COMMAND_ERROR;
                                      io_MiibIndirectAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 69  

                              case IO_DBG_WCPU_PCIB_REG_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      len = PCIB_IndirectIO(IO_COMMAND_READ, pbuf[3], reg);
                                      if (0xff == len)
                                      return IO_COMMAND_ERROR;
                                      io_PcibIndirectRegAckRW(IO_COMMAND_READ, len, reg);
                                      break;
                              case IO_DBG_WCPU_PCIB_REG_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      len = PCIB_IndirectIO(IO_COMMAND_WRITE, pbuf[3], &pbuf[4]);
                                      if (0xff == len)
                                      return IO_COMMAND_ERROR;
                                      io_PcibIndirectRegAckRW(IO_COMMAND_WRITE, len, reg);
                                      break;
                              case IO_DBG_PCI_CONFIGURATION_READ:
                                      if (pbuf[2] != 1)
                                              return IO_COMMAND_ERROR;
                                      PCIB_PciRead(PCIB_CONFIG_MODE, pbuf[3], reg);
                                      io_PciConfigAckRW(IO_COMMAND_READ, reg);
                                      break;
                              case IO_DBG_PCI_CONFIGURATION_WRITE:
                                      if (pbuf[2] < 2)
                                              return IO_COMMAND_ERROR;
                                      PCIB_PciWrite(PCIB_CONFIG_MODE, pbuf[3], &pbuf[4]);
                                      io_PciConfigAckRW(IO_COMMAND_WRITE, reg);
                                      break;
                              case IO_DBG_WIFI_REG_READ:
                                      if (pbuf[2] != 2)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_WifiRegIO(IO_COMMAND_READ, *((U16_T*)&pbuf[3]), &value32))
                                              return IO_COMMAND_ERROR;
                                      io_WiFiRegAckRW(IO_COMMAND_READ, (U8_T XDATA*)&value32);
                                      break;
                              case IO_DBG_WIFI_REG_WRITE:
                                      if (pbuf[2] != 6)
                                              return IO_COMMAND_ERROR;
                                      if (0xff == io_WifiRegIO(IO_COMMAND_WRITE, *((U16_T*)&pbuf[3]), (U32_T XDATA*)&pbuf[5]))
                                              return IO_COMMAND_ERROR;
                                      io_WiFiRegAckRW(IO_COMMAND_WRITE, (U8_T XDATA*)&value32);
                                      break;
                              case IO_DBG_WIFI_PACKET_FILTERING_WRITE:
                                      if (pbuf[2] != 9)
                                              return IO_COMMAND_ERROR;
                                      PCIB_WlanPktFilterIO(IO_COMMAND_WRITE, &pbuf[3], (U16_T XDATA*)&pbuf[4], &pbuf[6]);
                                      io_WlanPktFilterAckRW(IO_COMMAND_WRITE, value8, value16, reg);
                                      break;
                              case IO_DBG_WIFI_PACKET_FILTERING_READ:
                                      if (pbuf[2])
                                              return IO_COMMAND_ERROR;
                                      PCIB_WlanPktFilterIO(IO_COMMAND_READ, &value8, &value16, reg);
                                      io_WlanPktFilterAckRW(IO_COMMAND_READ, value8, value16, reg);
                                      break;
                              case IO_DBG_SYNTHESIZER_SET:
                                      if (pbuf[2] != 4)
                                              return IO_COMMAND_ERROR;
              
                                      HW_3W_IF_Synthesizer(dbg_SYNBitReverse(*((U32_T XDATA*)&pbuf[3])));
                                      io_SynthesizerSetAck();
                                      break;
                              case IO_DBG_RETRY_NUMBER:
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 70  

                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IORetry(IO_COMMAND_WRITE, &pbuf[4]);
                                              io_RetryAckRW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              MGR_IORetry(IO_COMMAND_READ, &value8);
                                              io_RetryAckRW(IO_COMMAND_READ, value8);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_ZERO:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P0 = pbuf[4];
                                              io_Gpio0RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio0RW(IO_COMMAND_READ, P0);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_ONE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P1 = pbuf[4];
                                              io_Gpio1RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio1RW(IO_COMMAND_READ, P1);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_TWO:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P2 = pbuf[4];
                                              io_Gpio2RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 71  

                                                      return IO_COMMAND_ERROR;
                                              io_Gpio2RW(IO_COMMAND_READ, P2);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_GPIO_THREE:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if (pbuf[2] != 2)
                                                      return IO_COMMAND_ERROR;
                                              P3 = pbuf[4];
                                              io_Gpio3RW(IO_COMMAND_WRITE, value8);
                                      }
                                      else if (!pbuf[3])
                                      {
                                              if (pbuf[2] != 1)
                                                      return IO_COMMAND_ERROR;
                                              io_Gpio3RW(IO_COMMAND_READ, P3);
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_DBG_AUTO_POWER_CONTROL:
                                      if (pbuf[3] == IO_COMMAND_WRITE)
                                      {
                                              if ((pbuf[2] != 3) && (pbuf[4] != 2))
                                                      return IO_COMMAND_ERROR;
                                              if (MAC_Inform.State >= MAC_STATE_JOINED)
                                              {
                                                      MAC_CurSet.SwProfile[MAC_UserProfile].AutoPowerContol = 1;
                                                      WIFI_AutoPowerControl(0, 0, 0, 1);
                                                      value32 = (U32_T)pbuf[5];
                                                      if (0xff == io_WifiRegIO(IO_COMMAND_WRITE, 0x007c, &value32))
                                                              return IO_COMMAND_ERROR;
                                              }
                                              io_AutoPowerCtrlDetailW();
                                      }
                                      else
                                              return IO_COMMAND_ERROR;
                                      break;
                              case IO_WLAN_DEBUG1_RESP:
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
              
                      return IO_COMMAND_DONE;
              }
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_NoticeMcpu
               * Purpose: To management CPU connect, disconnect, and ready commands
               * Params: U8_T  type - The type of the command
               *         U8_T* pbuf - The start pointer of the payload buffer
               *         U8_T  len  - Length of the payload
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 72  

              void IO_NoticeMcpu(U8_T type, U8_T* pbuf, U8_T len)
              {
                      U8_T XDATA                      i;
                      static U8_T XDATA       avoidRepeat = 0;
              
                      if (type == IO_MCPU_WCPU_CONNECT)
                      {
              #if SUPPLICANT_SUPPORT
                              SUP_notice = 0;
              #endif
              #if QOS_SUPPORT
                              if (MAC_Inform.CurWmmMode)
                              {
                                      HW_QosSetting();
                              }
              #endif
                              /* Check out if need to set custom traffic profile */
                              {
                                      MAC_SetTrafficProfile(MAC_CurSet.SwProfile[MAC_UserProfile].TrafficProfile);
                              }
                              
                              if (avoidRepeat == 1)
                              {
                                      return;
                              }
                              
                              /* Enable receiving PKT of MIB */
                              MIB_IndirectIO(0, MIB_TX_CONTROL, &i);
                              i |= MIB_RCV_ENABLE;
                              MIB_IndirectIO(1, MIB_TX_CONTROL, &i);
              
                              avoidRepeat = 1;
                      }
                      else if (type == IO_MCPU_WCPU_DISCONNECT)
                      {
              #if SUPPLICANT_SUPPORT
                              SUP_notice = 1;
              #endif
                              if (avoidRepeat == 2)
                              {
                                      return;
                              }
                              
                              /* Disable receiving PKT of MIB */
                              MIB_IndirectIO(0, MIB_TX_CONTROL, &i);
                              i &= ~(MIB_RCV_ENABLE);
                              MIB_IndirectIO(1, MIB_TX_CONTROL, &i);
                              
                              avoidRepeat = 2;
                      }
              
                      if (WCPU_McpuReady || type == IO_MCPU_WCPU_READY)
                      {
                              MWIF_Send(type, pbuf, len);
                      }
              
              } /* End of IO_NoticeMcpu() */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_ScanReport
               * Purpose: To reply the scanning result to MCPU
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 73  

               * Params: U8_T result - 1: no find any BSS, generate itself
               *                       2: no find any BSS, rescan
               *                       3: find a BSS
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_ScanReport(U8_T result)
              {
                      U8_T    len = 0;
              
                      switch (result)
                      {
                      case 1: // Not found any BSS, generate a new IBSS
                      case 2: // Not found any BSS, rescan
                              len = 1;
                              io_TxBuf[0] = result;
                              break;
                      case 3: // BSS is found
                              io_TxBuf[0] = result;
                              len = sizeof (MGR_KNOWN_BSS);
                              memcpy(&io_TxBuf[1], &MGR_Inform.BssList[0], len);
                              len += 1;
                              break;
                      }
              
                      MWIF_Send(IO_SCAN_REPORT, io_TxBuf, len);
                      
              }       /* End of IO_ScanReport */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: IO_SiteSurveyReport
               * Purpose: To reply site survey result to MCPU
               * Params: U8_T BssNum - The order of BSS
               *         U8_T IsTheLast - 0: Not the last BSS
               *                          1: Is the last BSS
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void IO_SiteSurveyReport(U8_T BssNum, U8_T IsTheLast)
              {
                      MGR_BSSID XDATA*        pBSS = &MGR_Inform.BssInform[BssNum];
                      U8_T                            i, len;
                      U8_T XDATA*                     ptr;
                      
                      if (IsTheLast != 2)     // find a BSS at least
                      {
                              io_TxBuf[0] = BssNum;
                              io_TxBuf[1] = pBSS->MacAddr[0];
                              io_TxBuf[2] = pBSS->MacAddr[1];
                              io_TxBuf[3] = pBSS->MacAddr[2];
                              io_TxBuf[4] = pBSS->MacAddr[3];
                              io_TxBuf[5] = pBSS->MacAddr[4];
                              io_TxBuf[6] = pBSS->MacAddr[5];
                              io_TxBuf[7] = pBSS->InfrastructureMode;
                              io_TxBuf[8] = pBSS->Config.Channel;
                              io_TxBuf[9] = pBSS->Rssi;
                              io_TxBuf[10] = pBSS->EncryptMode;
                              io_TxBuf[11] = IsTheLast;
                              ptr = &io_TxBuf[12];
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 74  

                              len = pBSS->Ssid.SsidLength;
                              for (i = 0; i < len; i++)
                              {
                                      ptr[i] = pBSS->Ssid.Ssid[i];
                              }
                              len = len + 12;
                      }
                      else    // can't find any BSS
                      {
                              len = 1;
                              io_TxBuf[0] = 0;
                      }       
              
                      MWIF_Send(IO_SITE_SURVEY_REPORT, io_TxBuf, len);
              
              }       /* End of IO_SiteSurveyReport */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ResetAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ResetAck(void)
              {
                      MWIF_Send(IO_WCPU_RESET_ACK, NULL, 0);
                      
              }       /* End of io_ResetAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ScanAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ScanAck(void)
              {
                      MWIF_Send(IO_SCAN_ACK, NULL, 0);
                      
              }       /* End of io_ScanAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SiteSurveyAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SiteSurveyAck(void)
              {
                      MWIF_Send(IO_SITE_SURVEY_ACK, NULL, 0);
                      
              }       /* End of io_SiteSurveyAck */
              
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 75  

              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_JoinBssAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_JoinBssAck(void)
              {
                      MWIF_Send(IO_JOIN_BSS_ACK, NULL, 0);
                      
              }       /* End of io_JoinBssAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SsidAckRW
               * Purpose: To reply a writing acknowedgement or the SSID to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T  len - The SSID length
               *         U8_T* pReg - Start pointer of the buffer to save SSID
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SsidAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_SSID_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_SSID_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_SsidRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_OperateModeAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi operating mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi operating mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_OperateModeAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 76  

                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_OPERATE_MODE_RESP, io_TxBuf, len);
                      
              }       /* End of io_OperateModeAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ChannelAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi channel to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi channel value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ChannelAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_CHANNEL_RESP, io_TxBuf, len);
                      
              }       /* End of io_ChannelAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_NetworkModeAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi network mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi network mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_NetworkModeAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 77  

                      }
              
                      MWIF_Send(IO_NETWORK_MODE_RESP, io_TxBuf, len);
                      
              }       /* End of io_NetworkModeAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SetMulticastMacAck
               * Purpose: To reply a writing acknowledgement or the WiFi multicast MAC address to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SetMulticastMacAck(void)
              {
                      MWIF_Send(IO_MULTICAST_SET_ACK, NULL, 0);
                      
              }       /* End of io_SetMulticastMacAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WiFiMacAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi MAC address to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T* pReg - Start pointer of the WiFi MAC buffer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WiFiMacAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = 1;
                      }
                      else
                      {
                              len = 7;
                              io_TxBuf[0] = 0;
                              memcpy(&io_TxBuf[1], pReg, 6);
                      }
              
                      MWIF_Send(IO_WIFI_MAC_ADDR_SET_RESP, io_TxBuf, len);
                      
              }       /* End of io_WiFiMacRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RadioOnOffAck
               * Purpose: To reply a writing acknowledgement or the WiFi RF state to MCPU
               * Params: U8_T state - The state of WiFi RF
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RadioOnOffAck(U8_T state)
              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 78  

                      io_TxBuf[0] = state;
              
                      MWIF_Send(IO_WIFI_RADIO_ON_OFF_ACK, io_TxBuf, 1);
              
              }       /* End of io_RadioOnOffAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BgProtectionRespRW
               * Purpose: To reply a writing acknowledgement or the WiFi data rate to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of bg protection mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BgProtectionRespRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_B_G_PROTECTION_RESP, io_TxBuf, len);
              
              }       /* End of io_BgProtectionRespRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_EncryptionAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi encryption type to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi encryption type
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_EncryptionAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 79  

                      MWIF_Send(IO_ENCRYPTION_TYPE_RESP, io_TxBuf, len);
                      
              }       /* End of io_EncryptionAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_OpenSysAckRW
               * Purpose: To reply a writing acknowledgement or the open system mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi open system mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_OpenSysAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_OPEN_SYSTEM_RESP, io_TxBuf, len);
                      
              }       /* End of io_OpenSysAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Wep64KeyRW
               * Purpose: To reply a writing acknowedgement or the WEP64 key to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pReg - Start pointer of the buffer to save WEP64 key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Wep64KeyAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type)// write
                      {
                              MWIF_Send(IO_WEP64_KEY_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 5);
              
                              MWIF_Send(IO_WEP64_KEY_READ_RESP, io_TxBuf, 5);
                      }
              }       /* End of io_Wep64KeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Wep128KeyAckRW
               * Purpose: To reply a writing acknowedgement or the WEP128 key to MCPU
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 80  

               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pReg - Start pointer of the buffer to save WEP128 key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Wep128KeyAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_WEP128_KEY_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 13);
              
                              MWIF_Send(IO_WEP128_KEY_READ_RESP, io_TxBuf, 13);
                      }
              }       /* End of io_Wep128KeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WepKeyIndexKeyRW
               * Purpose: To reply a writing acknowledgement or the WEP key index to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WEP key index
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WepKeyIndexKeyRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_WEP_KEY_INDEX_RESP, io_TxBuf, len);
                      
              }       /* End of io_WepKeyIndexKeyRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TkipAesAckRW
               * Purpose: To reply a writing acknowedgement or the TKIP/AES key to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T  len - The TKIP/AES key length
               *         U8_T* pReg - Start pointer of the buffer to save TKIP/AES key
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TkipAesAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 81  

              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_TKIP_AES_PASSPHASE_STRING_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_TkipAesRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_FragmentThresholdRW
               * Purpose: To reply a writing acknowedgement or the fragment threshold value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save fragment threshold value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_FragmentThresholdAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_FRAGMENT_THRESHOLD_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_FRAGMENT_THRESHOLD_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_FragmentThresholdRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RtsThresholdRW
               * Purpose: To reply a writing acknowedgement or the RTS threshold value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save RTS threshold value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RtsIntervalAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_RTS_THRESHOLD_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_RTS_THRESHOLD_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_RtsThresholdRW */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 82  

              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PreambleAckRW
               * Purpose: To reply a writing acknowledgement or the preamble mode to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi preamble mode
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PreambleAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_PREAMBLE_RESP, io_TxBuf, len);
                      
              }       /* End of io_PreambleAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxGainRW
               * Purpose: To reply a writing acknowledgement or the WiFi Tx power gain to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  txGain - The value of WiFi Tx power gain
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxGainRW(U8_T rw, U8_T txGain)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_TX_POWER_LEVEL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = txGain;
              
                              MWIF_Send(IO_TX_POWER_LEVEL_READ_RESP, io_TxBuf, 1);
                      }
              }       /* End of io_TxGainRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BeaconIntervalRW
               * Purpose: To reply a writing acknowedgement or the beacon interval value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save beacon interval value
               * Returns: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 83  

               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BeaconIntervalAckRW(U8_T type, U8_T* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_BEACON_INTERVAL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_BEACON_INTERVAL_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_BeaconIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_CountryRegionAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi country region to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi country region
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_CountryRegionAckRW(U8_T type, U16_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T XDATA *)(&io_TxBuf[1])) = value;
                      }
              
                      MWIF_Send(IO_COUNTRY_REGION_RESP, io_TxBuf, len);
                      
              }       /* End of io_CountryRegionAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AtimIntervalRW
               * Purpose: To reply a writing acknowedgement or the ATIM interval value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save ATIM interval value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AtimIntervalAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 84  

                              MWIF_Send(IO_ATIM_INTERVAL_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = *pValue;
                              io_TxBuf[1] = *(pValue + 1);
              
                              MWIF_Send(IO_ATIM_INTERVAL_READ_RESP, io_TxBuf, 2);
                      }
              }       /* End of io_AtimIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxDataRateRW
               * Purpose: To reply a writing acknowledgement or the WiFi data rate to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  txRate - The value of WiFi data rate
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxDataRateRW(U8_T rw, U8_T txRate)
              {
                      U8_T    len;    
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = txRate;
                      }
              
                      MWIF_Send(IO_TX_DATA_RATE_RESP, io_TxBuf, len);
                      
              }       /* End of io_TxDataRateRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AutoPowerCtrlRW
               * Purpose: To reply a writing acknowledgement or the auto power control state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of auto power control
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AutoPowerCtrlRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 85  

                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_AUTO_POWER_CONTROL_RESP, io_TxBuf, len);
              
              }       /* End of io_AutoPowerCtrlRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_AutoPowerCtrlDetailW
               * Purpose: To reply a writing acknowledgement or the auto power control state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of auto power control
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_AutoPowerCtrlDetailW(void)
              {
                      U8_T    len;
              
                      len = 1;
                      io_TxBuf[0] = IO_COMMAND_WRITE;
                      
                      MWIF_Send(IO_DBG_AUTO_POWER_CONTROL_RESP, io_TxBuf, len);
              
              }       /* End of io_AutoPowerCtrlDetailW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RoamingRW
               * Purpose: To reply a writing acknowledgement or the roaming state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of roaming
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RoamingRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_ROAMING_RESP, io_TxBuf, len);
              
              }       /* End of io_RoamingRW */
              
              /*
               * ----------------------------------------------------------------------------
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 86  

               * Function Name: io_WifiMultimediaSetRW
               * Purpose: To reply a writing acknowledgement or the WMM state to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - The state of WMM
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiMultimediaSetRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_WIFI_MULTIMEDIA_SET_RESP, io_TxBuf, len);
              
              }       /* End of io_WifiMultimediaSetRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ListenIntervalRW
               * Purpose: To reply a writing acknowledgement or the listen interval to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of listen interval
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ListenIntervalRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_LISTEN_INTERVAL_RESP, io_TxBuf, len);
              
              }       /* End of io_ListenIntervalRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MinContentionWindowRW
               * Purpose: To reply a writing acknowledgement or the minimum contention window to MCPU
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 87  

               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of minimum contention window
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MinContentionWindowRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_MINIMUM_CONTENTION_WINDOW_RESP, io_TxBuf, len);
              
              }       /* End of io_MinContentionWindowRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MaxContentionWindowRW
               * Purpose: To reply a writing acknowledgement or the maximum contention window to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - The value of minimum contention window
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MaxContentionWindowRW(U8_T rw, U16_T value)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 3;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              *((U16_T*)&io_TxBuf[1]) = value;
                      }
                      
                      MWIF_Send(IO_MAXIMUM_CONTENTION_WINDOW_RESP, io_TxBuf, len);
              
              }       /* End of io_MaxContentionWindowRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ShowRssiResp
               * Purpose: To reply RSSI value to MCPU
               * Params: U8_T rssi - Input of the RSSI value
               * Returns: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 88  

               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ShowRssiResp(U8_T rssi)
              {
                      io_TxBuf[0] = rssi;
              
                      MWIF_Send(IO_SHOW_RSSI_RESP, io_TxBuf, 1);
                      
              }       /* End of io_ShowRssiResp */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PayloadLenAddInWifiRW
               * Purpose: To reply a writing acknowledgement or the payload length in WiFi packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable payload length in WiFi packet
               *                       1: Enable payload length in WiFi packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PayloadLenAddInWifiRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_PAYLOAD_LENGTH_ATTACH_IN_WIFI_PACKET_RESP, io_TxBuf, len);
                      
              }       /* End of io_PayloadLenAddInWifiRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RetainLlcInWifiRW
               * Purpose: To reply a writing acknowledgement or the retain LLC in WiFi packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable retain LLC in WiFi packet
               *                       1: Enable retain LLC in WiFi packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_RetainLlcInWifiRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 89  

                      else
                      {
                              len = 2;
                              io_TxBuf[1] = IO_COMMAND_READ;
                              io_TxBuf[2] = state;
                      }
                      
                      MWIF_Send(IO_RETAIN_LLC_IN_WIFI_PACKET_RESP, io_TxBuf, len);
                      
              }       /* End of io_RetainLlcInWifiRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_2LlcInWiFiVlanPacketRW
               * Purpose: To reply a writing acknowledgement or add 2 LLC in WiFi VLAN packet to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: Disable 2 LLC in WiFi VLAN packet
               *                       1: Enable 2 LLC in WiFi VLAN packet
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_2LlcInWiFiVlanPacketRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_2_LLC_IN_WIFI_VLAN_PACKET, io_TxBuf, len);
                      
              }       /* End of io_2LlcInWiFiVlanPacketRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TrafficProfileRW
               * Purpose: To reply a writing acknowledgement or send the traffic profile value to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  state - 0: voice        1: vedio
               *                       2: best effort  3: back ground
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TrafficProfileRW(U8_T rw, U8_T state)
              {
                      U8_T    len;
              
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 90  

                      else
                      {
                              len= 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = state;
                      }
                      
                      MWIF_Send(IO_TRAFFIC_PROFILE_RESP, io_TxBuf, len);
                      
              }       /* End of io_TrafficProfileRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_TxDefaultPowerLevelRW
               * Purpose: To reply a writing acknowledgement or current Tx default power level to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  level - 0: 100%, 1: 50%, 2: 25%, 3: 12.5%, 4: 6.25%
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_TxDefaultPowerLevelRW(U8_T rw, U8_T level)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                              io_TxBuf[1] = level;
                      }
                      else
                      {
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = level;
                      }
                      
                      MWIF_Send(IO_TX_DEFAULT_POWER_LEVEL_RESP, io_TxBuf, 2);
                      
              }       /* End of io_TxDefaultPowerLevelRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_QueuePrioritySetRW
               * Purpose: To reply a queue priority to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  index - 0~3: Queue index
               *         U8_T  priority - 0~3: voice, vedio, best effort, background
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_QueuePrioritySetRW(U8_T rw, U8_T priority)
              {
                      U8_T    len;
                      
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                              io_TxBuf[1] = priority;
                      }
                      else
                      {
                              len = 2;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 91  

                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = priority;
                      }
                      
                      MWIF_Send(IO_QUEUE_PRIORITY_SET_RESP, io_TxBuf, len);
                      
              }       /* End of io_TxDefaultPowerLevelRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SelfCtsRW
               * Purpose: To reply the self-CTS from MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  value - 0: OFF, 1: ON
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SelfCtsRW(U8_T rw, U8_T value)
              {
                      U8_T    len;
                      
                      if (rw == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
                      
                      MWIF_Send(IO_SELF_CTS_RESP, io_TxBuf, len);
                      
              }       /* End of io_SelfCtsRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_BssidR
               * Purpose: To reply the BSSID to MCPU
               * Params: U8_T  *bssid
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_BssidR(U8_T *bssid)
              {
                      io_TxBuf[0] = IO_COMMAND_READ;
                      memcpy(&io_TxBuf[1], bssid, 6);
                      
                      MWIF_Send(IO_BSSID_RESP, io_TxBuf, 7);
                      
              }       /* End of io_BssidR */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiIpR
               * Purpose: To reply the Wifi IP address to MCPU
               * Params: U8_T  *wifiIp
               * Returns: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 92  

               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiIpR(U8_T *wifiIp)
              {
                      memcpy(&io_TxBuf[0], wifiIp, 4);
                      
                      MWIF_Send(IO_WIFI_IP_READ_RESP, io_TxBuf, 4);
                      
              }       /* End of io_WifiIpR */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiDriverR
               * Purpose: To reply the Wifi driver version to MCPU
               * Params: U8_T  *pVer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WifiDriverVerR(U8_T *pVer)
              {
                      memcpy(&io_TxBuf[0], pVer, (U8_T)strlen(pVer));
              
                      MWIF_Send(IO_WIFI_DRIVER_VER_READ_RESP, io_TxBuf, (U8_T)strlen(pVer));
                      
              }       /* End of io_WifiDriverVerR */
              
              #if MASS_PRODUCTION
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ContinuousTxAck
               * Purpose: To reply a writing acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ContinuousTxAck(U8_T mode)
              {
                      io_TxBuf[0] = mode;
              
                      MWIF_Send(IO_CONTINUOUS_TX_ACK, io_TxBuf, 1);
              
              }       /* End of io_ContinuousTxAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SensitivityTestAck
               * Purpose: To reply a acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SensitivityTestAck(U8_T *ptr)
              {
                      io_TxBuf[0] = ptr[0];
                      io_TxBuf[1] = ptr[1];
                      
                      MWIF_Send(IO_SENSITIVITY_TEST_ACK, io_TxBuf, 2);
              
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 93  

              }       /* End of io_SensitivityTestAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SensitivityTestReportAck
               * Purpose: To reply a acknowledgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SensitivityTestReportAck(void)
              {
                      U8_T    i, j;
              
                      j = (U8_T)strlen(DBG_senTestResult);
              
                      for (i = 0; i < j; i++)
                      {
                              io_TxBuf[i] = DBG_senTestResult[i];
                      }
              
                      MWIF_Send(IO_SENSITIVITY_TEST_REPORT_ACK, io_TxBuf, j);
                      
              }       /* End of io_SensitivityTestReportAck */
              #endif
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SfrIO
               * Purpose: To write the value into specific SFR or to read the value from specific SFR
               * Params: U8_T  rw - 0: read 1: write
               *         U8_T  index - The index of the specific SFR
               *         U8_T* pValue - The pointer of the buffer to save SFR value
               * Returns: 0x00: success 0xFF: fault
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T io_SfrIO(U8_T rw, U8_T index, U8_T XDATA* pValue)
              {
                      if (rw == IO_COMMAND_READ)
                      {
                              switch(index)
                              {
                              case 0x80:
                                      *pValue = P0;
                                      break;
                              case 0x81:
                                      *pValue = SP;
                                      break;
                              case 0x82:
                                      *pValue = DPL0;
                                      break;
                              case 0x83:
                                      *pValue = DPH0;
                                      break;
                              case 0x84:
                                      *pValue = DPL1;
                                      break;
                              case 0x85:
                                      *pValue = DPH1;
                                      break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 94  

                              case 0x86:
                                      *pValue = DPS;
                                      break;
                              case 0x87:
                                      *pValue = PCON;
                                      break;
                              case 0x88:
                                      *pValue = TCON;
                                      break;
                              case 0x89:
                                      *pValue = TMOD;
                                      break;
                              case 0x8a:
                                      *pValue = TL0;
                                      break;
                              case 0x8b:
                                      *pValue = TL1;
                                      break;
                              case 0x8c:
                                      *pValue = TH0;
                                      break;
                              case 0x8d:
                                      *pValue = TH1;
                                      break;
                              case 0x8e:
                                      *pValue = CKCON;
                                      break;
                              case 0x90:
                                      *pValue = P1;
                                      break;
                              case 0x91:
                                      *pValue = EIF;
                                      break;
                              case 0x92:
                                      *pValue = WTST;
                                      break;
                              case 0x93:
                                      *pValue = DPX0;
                                      break;
                              case 0x95:
                                      *pValue = DPX1;
                                      break;
                              case 0x98:
                                      *pValue = SCON0;
                                      break;
                              case 0x99:
                                      *pValue = SBUF0;
                                      break;
                              case 0x9d:
                                      *pValue = ACON;
                                      break;
                          case 0xa0:
                                      *pValue = P2;
                                      break;
                              case 0xa1:
                                      *pValue = PMALR;
                                      break;
                          case 0xa2:
                                      *pValue = PMAHR;
                                      break;
                              case 0xa3:
                                      *pValue = PMDR0;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 95  

                                      break;
                              case 0xa4:
                                      *pValue = PMDR1;
                                      break;
                              case 0xa5:
                                      *pValue = PMDR2;
                                      break;
                              case 0xa6:
                                      *pValue = PMDR3;
                                      break;
                              case 0xa7:
                                      *pValue = PBIER;
                                      break;
                              case 0xa8:
                                      *pValue = IE;
                                      break;
                              case 0xa9:
                                      *pValue = RHPLR;
                                      break;
                              case 0xaa:
                                      *pValue = RHPHR;
                                      break;
                              case 0xab:
                                      *pValue = RSPLR;
                                      break;
                              case 0xac:
                                      *pValue = RSPHR;
                                      break;
                              case 0xae:
                                      *pValue = PBSR;
                                      break;
                              case 0xaf:
                                      *pValue = PBISR;
                                      break;
                              case 0xb0:
                                      *pValue = P3;
                                      break;
                              case 0xb1:
                                      *pValue = MTWPL;
                                      break;
                              case 0xb2:
                                      *pValue = MTWPH;
                                      break;
                              case 0xb3:
                                      *pValue = CTRPL;
                                      break;
                              case 0xb4:
                                      *pValue = CTRPH;
                                      break;
                              case 0xb5:
                                      *pValue = TXBS;
                                      break;
                              case 0xb8:
                                      *pValue = IP;
                                      break;
                              case 0xb9:
                                      *pValue = MRPLL;
                                      break;
                              case 0xba:
                                      *pValue = MRPLH;
                                      break;
                              case 0xbb:
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 96  

                                      *pValue = MRBLL;
                                      break;
                              case 0xbc:
                                      *pValue = MRBLH;
                                      break;
                              case 0xbd:
                                      *pValue = MRBSAL;
                                      break;
                              case 0xbe:
                                      *pValue = MRBSAH;
                                      break;
                              case 0xbf:
                                      *pValue = MRCR;
                                      break;
                              case 0xc0:
                                      *pValue = SCON1;
                                      break;
                              case 0xc1:
                                      *pValue = SBUF1;
                                      break;
                              case 0xc2:
                                      *pValue = MISR;
                                      break;
                              case 0xc3:
                                      *pValue = MIMR;
                                      break;
                              case 0xc8:
                                      *pValue = T2CON;
                                      break;
                              case 0xc9:
                                      *pValue = T2IF;
                                      break;
                              case 0xca:
                                      *pValue = RLDL;
                                      break;
                              case 0xcb:
                                      *pValue = RLDH;
                                      break;
                              case 0xcc:
                                      *pValue = TL2;
                                      break;
                              case 0xcd:
                                      *pValue = TH2;
                                      break;
                              case 0xce:
                                      *pValue = WI2CCIR;
                                      break;
                              case 0xcf:
                                      *pValue = WI2CDR;
                                      break;
                              case 0xd0:
                                      *pValue = PSW;
                                      break;
                              case 0xd8:
                                      *pValue = WDCON;
                                      break;
                              case 0xd9:
                                      *pValue = SINTMR;
                                      break;
                              case 0xda:
                                      *pValue = HASHCR;
                                      break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 97  

                              case 0xdb:
                                      *pValue = HASHDR;
                                      break;
                              case 0xe0:
                                      *pValue = ACC;
                                      break;
                              case 0xe1:
                                      *pValue = SINTSR;
                                      break;
                              case 0xe2:
                                      *pValue = SSCIR;
                                      break;
                              case 0xe3:
                                      *pValue = SSDR;
                                      break;
                              case 0xe4:
                                      *pValue = MBCIR;
                                      break;
                              case 0xe5:
                                      *pValue = MBDR;
                                      break;
                              case 0xe6:
                                      *pValue = PBCIR;
                                      break;
                              case 0xe7:
                                      *pValue = PBDR;
                                      break;
                              case 0xe8:
                                      *pValue = EIE;
                                      break;
                              case 0xe9:
                                      *pValue = STATUS;
                                      break;
                              case 0xea:
                                      *pValue = MXAX;
                                      break;
                              case 0xeb:
                                      *pValue = TA;
                                      break;
              //              case 0xec:
              //                      *pValue = SHACIR;
              //                      break;
              //              case 0xed:
              //                      *pValue = SHADR;
              //                      break;
                              case 0xee:
                                      *pValue = RNO;
                                      break;
                              case 0xef:
                                      *pValue = RNDP;
                                      break;
                              case 0xf0:
                                      *pValue = B;
                                      break;
                              case 0xf1:
                                      *pValue = RC0;
                                      break;
                              case 0xf2:
                                      *pValue = RC1;
                                      break;
                              case 0xf3:
                                      *pValue = RC2;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 98  

                                      break;
                              case 0xf4:
                                      *pValue = RC3;
                                      break;
                              case 0xf5:
                                      *pValue = RC4;
                                      break;
                              case 0xf6:
                                      *pValue = MOP;
                                      break;
                              case 0xf7:
                                      *pValue = MD;
                                      break;
                              case 0xf8:
                                      *pValue = EIP;
                                      break;
                              case 0xf9:
                                      *pValue = WC0;
                                      break;
                              case 0xfa:
                                      *pValue = WC1;
                                      break;
                              case 0xfb:
                                      *pValue = WC2;
                                      break;
                              case 0xfc:
                                      *pValue = WC3;
                                      break;
                              case 0xfd:
                                      *pValue = WC4;
                                      break;
                              case 0xfe:
                                      *pValue = CCTRL;
                                      break;
                              case 0xff:
                                      *pValue = CSSR;
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
                      else if (rw == 1) // write sfr
                      {
                              switch(index)
                              {
                              case 0x80:
                                      P0 = *pValue;
                                      break;
                              case 0x81:
                                      SP = *pValue;
                                      break;
                              case 0x82:
                                      DPL0 = *pValue;
                                      break;
                              case 0x83:
                                      DPH0 = *pValue;
                                      break;
                              case 0x84:
                                      DPL1 = *pValue;
                                      break;
                              case 0x85:
                                      DPH1 = *pValue;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 99  

                                      break;
                              case 0x86:
                                      DPS = *pValue;
                                      break;
                              case 0x87:
                                      PCON = *pValue;
                                      break;
                              case 0x88:
                                      TCON = *pValue;
                                      break;
                              case 0x89:
                                      TMOD = *pValue;
                                      break;
                              case 0x8a:
                                      TL0 = *pValue;
                                      break;
                              case 0x8b:
                                      TL1 = *pValue;
                                      break;
                              case 0x8c:
                                      TH0 = *pValue;
                                      break;
                              case 0x8d:
                                      TH1 = *pValue;
                                      break;
                              case 0x8e:
                                      CKCON = *pValue;
                                      break;
                              case 0x90:
                                      P1 = *pValue;
                                      break;
                              case 0x91:
                                      EIF = *pValue;
                                      break;
                              case 0x92:
                                      WTST = *pValue;
                                      break;
                              case 0x93:
                                      DPX0 = *pValue;
                                      break;
                              case 0x95:
                                      DPX1 = *pValue;
                                      break;
                              case 0x98:
                                      SCON0 = *pValue;
                                      break;
                              case 0x99:
                                      SBUF0 = *pValue;
                                      break;
                              case 0x9d:
                                      ACON = *pValue;
                                      break;
                          case 0xa0:
                                      P2 = *pValue;
                                      break;
                              case 0xa1:
                                      PMALR = *pValue;
                                      break;
                          case 0xa2:
                                      PMAHR = *pValue;
                                      break;
                              case 0xa3:
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 100 

                                      PMDR0 = *pValue;
                                      break;
                              case 0xa4:
                                      PMDR1 = *pValue;
                                      break;
                              case 0xa5:
                                      PMDR2 = *pValue;
                                      break;
                              case 0xa6:
                                      PMDR3 = *pValue;
                                      break;
                              case 0xa7:
                                      PBIER = *pValue;
                                      break;
                              case 0xa8:
                                      IE = *pValue;
                                      break;
                              case 0xa9:
                                      RHPLR = *pValue;
                                      break;
                              case 0xaa:
                                      RHPHR = *pValue;
                                      break;
                              case 0xab:
                                      RSPLR = *pValue;
                                      break;
                              case 0xac:
                                      RSPHR = *pValue;
                                      break;
                              case 0xae:
                                      PBSR = *pValue;
                                      break;
                              case 0xaf:
                                      PBISR = *pValue;
                                      break;
                              case 0xb0:
                                      P3 = *pValue;
                                      break;
                              case 0xb1:
                                      MTWPL = *pValue;
                                      break;
                              case 0xb2:
                                      MTWPH = *pValue;
                                      break;
                              case 0xb3:
                                      CTRPL = *pValue;
                                      break;
                              case 0xb4:
                                      CTRPH = *pValue;
                                      break;
                              case 0xb5:
                                      TXBS = *pValue;
                                      break;
                              case 0xb8:
                                      IP = *pValue;
                                      break;
                              case 0xb9:
                                      MRPLL = *pValue;
                                      break;
                              case 0xba:
                                      MRPLH = *pValue;
                                      break;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 101 

                              case 0xbb:
                                      MRBLL = *pValue;
                                      break;
                              case 0xbc:
                                      MRBLH = *pValue;
                                      break;
                              case 0xbd:
                                      MRBSAL = *pValue;
                                      break;
                              case 0xbe:
                                      MRBSAH = *pValue;
                                      break;
                              case 0xbf:
                                      MRCR = *pValue;
                                      break;
                              case 0xc0:
                                      SCON1 = *pValue;
                                      break;
                              case 0xc1:
                                      SBUF1 = *pValue;
                                      break;
                              case 0xc2:
                                      MISR = *pValue;
                                      break;
                              case 0xc3:
                                      MIMR = *pValue;
                                      break;
                              case 0xc8:
                                      T2CON = *pValue;
                                      break;
                              case 0xc9:
                                      T2IF = *pValue;
                                      break;
                              case 0xca:
                                      RLDL = *pValue;
                                      break;
                              case 0xcb:
                                      RLDH = *pValue;
                                      break;
                              case 0xcc:
                                      TL2 = *pValue;
                                      break;
                              case 0xcd:
                                      TH2 = *pValue;
                                      break;
                              case 0xce:
                                      WI2CCIR = *pValue;
                                      break;
                              case 0xcf:
                                      WI2CDR = *pValue;
                                      break;
                              case 0xd0:
                                      PSW = *pValue;
                                      break;
                              case 0xd8:
                                      WDCON = *pValue;
                                      break;
                              case 0xd9:
                                      SINTMR = *pValue;
                                      break;
                              case 0xda:
                                      HASHCR = *pValue;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 102 

                                      break;
                              case 0xdb:
                                      HASHDR = *pValue;
                                      break;
                              case 0xe0:
                                      ACC = *pValue;
                                      break;
                              case 0xe1:
                                      SINTSR = *pValue;
                                      break;
                              case 0xe2:
                                      SSCIR = *pValue;
                                      break;
                              case 0xe3:
                                      SSDR = *pValue;
                                      break;
                              case 0xe4:
                                      MBCIR = *pValue;
                                      break;
                              case 0xe5:
                                      MBDR = *pValue;
                                      break;
                              case 0xe6:
                                      PBCIR = *pValue;
                                      break;
                              case 0xe7:
                                      PBDR = *pValue;
                                      break;
                              case 0xe8:
                                      EIE = *pValue;
                                      break;
                              case 0xe9:
                                      STATUS = *pValue;
                                      break;
                              case 0xea:
                                      MXAX = *pValue;
                                      break;
                              case 0xeb:
                                      TA = *pValue;
                                      break;
                              case 0xee:
                                      RNO = *pValue;
                                      break;
                              case 0xef:
                                      RNDP = *pValue;
                                      break;
                              case 0xf0:
                                      B = *pValue;
                                      break;
                              case 0xf1:
                                      RC0 = *pValue;
                                      break;
                              case 0xf2:
                                      RC1 = *pValue;
                                      break;
                              case 0xf3:
                                      RC2 = *pValue;
                                      break;
                              case 0xf4:
                                      RC3 = *pValue;
                                      break;
                              case 0xf5:
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 103 

                                      RC4 = *pValue;
                                      break;
                              case 0xf6:
                                      MOP = *pValue;
                                      break;
                              case 0xf7:
                                      MD = *pValue;
                                      break;
                              case 0xf8:
                                      EIP = *pValue;
                                      break;
                              case 0xf9:
                                      WC0 = *pValue;
                                      break;
                              case 0xfa:
                                      WC1 = *pValue;
                                      break;
                              case 0xfb:
                                      WC2 = *pValue;
                                      break;
                              case 0xfc:
                                      WC3 = *pValue;
                                      break;
                              case 0xfd:
                                      WC4 = *pValue;
                                      break;
                              case 0xfe:
                                      CCTRL = *pValue;
                                      break;
                              case 0xff:
                                      CSSR = *pValue;
                                      break;
                              default:
                                      return IO_COMMAND_ERROR;
                              }
                      }
                      else // command error
                              return IO_COMMAND_ERROR;
              
                      return IO_COMMAND_DONE;
              
              }       /* End of io_SfrIO */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SfrAckRW
               * Purpose: To reply a writing acknowedgement or the SFR value to MCPU
               * Params: U8_T type - 0: read 1: write
               *         U8_T value - The value of specific SFR
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SfrAckRW(U8_T type, U8_T value)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_SFR_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = value;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 104 

              
                              MWIF_Send(IO_DBG_WCPU_SFR_READ_RESP, io_TxBuf, 1);
                      }
              }       /* End of io_SfrRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WcpuIndirectAckRW
               * Purpose: To reply a writing acknowledgement or the WCPU system register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of WCPU system register
               *         U8_T* pReg - The start pointer of the buffer to save WCPU system register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WcpuIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_WRITE_RESP, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_SUB_SYS_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_WcpuIndirectAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_MiibIndirectAckRW
               * Purpose: To reply a writing acknowledgement or the MII bridge register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of MII bridge register
               *         U8_T* pReg - The start pointer of the buffer to save MII bridge register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_MiibIndirectAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type== IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_MIIB_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_MIIB_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_MiibIndirectAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PcibIndirectRegAckRW
               * Purpose: To reply a writing acknowledgement or the PCI bridge register value to MCPU
               * Params: U8_T  type - 1: write command 0: read command
               *         U8_T  len - The buffer length of PCI bridge register
               *         U8_T* pReg - The start pointer of the buffer to save PCI bridge register value
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 105 

               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PcibIndirectRegAckRW(U8_T type, U8_T len, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WCPU_PCIB_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, len);
              
                              MWIF_Send(IO_DBG_WCPU_PCIB_REG_READ_RESP, io_TxBuf, len);
                      }
              }       /* End of io_PcibIndirectRegAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_PciConfigRW
               * Purpose: To reply a writing acknowedgement or the PCI configuration value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the butter to save PCI configuration value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_PciConfigAckRW(U8_T type, U8_T XDATA* pReg)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_PCI_CONFIGURATION_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pReg, 4);
              
                              MWIF_Send(IO_DBG_PCI_CONFIGURATION_READ_RESP, io_TxBuf, 4);
                      }
              }       /* End of io_PciConfigRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WiFiRegRW
               * Purpose: To reply a writing acknowedgement or the WiFi register value to MCPU
               * Params: U8_T  type - 0: read 1: write
               *         U8_T* pValue - Start pointer of the buffer to save register value
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WiFiRegAckRW(U8_T type, U8_T XDATA* pValue)
              {
                      if (type == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WIFI_REG_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              memcpy(&io_TxBuf[0], pValue, 4);
              
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 106 

                              MWIF_Send(IO_DBG_WIFI_REG_READ_RESP, io_TxBuf, 4);
                      }
              }       /* End of io_WiFiRegRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WlanPktFilterAckRW
               * Purpose: To reply a writing acknowledgement or the WiFi packet filtering result to MCPU
               * Params: U8_T  rw - 1: write command 0: read command
               *         U8_T  type - the type of WiFi packet
               *         U8_T  subtype - The subtype of WiFi packet
               *         U8_T* pBssid - The start pointer of the buffer to save BSSID
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_WlanPktFilterAckRW(U8_T rw, U8_T type, U16_T subtype, U8_T XDATA* pBssid)
              {
                      if (rw == IO_COMMAND_WRITE)
                      {
                              MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_WRITE_ACK, NULL, 0);
                      }
                      else
                      {
                              io_TxBuf[0] = type;
                              io_TxBuf[1] = *((U8_T XDATA *)&subtype);
                              io_TxBuf[2] = (U8_T)subtype;
                              io_TxBuf[3] = pBssid[0];
                              io_TxBuf[4] = pBssid[1];
                              io_TxBuf[5] = pBssid[2];
                              io_TxBuf[6] = pBssid[3];
                              io_TxBuf[7] = pBssid[4];
                              io_TxBuf[8] = pBssid[5];
              
                              MWIF_Send(IO_DBG_WIFI_PACKET_FILTERING_READ_RESP, io_TxBuf, 9);
                      }
              
              }       /* End of io_WlanPktFilterAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_SynthesizerSetAck
               * Purpose: To reply a acknowedgement to MCPU
               * Params: none
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_SynthesizerSetAck(void)
              {
                      MWIF_Send(IO_DBG_SYNTHESIZER_SET_ACK, NULL, 0);
                      
              }       /* End of io_SynthesizerSetAck */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_RetryAckRW
               * Purpose: To reply a writing acknowledgement or the retry count to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - WiFi packet retry count
               * Returns: none
               * Note: none
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 107 

               * ----------------------------------------------------------------------------
               */
              void io_RetryAckRW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_DBG_RETRY_NUMBER_RESP, io_TxBuf, len);
                      
              }       /* End of io_RetryAckRW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio0RW
               * Purpose: To reply a writing acknowledgement or the P0 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P0
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio0RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_ZERO_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio0RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio1RW
               * Purpose: To reply a writing acknowledgement or the P1 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P1
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 108 

              void io_Gpio1RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_ONE_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio1RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio2RW
               * Purpose: To reply a writing acknowledgement or the P2 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P2
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio2RW(U8_T type, U8_T value)
              {
                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_TWO_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio2RW */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_Gpio3RW
               * Purpose: To reply a writing acknowledgement or the P3 value to MCPU
               * Params: U8_T type - 1: write command 0: read command
               *         U8_T value - value of P3
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_Gpio3RW(U8_T type, U8_T value)
              {
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 109 

                      U8_T    len;
              
                      if (type == IO_COMMAND_WRITE)
                      {
                              len = 1;
                              io_TxBuf[0] = IO_COMMAND_WRITE;
                      }
                      else
                      {
                              len = 2;
                              io_TxBuf[0] = IO_COMMAND_READ;
                              io_TxBuf[1] = value;
                      }
              
                      MWIF_Send(IO_GPIO_THREE_RESP, io_TxBuf, len);
                      
              }       /* End of io_Gpio3RW */
              
              #if ALLEN_DBG
              void IO_WlanDebug1(U8_T value)
              {
                      MWIF_Send(IO_WLAN_DEBUG1, &value, 1);
              
              } /* End of IO_WlanDebug1 */
              #endif
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_WifiRegIO
               * Purpose: To read or to write the value into specific WiFi register
               * Params: U8_T  rw - 0: read 1: write
               *         U8_T  index - The index of the specific WiFi register
               *         U8_T* pValue - Start pointer of the WiFi value buffer
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              U8_T io_WifiRegIO(U8_T rw, U16_T index, U32_T XDATA* pValue)
              {
                      if ((index > 0xeff) || (index % 4))
                              return IO_COMMAND_ERROR;
              
                      if (index < 0x400)
                      {
                              LockPhyReg();
                      }
              
                      if (rw == 0)
                      {
                              *pValue = ZD_Readl(index);
                      }
                      else if (rw == 1)
                      {
                              ZD_Writel(*pValue, index);
                      }
                      else
                      {
                              if (index < 0x400)
                              {
                                      UnLockPhyReg();
                              }
                              return IO_COMMAND_ERROR;
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 110 

                      }
              
                      if (index < 0x400)
                      {
                              UnLockPhyReg();
                      }
                      return IO_COMMAND_DONE;
              
              } /* End of dbg_WifiRegIO */
              
              /*******************************************************************/
              #endif  /**************** End of IO_CPU_TYPE macro *****************/
6755          
6756          #if IO_SHOWCMD
              /*
               * ----------------------------------------------------------------------------
               * Function Name: io_ShowCmd
               * Purpose: To list the contents of the MCPU/WCPU communication command 
               * Params: U8_T  TxRx - 1: To send command to the other CPU
               *                      0: To receive command from the other CPU
               *         U8_T* pReg - Start pointer of the buffer to save the command
               * Returns: none
               * Note: none
               * ----------------------------------------------------------------------------
               */
              void io_ShowCmd(U8_T TxRx, U8_T XDATA* pReg)
              {
                      U8_T i, len;
              
              
                      len = pReg[2] + 3;
                      printd ("\n\r*------------------------------------*\n\r");
                      if (TxRx)
                              printd ("| Sent IO Cmd.. ==>\n\r");
                      else
                              printd ("| Received IO Cmd.. <==\n\r");
                      printd ("| Len: %bd\n\r", len);
                      printd ("| header: %02bx %02bx %02bx\n\r", pReg[0], pReg[1], pReg[2]);
                      printd ("| payload:");
                      for (i = 3; i < len; i++)
                      {
                              printd(" %02bx", pReg[i]);
                              if (!((i + 1) % 16))
                                      printd("\n\r|         ");
                      }
                      printd ("\n\r*------------------------------------*\n\r");
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15159    ----
   CONSTANT SIZE    =   3904    ----
   XDATA SIZE       =   1695      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =     34    ----
C51 COMPILER V9.01   MWIOCTL                                                               03/08/2012 11:00:56 PAGE 111 

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
