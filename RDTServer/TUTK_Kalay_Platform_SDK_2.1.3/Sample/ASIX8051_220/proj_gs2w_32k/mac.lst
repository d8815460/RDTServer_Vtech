C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAC
OBJECT MODULE PLACED IN .\mac.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mmac\mac.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(..\s
                    -rc\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mping;..
                    -\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\mhtt
                    -p;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug) DEFINE(RuntimeCodeAt32KH) VA
                    -RBANKING DEBUG PRINT(.\mac.lst) OBJECT(.\mac.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2010       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: mac.c
  13           * Purpose:  
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: mac.c,v $
  18           * no message
  19           *
  20           *=============================================================================
  21           */
  22          
  23          /* INCLUDE FILE DECLARATIONS */
  24          #include "ax22000.h"
  25          #include "mac.h"
  26          #include "stoe.h"
  27          #include "uart0.h"
  28          #include "delay.h"
  29          #include "at24c02.h"
  30          #include "mpsave.h"
  31          #include "mcpu.h"
  32          #include <intrins.h>
  33          #include "printd.h"
  34          
  35          /* GLOBAL VARIABLES DECLARATIONS */
  36          MAC_DEFAULT_AREA code* MAC_Default = 0x6000;
  37          U8_T XDATA MAC_InterruptStatus = 0;
  38          U8_T XDATA MAC_WifiMacAddr[6];
  39          U8_T XDATA MAC_WifiIp[4];
  40          U8_T XDATA MAC_WifiSubMask[4];
  41          
  42          /* LOCAL VARIABLES DECLARATIONS */
  43          #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)
                #if (MAC_REMOTE_WAKEUP == MAC_SUPPORT)
                static U8_T XDATA mac_WakeupFlag = 0;
                #endif
              #else
  48            #if (POWER_SAVING)
  49            static U8_T XDATA mac_WakeupFlag = 0;
  50            #endif
  51          #endif
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 2   

  52          
  53          /* LOCAL SUBPROGRAM DECLARATIONS */
  54          static void mac_InterruptEnable(void);
  55          static void mac_InterruptDisable(void);
  56          static void mac_StartOperate(void);
  57          
  58          /*
  59           * ----------------------------------------------------------------------------
  60           * Function Name: mac_ReadReg
  61           * Purpose:
  62           * Params:
  63           * Returns:
  64           * Note:
  65           * ----------------------------------------------------------------------------
  66           */
  67          void mac_ReadReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  68          {
  69   1              U8_T    isr;
  70   1      
  71   1              isr = EA;
  72   1              EA = 0;
  73   1              _nop_();
  74   1              MCIR = regaddr;
  75   1              while (length--)
  76   1                      pbuf[length] = MDR;
  77   1              EA = isr;
  78   1      
  79   1      } /* End of mac_ReadReg */
  80          
  81          /*
  82           * ----------------------------------------------------------------------------
  83           * Function Name: mac_WriteReg
  84           * Purpose:
  85           * Params:
  86           * Returns:
  87           * Note:
  88           * ----------------------------------------------------------------------------
  89           */
  90          void mac_WriteReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  91          {
  92   1              U8_T    isr;
  93   1      
  94   1              isr = EA;
  95   1              EA = 0;
  96   1              while (length--)
  97   1                      MDR = pbuf[length];
  98   1              MCIR = regaddr;
  99   1              EA = isr;
 100   1      
 101   1      } /* End of mac_WriteReg */
 102          
 103          #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 104          /*
 105           * ----------------------------------------------------------------------------
 106           * Function Name: MAC_ValidateSubsystemId
 107           * Purpose:
 108           * Params:
 109           * Returns:
 110           * Note:
 111           * ----------------------------------------------------------------------------
 112           */
 113          void MAC_ValidateSubsystemId(void)
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 3   

 114          {
 115   1              U8_T XDATA      temp[6];
 116   1              U16_T XDATA     i;
 117   1      
 118   1              if (MCPU_NoCfgEeprom())
 119   1              {
 120   2      LOAD_FROM_FLASH:
 121   2                      if (MAC_Default->HwDefault[0x40] == 'A' &&
 122   2                              MAC_Default->HwDefault[0x41] == 'S' &&
 123   2                              MAC_Default->HwDefault[0x42] == 'I' &&
 124   2                              MAC_Default->HwDefault[0x43] == 'X')
 125   2                      {
 126   3                              printd("Load WIFI mac/ip/subnet from FLASH.\n\r");
 127   3                              MAC_WifiMacAddr[0] = MAC_Default->HwDefault[0x55];
 128   3                              MAC_WifiMacAddr[1] = MAC_Default->HwDefault[0x54];
 129   3                              MAC_WifiMacAddr[2] = MAC_Default->HwDefault[0x53];
 130   3                              MAC_WifiMacAddr[3] = MAC_Default->HwDefault[0x52];
 131   3                              MAC_WifiMacAddr[4] = MAC_Default->HwDefault[0x51];
 132   3                              MAC_WifiMacAddr[5] = MAC_Default->HwDefault[0x50];
 133   3                              MAC_WifiIp[0] = MAC_Default->HwDefault[0x59];
 134   3                              MAC_WifiIp[1] = MAC_Default->HwDefault[0x58];
 135   3                              MAC_WifiIp[2] = MAC_Default->HwDefault[0x57];
 136   3                              MAC_WifiIp[3] = MAC_Default->HwDefault[0x56];
 137   3                              MAC_WifiSubMask[0] = MAC_Default->HwDefault[0x5D];
 138   3                              MAC_WifiSubMask[1] = MAC_Default->HwDefault[0x5C];
 139   3                              MAC_WifiSubMask[2] = MAC_Default->HwDefault[0x5B];
 140   3                              MAC_WifiSubMask[3] = MAC_Default->HwDefault[0x5A];
 141   3                      }
 142   2                      else
 143   2                      {
 144   3                              /* Allocate default WIFI mac/ip/subnet */
 145   3                              printd("Invalid subsystem id in FLASH so that load driver default.\n\r");
 146   3                              printd("WIFI mac = 00:12:34:56:78:9A\n\r");
 147   3                              printd("WIFI ip = 192.168.2.250\n\r");
 148   3                              printd("WIFI subnet = 255.255.255.0\n\r");
 149   3                              MAC_WifiMacAddr[0] = 0x00;
 150   3                              MAC_WifiMacAddr[1] = 0x12;
 151   3                              MAC_WifiMacAddr[2] = 0x34;
 152   3                              MAC_WifiMacAddr[3] = 0x56;
 153   3                              MAC_WifiMacAddr[4] = 0x78;
 154   3                              MAC_WifiMacAddr[5] = 0x9A;
 155   3                              MAC_WifiIp[0] = 192;
 156   3                              MAC_WifiIp[1] = 168;
 157   3                              MAC_WifiIp[2] = 2;
 158   3                              MAC_WifiIp[3] = 3;
 159   3                              MAC_WifiSubMask[0] = 255;
 160   3                              MAC_WifiSubMask[1] = 255;
 161   3                              MAC_WifiSubMask[2] = 255;
 162   3                              MAC_WifiSubMask[3] = 0;
 163   3                              return;
 164   3                      }
 165   2              }
 166   1              else
 167   1              {
 168   2                      if(EEPROM_Read(0x40, 4, temp))
 169   2                      {
 170   3                              if (temp[0] == 'A' &&
 171   3                                      temp[1] == 'S' &&
 172   3                                      temp[2] == 'I' &&
 173   3                                      temp[3] == 'X')
 174   3                              {
 175   4                                      if (MAC_Default->HwDefault[0x40] == 'A' &&
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 4   

 176   4                                              MAC_Default->HwDefault[0x41] == 'S' &&
 177   4                                              MAC_Default->HwDefault[0x42] == 'I' &&
 178   4                                              MAC_Default->HwDefault[0x43] == 'X')
 179   4                                      {
 180   5                                              /* Compare pattern from hardware_type to ip */
 181   5                                              for (i = 0x44; i < 0x5E; i++)
 182   5                                              {
 183   6                                                      if (EEPROM_Read(i, 1, temp))
 184   6                                                      {
 185   7                                                              if (temp[0] != MAC_Default->HwDefault[i])
 186   7                                                              {
 187   8                                                                      printd("Parameters (mac ~ ip) in EEPROM are different with FLASH.\n\rReload from FLASH.\n\r");
 188   8                                                                      goto LOAD_FROM_FLASH;
 189   8                                                              }
 190   7                                                      }
 191   6                                                      else
 192   6                                                      {
 193   7                                                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 194   7                                                              goto LOAD_FROM_FLASH;
 195   7                                                      }
 196   6                                              }
 197   5                                              
 198   5                                              /* Compare pattern from hardware_type to ip */
 199   5                                              for (i = 0xF4; i < 0x100; i++)
 200   5                                              {
 201   6                                                      if (EEPROM_Read(i, 1, temp))
 202   6                                                      {
 203   7                                                              if (temp[0] != MAC_Default->HwDefault[i])
 204   7                                                              {
 205   8                                                                      printd("Serial num in EEPROM are different with FLASH.\n\rReload from FLASH.\n\r");
 206   8                                                                      goto LOAD_FROM_FLASH;
 207   8                                                              }
 208   7                                                      }
 209   6                                                      else
 210   6                                                      {
 211   7                                                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 212   7                                                              goto LOAD_FROM_FLASH;
 213   7                                                      }
 214   6                                              }
 215   5                                      }
 216   4                                              
 217   4                                      /* Load WIFI mac from EEPROM */
 218   4                                      if(EEPROM_Read(0x50, 6, temp))
 219   4                                      {
 220   5                                              MAC_WifiMacAddr[0] = temp[5];
 221   5                                              MAC_WifiMacAddr[1] = temp[4];
 222   5                                              MAC_WifiMacAddr[2] = temp[3];
 223   5                                              MAC_WifiMacAddr[3] = temp[2];
 224   5                                              MAC_WifiMacAddr[4] = temp[1];
 225   5                                              MAC_WifiMacAddr[5] = temp[0];
 226   5                                      }
 227   4                                      else
 228   4                                      {
 229   5                                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 230   5                                              goto LOAD_FROM_FLASH;
 231   5                                      }
 232   4                                      
 233   4                                      /* Load WIFI ip from EEPROM */
 234   4                                      if(EEPROM_Read(0x56, 4, temp))
 235   4                                      {
 236   5                                              MAC_WifiIp[0] = temp[3];
 237   5                                              MAC_WifiIp[1] = temp[2];
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 5   

 238   5                                              MAC_WifiIp[2] = temp[1];
 239   5                                              MAC_WifiIp[3] = temp[0];
 240   5                                      }
 241   4                                      else
 242   4                                      {
 243   5                                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 244   5                                              goto LOAD_FROM_FLASH;
 245   5                                      }
 246   4                                      
 247   4                                      /* Load WIFI subnet from EEPROM */
 248   4                                      if(EEPROM_Read(0x5A, 4, temp))
 249   4                                      {
 250   5                                              MAC_WifiSubMask[0] = temp[3];
 251   5                                              MAC_WifiSubMask[1] = temp[2];
 252   5                                              MAC_WifiSubMask[2] = temp[1];
 253   5                                              MAC_WifiSubMask[3] = temp[0];
 254   5                                      }
 255   4                                      else
 256   4                                      {
 257   5                                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 258   5                                              goto LOAD_FROM_FLASH;
 259   5                                      }
 260   4                              }
 261   3                              else
 262   3                              {
 263   4                                      printd("Invalid subsystem id in EEPROM so that reload from FLASH.\n\r");
 264   4                                      goto LOAD_FROM_FLASH;
 265   4                              }
 266   3                      }
 267   2                      else
 268   2                      {
 269   3                              printd("Can not read EEPROM so that reload from FLASH.\n\r");
 270   3                              goto LOAD_FROM_FLASH;
 271   3                      }
 272   2              }
 273   1              
 274   1              /* Check out if mac is valid */
 275   1              temp[0] = 0;
 276   1              temp[1] = 0;
 277   1              for (i = 0; i < MAC_ADDRESS_LEN; i++)
 278   1              {
 279   2                      if (MAC_WifiMacAddr[i] == 0x00)
 280   2                      {
 281   3                              temp[0] += 1;
 282   3                      }
 283   2                      else if (MAC_WifiMacAddr[i] == 0xFF)
 284   2                      {
 285   3                              temp[1] += 1;
 286   3                      }
 287   2              }
 288   1              
 289   1              if (temp[0] == MAC_ADDRESS_LEN ||
 290   1                      temp[1] == MAC_ADDRESS_LEN)
 291   1              {
 292   2                      printd("Invalid WIFI mac value (all 0x00 or 0xFF) so that load driver default.\n\r");
 293   2                      printd("WIFI mac = 00:12:34:56:78:9A\n\r");
 294   2                      MAC_WifiMacAddr[0] = 0x00;
 295   2                      MAC_WifiMacAddr[1] = 0x12;
 296   2                      MAC_WifiMacAddr[2] = 0x34;
 297   2                      MAC_WifiMacAddr[3] = 0x56;
 298   2                      MAC_WifiMacAddr[4] = 0x78;
 299   2                      MAC_WifiMacAddr[5] = 0x9A;
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 6   

 300   2              }
 301   1              
 302   1              /* Check out if ip is valid */
 303   1              temp[0] = 0;
 304   1              temp[1] = 0;
 305   1              for (i = 0; i < 4; i++)
 306   1              {
 307   2                      if (MAC_WifiIp[i] == 0x00)
 308   2                      {
 309   3                              temp[0] += 1;
 310   3                      }
 311   2                      else if (MAC_WifiIp[i] == 0xFF)
 312   2                      {
 313   3                              temp[1] += 1;
 314   3                      }
 315   2              }
 316   1              
 317   1              if (temp[0] == 4 ||
 318   1                      temp[1] == 4)
 319   1              {
 320   2                      printd("Invalid WIFI ip value (all 0x00 or 0xFF) so that load driver default.\n\r");
 321   2                      printd("WIFI ip = 192.168.2.250\n\r");
 322   2                      printd("WIFI subnet = 255.255.255.0\n\r");
 323   2                      MAC_WifiIp[0] = 192;
 324   2                      MAC_WifiIp[1] = 168;
 325   2                      MAC_WifiIp[2] = 2;
 326   2                      MAC_WifiIp[3] = 3;
 327   2                      MAC_WifiSubMask[0] = 255;
 328   2                      MAC_WifiSubMask[1] = 255;
 329   2                      MAC_WifiSubMask[2] = 255;
 330   2                      MAC_WifiSubMask[3] = 0;
 331   2              }
 332   1      
 333   1      } /* MAC_ValidateSubsystemId */
 334          #endif
 335          
 336          /*
 337           * ----------------------------------------------------------------------------
 338           * Function Name: MAC_Init
 339           * Purpose: initial all registers and variables of MAC.
 340           * Params: network_type -0: auto- negotiation
 341           *                                              -1: fixed 100 full speed.
 342           *                                              -2: fixed 100 half speed.
 343           *                                              -3: fixed 10 full speed.
 344           *                                              -4: fixed 10 half speed.
 345           * Returns:
 346           * Note:
 347           * ----------------------------------------------------------------------------
 348           */
 349          void MAC_Init(U8_T network_type)
 350          {
 351   1              U8_T XDATA      temp[6];
 352   1              U8_T            i;
 353   1      
 354   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 355   1              PNetStation->SecPermStaAddr[0] = MAC_WifiMacAddr[0];
 356   1              PNetStation->SecPermStaAddr[1] = MAC_WifiMacAddr[1];
 357   1              PNetStation->SecPermStaAddr[2] = MAC_WifiMacAddr[2];
 358   1              PNetStation->SecPermStaAddr[3] = MAC_WifiMacAddr[3];
 359   1              PNetStation->SecPermStaAddr[4] = MAC_WifiMacAddr[4];
 360   1              PNetStation->SecPermStaAddr[5] = MAC_WifiMacAddr[5];
 361   1              for (i = 0; i < MAC_ADDRESS_LEN; i++)
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 7   

 362   1                      PNetStation->SecCurrStaAddr[i] = PNetStation->SecPermStaAddr[i];
 363   1      
 364   1              mac_WriteReg(MAC_ADDR_REG, PNetStation->SecPermStaAddr, MAC_ADDRESS_LEN);
 365   1      #else /* (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
                      mac_ReadReg(MAC_ADDR_REG, PNetStation->PermStaAddr, MAC_ADDRESS_LEN);
              
                      for (i = 0; i < MAC_ADDRESS_LEN; i++)
                              PNetStation->CurrStaAddr[i] = PNetStation->PermStaAddr[i];
              #endif
 371   1      
 372   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)
                      /* do not use WiFi, change to Ethernet mode */
                      temp[0] = ARBIT_ETH_ONLY;
              #else /* MAC_ARBIT_WIFI */
 376   1              temp[0] = ARBIT_MII_ONLY;
 377   1      #endif
 378   1              mac_WriteReg(MAC_ARB_CTL_REG, temp, 1);
 379   1      
 380   1              PBDP->MacInfo.MediumLinkType = (MEDIUM_ENABLE_RECEIVE | MEDIUM_ENABLE_TX_FLOWCTRL);
 381   1              PBDP->MacInfo.FullDuplex = 1;
 382   1      
 383   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_WIFI)
 384   1              /* FIXED_100_HALF in WiFi mode without PHY */
 385   1              network_type = FIXED_100_FULL; //FIXED_100_FULL
 386   1              PBDP->MacInfo.NetworkType = MAC_LINK_100M_SPEED;
 387   1              PBDP->MacInfo.MediumLinkType |= MEDIUM_MII_100M_MODE;
 388   1              /* set medium status */
 389   1              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
 390   1      #else  /* (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
                      switch (network_type)
                      {
                      default:
                      case AUTO_NEGOTIATION:
                              PBDP->MacInfo.NetworkType = MAC_AUTO_NEGOTIATION;
                              PBDP->MacInfo.MediumLinkType|=(MEDIUM_FULL_DUPLEX_MODE | MEDIUM_MII_100M_MODE |
                                      MEDIUM_ENABLE_RX_FLOWCTRL);
                              break;
                      case FIXED_100_FULL:
                              PBDP->MacInfo.NetworkType = (MAC_LINK_100M_SPEED | MAC_LINK_FULL_DUPLEX);
                              PBDP->MacInfo.MediumLinkType|=(MEDIUM_FULL_DUPLEX_MODE | MEDIUM_MII_100M_MODE |
                                      MEDIUM_ENABLE_RX_FLOWCTRL);
                              break;
                      case FIXED_100_HALF:
                              PBDP->MacInfo.NetworkType = MAC_LINK_100M_SPEED;
                              PBDP->MacInfo.MediumLinkType |= MEDIUM_MII_100M_MODE;
                              break;
                      case FIXED_10_FULL:
                              PBDP->MacInfo.NetworkType = (MAC_LINK_10M_SPEED | MAC_LINK_FULL_DUPLEX);
                              PBDP->MacInfo.MediumLinkType |= (MEDIUM_FULL_DUPLEX_MODE |
                                      MEDIUM_ENABLE_RX_FLOWCTRL);
                              break;
                      case FIXED_10_HALF:
                              PBDP->MacInfo.NetworkType = MAC_LINK_10M_SPEED;
                              break;
                      }
                      /* set medium status */
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
              #endif
 420   1      
 421   1              /* set IPG */
 422   1              temp[0] = 0x2b;
 423   1              temp[1] = 0x16;
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 8   

 424   1              temp[2] = 0x95;
 425   1              mac_WriteReg(MAC_IPG_CTL_REG, temp, 3);
 426   1      
 427   1              /* set RX filter. */
 428   1              temp[0] = BIT6;
 429   1              mac_WriteReg(MAC_RX_CTL_REG, temp, 1);
 430   1              MAC_SetRxFilter(MAC_RCV_BROADCAST);
 431   1      
 432   1              PBDP->MacInfo.LinkSpeed = 0; // Ethernet not linkup.
 433   1      
 434   1      #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH)
                      /* decide interrupt mask */
              #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE) 
                      PBDP->MacInfo.InterruptMask = PRIMARY_LINK_CHANGE_ENABLE;
              #endif
              
                      /* phy initialize. */
                      PHY_Init(network_type);
              #endif
 443   1      } /* End of MAC_Init() */
 444          
 445          /*
 446           * ----------------------------------------------------------------------------
 447           * Function Name: MAC_GetMacAddr
 448           * Purpose:
 449           * Returns:
 450           * Note:
 451           * ----------------------------------------------------------------------------
 452           */
 453          U8_T* MAC_GetMacAddr(void)
 454          {
 455   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)   
                      return PNetStation->CurrStaAddr;
              #else /* MAC_ARBIT_WIFI */
 458   1              return PNetStation->SecCurrStaAddr;
 459   1      #endif
 460   1      } /* End of MAC_GetMacAddr() */
 461          
 462          /*
 463           * ----------------------------------------------------------------------------
 464           * Function Name: MAC_SetMacAddr
 465           * Purpose:
 466           * Params:      addr- pointer to MAC address
 467           * Returns:
 468           * Note:
 469           * ----------------------------------------------------------------------------
 470           */
 471          void MAC_SetMacAddr(U8_T* addr)
 472          {
 473   1              U8_T i;
 474   1      
 475   1      #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH)
                              for (i = 0; i < MAC_ADDRESS_LEN; i++)
                                      PNetStation->CurrStaAddr[i] = addr[i];
              
                              mac_WriteReg(MAC_ADDR_REG, PNetStation->CurrStaAddr, MAC_ADDRESS_LEN);
              #else /* MAC_ARBIT_WIFI */
 481   1                      for (i = 0; i < MAC_ADDRESS_LEN; i++)
 482   1                              PNetStation->SecCurrStaAddr[i] = addr[i];
 483   1                              
 484   1                      mac_WriteReg(MAC_ADDR_REG, PNetStation->SecCurrStaAddr, MAC_ADDRESS_LEN);
 485   1      #endif
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 9   

 486   1      } /* End of MAC_SetMacAddr() */
 487          
 488          /*
 489           * ----------------------------------------------------------------------------
 490           * Function Name: MAC_Start
 491           * Purpose:
 492           * Params:
 493           * Returns:
 494           * Note:
 495           * ----------------------------------------------------------------------------
 496           */
 497          void MAC_Start(void)
 498          {
 499   1      #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH)
                #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE)
              
                      U8_T XDATA      temp;
              
                      /* clear mac interrupt status */
                      mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &temp, 1);
              
                      /* enable mac interrupt */
                      mac_InterruptEnable();
                #endif
              #endif
 511   1      
 512   1              /* start mac to receive/transmit packets */
 513   1              mac_StartOperate();
 514   1      
 515   1      } /* End of MAC_Start() */
 516          
 517          /*
 518           * ----------------------------------------------------------------------------
 519           * Function Name: mac_StartOperate
 520           * Purpose:
 521           * Params:
 522           * Returns:
 523           * Note:
 524           * ----------------------------------------------------------------------------
 525           */
 526          void mac_StartOperate(void)
 527          {
 528   1              U8_T XDATA      temp;
 529   1      
 530   1              mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
 531   1      
 532   1              /* set mac register to start receive/transmit packets. */
 533   1              temp |= START_OPERATION;
 534   1              mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
 535   1      
 536   1      } /* End of mac_StartOperate */
 537          
 538          #if 0
              /*
               * ----------------------------------------------------------------------------
               * Function Name: mac_StopOperate
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 10  

              void mac_StopOperate(void)
              {
                      U8_T XDATA      temp;
              
                      mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
              
                      temp &= ~START_OPERATION;
                      mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
              
              } /* End of mac_StopOperate */
              #endif
 559          
 560          /*
 561           * ----------------------------------------------------------------------------
 562           * Function Name: MAC_SetRxFilter
 563           * Purpose:
 564           * Params:
 565           * Returns:
 566           * Note:
 567           * ----------------------------------------------------------------------------
 568           */
 569          void MAC_SetRxFilter(U8_T filter)
 570          {
 571   1              U8_T XDATA      temp;
 572   1      
 573   1              mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
 574   1      
 575   1              /* set rcv filter. */
 576   1              temp &= 0xc0;
 577   1              if (filter & MAC_RCV_PROMISCUOUS)
 578   1                      temp |= PACKET_TYPE_PROMISCOUS;
 579   1              if (filter & MAC_RCV_ALL_MULTICAST)
 580   1                      temp |= PACKET_TYPE_ALL_MULTI;
 581   1              if (filter & MAC_RCV_BROADCAST)
 582   1                      temp |= PACKET_TYPE_BROADCAST;
 583   1              if (filter & MAC_RCV_MULTICAST)
 584   1                      temp |= PACKET_TYPE_MULTICAST;
 585   1      
 586   1              mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
 587   1      
 588   1      } /* End of MAC_SetRxFilter() */
 589          
 590          #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH)
              #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE) 
              /*
               * ----------------------------------------------------------------------------
               * Function Name: mac_InterruptEnable
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void mac_InterruptEnable(void)
              {
                      U8_T XDATA      temp;
              
                      /* set link change interrupt enable */
                      temp = PBDP->MacInfo.InterruptMask;
                      mac_WriteReg(MAC_LINK_CHANGE_INT_ENABLE_REG, &temp, 1);
              
              } /* End of mac_InterruptEnable */
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 11  

              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: mac_InterruptDisable
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void mac_InterruptDisable(void)
              {
                      U8_T XDATA      temp;
              
                      temp = 0;
                      mac_WriteReg(MAC_LINK_CHANGE_INT_ENABLE_REG, &temp, 1);
              
              } /* End of mac_InterruptDisable */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_SetInterruptFlag
               * Purpose:
               * Params:
               * Returns:
               * Note: The function only be called by interrupt routine
               * ----------------------------------------------------------------------------
               */
              void MAC_SetInterruptFlag(void)
              {
                      mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &MAC_InterruptStatus, 1);
              
                      if (MCPU_SleepFlag)
                              MCPU_SetWakeUpByMacFlag(MAC_InterruptStatus);
              
                      if (!(MAC_InterruptStatus & STATUS_PRIMARY_LINK_CHANGE))
                              MAC_InterruptStatus = 0;
              
              } /* End of MAC_SetInterruptFlag() */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_GetInterruptFlag
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T MAC_GetInterruptFlag(void)
              {
                      U8_T flag, isr;
              
                      isr = EA;
                      EA = 0;
                      flag = MAC_InterruptStatus;
                      EA = isr;
              
                      return flag;
              
              } /* End of MAC_GetInterruptFlag() */
              #endif
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 12  

              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: mac_GetMediaType
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T mac_GetMediaType(void)
              {
                      U16_T   phylinkstatus;
              
                      phylinkstatus = PHY_CheckMediaType();
              
                      PBDP->MacInfo.FullDuplex = TRUE;
              
                      PBDP->MacInfo.MediumLinkType = (MEDIUM_ENABLE_TX_FLOWCTRL | MEDIUM_ENABLE_RECEIVE);
              
                      /* Determine if we're linked to 100 full duplex. */
                      if (phylinkstatus & ANLPAR_100TXFD)
                      {
                              PBDP->MacInfo.LinkSpeed = 100;
                              PBDP->MacInfo.MediumLinkType |=(MEDIUM_FULL_DUPLEX_MODE |MEDIUM_MII_100M_MODE);
                              printd ("Link to 100 FULL.\n\r");
                      }
                      /* Determine if we're linked to 100 half duplex. */
                      else if (phylinkstatus & ANLPAR_100TX)
                      {
                              PBDP->MacInfo.LinkSpeed = 100;
                              PBDP->MacInfo.MediumLinkType |= MEDIUM_MII_100M_MODE;
                              PBDP->MacInfo.FullDuplex = FALSE;
                              printd ("Link to 100 HALF.\n\r");
                      } 
                      /* Determine if we're linked to 10 full duplex. */
                      else if (phylinkstatus & ANLPAR_10TFD)
                      {
                              PBDP->MacInfo.LinkSpeed = 10;
                              PBDP->MacInfo.MediumLinkType |= MEDIUM_FULL_DUPLEX_MODE;
                              printd ("Link to 10 FULL.\n\r");
                      }
                      /* we're linked to 10 half duplex. */
                      else
                      {
                              PBDP->MacInfo.LinkSpeed = 10;
                              PBDP->MacInfo.FullDuplex = FALSE;
                              printd ("Link to 10 HALF.\n\r");
                      }
              
                      if (PBDP->MacInfo.FullDuplex)
                              PBDP->MacInfo.MediumLinkType |= MEDIUM_ENABLE_RX_FLOWCTRL;
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
              
                      return PBDP->MacInfo.LinkSpeed;
              
              } /* End of mac_GetMediaType */
              
              #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE)
              /*
               * ----------------------------------------------------------------------------
               * Function Name: mac_LinkSpeedChk
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 13  

               * Purpose:
               * Params: none
               * Returns:     100: Ethernet is link to 100M
               *                      10 : Ethernet is link to 10M
               *                      0  : not link
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T mac_LinkSpeedChk(void)
              {
                      if (MAC_InterruptStatus & STATUS_PRIMARY_IS_LINK_UP)
                      {
                              STOE_ConnectState |= STOE_ETHERNET_LINK;
                              if (PBDP->MacInfo.NetworkType == MAC_AUTO_NEGOTIATION)
                                      mac_GetMediaType();
                      }
                      else
                      {
                              printd ("Ethernet is now unlink.\n\r");
                              STOE_ConnectState &= ~STOE_ETHERNET_LINK;
                              if (PBDP->MacInfo.LinkSpeed)
                              {
                                      PBDP->MacInfo.LinkSpeed = 0;
                              }
                      }
              
                      return PBDP->MacInfo.LinkSpeed;
              
              } /* End of mac_LinkSpeedChk */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_ProcessInterrupt
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void MAC_ProcessInterrupt(void)
              {
                      U8_T XDATA                      temp;
              
                      if (MAC_InterruptStatus & STATUS_PRIMARY_LINK_CHANGE)
                      {
                              if (mac_LinkSpeedChk())
                              {
                                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                                      temp |= MEDIUM_ENABLE_RECEIVE;
                                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                                      STOE_DROP_PKT = 0;
                              }
                              else
                              {
                                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                                      temp &= ~MEDIUM_ENABLE_RECEIVE;
                                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                                      STOE_DROP_PKT = 1;
                              }
                      }
              
                      MAC_InterruptStatus = 0;
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 14  

              
              } /* End of MAC_ProcessInterrupt */
              #else
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_LinkSpeedChk
               * Purpose:
               * Params: none
               * Returns:     100: Ethernet is link to 100M
               *                      10 : Ethernet is link to 10M
               *                      0  : not link
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T MAC_LinkSpeedChk(void)
              {
                      mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &MAC_InterruptStatus, 1);
                      if (MAC_InterruptStatus & STATUS_PRIMARY_IS_LINK_UP)
                      {
                              STOE_ConnectState |= STOE_ETHERNET_LINK;
                              if (PBDP->MacInfo.LinkSpeed == 0)
                              {
                                      if (PBDP->MacInfo.NetworkType == MAC_AUTO_NEGOTIATION)
                                              mac_GetMediaType();
                                      else
                                              PBDP->MacInfo.LinkSpeed = PBDP->MacInfo.NetworkType & 0x7f;
                              }
                      }
                      else
                      {
                              STOE_ConnectState &= ~STOE_ETHERNET_LINK;
                              if (PBDP->MacInfo.LinkSpeed)
                              {
                                      PBDP->MacInfo.LinkSpeed = 0;
                              }
                      }
              
                      return PBDP->MacInfo.LinkSpeed;
              
              } /* End of MAC_LinkSpeedChk */
              #endif
              
              #if (MAC_REMOTE_WAKEUP == MAC_SUPPORT)
              /*
              * -----------------------------------------------------------------------------
               * Function Name: mac_crc16
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              U16_T mac_crc16(U8_T* pbuf, U8_T len)
              {
                      U16_T   crc, carry;
                      U8_T    i, j;
                      S8_T    curByte;
              
                      crc = 0xffff;
              
                      for (i = 0; i < len; i++)
                      {
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 15  

                              curByte = pbuf[i];
                              for (j = 0; j < 8; j++)
                              {
                                      carry = ((crc & 0x8000) ? 1 : 0) ^ (curByte & 0x01);
                                      crc <<= 1;
                                      curByte >>= 1;
              
                                      if (carry)
                                          crc = ((crc ^ 0x8004) | carry);
                              }
                  }
              
                      return crc;
              
              } /* End of cal_crc16 */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_SetWakeupFrame
               * Purpose: for setting registers about wakeup frame
               * Params:      pWuf : point to MAC_WUF data structure
               * Returns:     0: setting fail.
               *                      1: setting success.
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T MAC_SetWakeupFrame(MAC_WUF* pWuf)
              {
                      U32_T XDATA     mask0, mask1;
                      U16_T XDATA crc16;
                      U8_T XDATA*     pMask;
                      U8_T XDATA      wakeupCmd, offset0, offset1;
                      U8_T            mode, i, maskLen, x, y;
                      U8_T            frame[64];
              
                      mode = pWuf->Mode;
                      offset0 = pWuf->Offset0;
                      offset1 = pWuf->Offset1;
                      mask0 = pWuf->Mask0;
                      mask1 = pWuf->Mask1;
              
                      mac_WriteReg(MAC_WAKEUP_FRAME_OFFSET1, &offset1, 1);
                      mac_WriteReg(MAC_WAKEUP_FRAME_OFFSET0, &offset0, 1);
                      mac_WriteReg(MAC_WAKEUP_FRAME_MASK1, (U8_T XDATA*)&mask1, 4);
                      mac_WriteReg(MAC_WAKEUP_FRAME_MASK0, (U8_T XDATA*)&mask0, 4);
              
                      if (mode < WUF_BOTH_FILTERS) /* single filter */
                      {
                              if (mode & BIT0)
                              {
                                      wakeupCmd = WAKEUP_FRAME_FILTER1_ENABLE;
                                      if (mode & BIT1)
                                              wakeupCmd |= WAKEUP_FRAME_FILTER1_UNI_ENABLE;
                              }
                              else
                              {
                                      wakeupCmd = WAKEUP_FRAME_FILTER0_ENABLE;
                                      if (mode & BIT1)
                                              wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                              }
                      }
                      else if (mode < WUF_CASCADE) /* both filter */
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 16  

                      {
                              wakeupCmd = (WAKEUP_FRAME_FILTER1_ENABLE | WAKEUP_FRAME_FILTER0_ENABLE);
                              if (mode & BIT1)
                                      wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                      }
                      else /* cascade */
                      {
                              wakeupCmd = (WAKEUP_FRAME_FILTER1_ENABLE | WAKEUP_FRAME_FILTER0_ENABLE |
                                      WAKEUP_FRAME_CASCADE_ENABLE);
                              if (mode & BIT1)
                                      wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                      }
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER0_UNI_ENABLE) && (mask0 == 0))
                              return 0;
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER1_UNI_ENABLE) && (mask1 == 0))
                              return 0;
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER0_UNI_ENABLE) &&
                              !(wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE))
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask0;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset0*2) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset0*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC0, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE0, &frame[maskLen -1], 1);
                      }
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER1_UNI_ENABLE) &&
                              !(wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE))
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask1;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset1*2) > pWuf->Length)
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 17  

                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset1*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC1, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE1, &frame[maskLen -1], 1);
                      }
              
                      if (wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE)
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask0;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset0*2) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset0*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              pMask = (U8_T XDATA*)&mask1;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + (offset1 + offset0)*2 + 32) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + (offset1 + offset0)*2 + 32];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC1, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE1, &frame[maskLen -1], 1);
                      }
              
                      mac_WriteReg(MAC_WAKEUP_FRAME_COMMAND, &wakeupCmd, 1);
                      return 1;
              
              } /* End of MAC_SetWakeupFrame() */
              
              /*
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 18  

              * -----------------------------------------------------------------------------
               * Function Name: MAC_SystemSleep
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void MAC_SystemSleep(void)
              {
                      U8_T XDATA      temp;
              
                      /* disable mac receive */
                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      temp &= 0xfb;
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
              
                      DELAY_Ms(500);
              
                      PCON &= ~(PMM_ | STOP_ | SWB_ | PMMS_);
                      if (MCPU_GetPowerSavingMode() & STOP_)
                              PCON |= STOP_;
                      else 
                              PCON |= (MCPU_GetPowerSavingMode() | PMMS_);
              
                      MCPU_SleepFlag = 1;
              
                      DELAY_Ms(500);
              
                      /* enable mac receive */
                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      temp |= 4;
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
              
              } /* End of MAC_SystemSleep() */
              #endif
              #endif /* #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH) */
1081          
1082          #if (MAC_ARBIT_MODE == MAC_ARBIT_ETH) 
                #if (MAC_REMOTE_WAKEUP==MAC_SUPPORT)
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_WakeupEnable
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void MAC_WakeupEnable(U8_T type)
              {
                      U8_T    temp = 0;
              
                      mac_WakeupFlag |= type;
                      if (mac_WakeupFlag & MAC_PRIMARY_PHY_LINK_WAKEUP)
                              temp |= WAKEUP_BY_PRIMARY_LINK_UP;
                      if (mac_WakeupFlag & MAC_MAGIC_PACKET_WAKEUP)
                              temp |= WAKEUP_BY_MAGIC_PACKET;
                      if (mac_WakeupFlag & MAC_EXTERNAL_PIN_WAKEUP)
                              temp |= WAKEUP_BY_EXTER_PIN_TRIG;
                      if (mac_WakeupFlag & MAC_MS_FRAME_WAKEUP)
                              temp |= WAKEUP_BY_MICROSOFT_FRAME;
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 19  

              
                      mac_WriteReg(MAC_WAKEUP_INT_ENABLE_REG, &temp, 1);
              
                      if (mac_WakeupFlag)
                      {
                              MCPU_SetWakeUpEventFlag(MCPU_WAKEUP_BY_ETHERNET);
                      }
              
              } /* End of MAC_WakeupEnable() */
                #endif
              #else
1117            #if (POWER_SAVING)
1118          /*
1119           * ----------------------------------------------------------------------------
1120           * Function Name: MAC_WakeupEnable
1121           * Purpose:
1122           * Params:
1123           * Returns:
1124           * Note:
1125           * ----------------------------------------------------------------------------
1126           */
1127          void MAC_WakeupEnable(U8_T type)
1128          {
1129   1              U8_T    temp = 0;
1130   1      
1131   1              mac_WakeupFlag |= type;
1132   1              if (mac_WakeupFlag & MAC_PRIMARY_PHY_LINK_WAKEUP)
1133   1                      temp |= WAKEUP_BY_PRIMARY_LINK_UP;
1134   1              if (mac_WakeupFlag & MAC_MAGIC_PACKET_WAKEUP)
1135   1                      temp |= WAKEUP_BY_MAGIC_PACKET;
1136   1              if (mac_WakeupFlag & MAC_EXTERNAL_PIN_WAKEUP)
1137   1                      temp |= WAKEUP_BY_EXTER_PIN_TRIG;
1138   1              if (mac_WakeupFlag & MAC_MS_FRAME_WAKEUP)
1139   1                      temp |= WAKEUP_BY_MICROSOFT_FRAME;
1140   1      
1141   1              mac_WriteReg(MAC_WAKEUP_INT_ENABLE_REG, &temp, 1);
1142   1      
1143   1              if (mac_WakeupFlag)
1144   1              {
1145   2                      MCPU_SetWakeUpEventTable(MCPU_WAKEUP_BY_ETHERNET);
1146   2              }
1147   1      
1148   1      } /* End of MAC_WakeupEnable() */
1149            #endif
1150          #endif
1151          
1152          #if (POWER_SAVING == MAC_SUPPORT)
1153          /*
1154          * -----------------------------------------------------------------------------
1155           * Function Name: MAC_PowerSavingSleep
1156           * Purpose:
1157           * Params:
1158           * Returns:
1159           * Note:
1160           * ----------------------------------------------------------------------------
1161           */
1162          void MAC_PowerSavingSleep(void)
1163          {
1164   1      #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH)
                      U8_T XDATA      temp;
              
                      if ((MCPU_GetPowerSavingMode() & STOP_) || PS_State) /* stop mode or deep sleep */ 
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 20  

                      {
                              /* disable mac receive */
                              mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                              temp &= 0xfb;
                              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      }
              #endif
1175   1      
1176   1              PCON &= ~(PMM_ | STOP_ | SWB_ | PMMS_);
1177   1              if (MCPU_GetPowerSavingMode() & STOP_)
1178   1                      PCON |= STOP_;
1179   1              else
1180   1                      PCON |= (MCPU_GetPowerSavingMode() | PMMS_);
1181   1      
1182   1              MCPU_SleepFlag = 1;
1183   1      
1184   1      #if (MAC_ARBIT_MODE & MAC_ARBIT_ETH)
                      if ((MCPU_GetPowerSavingMode() & STOP_) || PS_State) /* stop mode or deep sleep */
                      {
                              /* enable mac receive */
                              mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                              temp |= 4;
                              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      }
              #endif
1193   1      
1194   1      } /* End of MAC_PowerSavingSleep() */
1195          #endif
1196          
1197          #if (MAC_MULTICAST_FILTER == MAC_SUPPORT)
1198          /*
1199          * -----------------------------------------------------------------------------
1200           * Function Name: mac_ComputeCrc32
1201           * Purpose:
1202           * Params:
1203           * Returns:
1204           * Note:
1205           * ----------------------------------------------------------------------------
1206           */
1207          U32_T mac_ComputeCrc32(U16_T length, U8_T* pbuf)
1208          {
1209   1              U32_T   crc32 = 0xffffffff;
1210   1              U8_T    curByte, carry, j;
1211   1              
1212   1              for (; length; length--)
1213   1              {
1214   2                      curByte = *pbuf++;
1215   2                      for (j=0; j<8; j++)
1216   2                      {
1217   3                              carry = curByte & 1;
1218   3                              if ( crc32 & 0x80000000 )
1219   3                                      carry ^= 1;
1220   3                              crc32 <<= 1;
1221   3                              curByte >>= 1;
1222   3                              if (carry)
1223   3                                      crc32 ^= 0x04c11db7;
1224   3                      }
1225   2              }
1226   1              return crc32;
1227   1      
1228   1      } /* End of mac_ComputeCrc32() */
1229          
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 21  

1230          /*
1231           * ----------------------------------------------------------------------------
1232           * Function Name: MAC_MultiFilter
1233           * Purpose:
1234           * Params:
1235           * Returns:
1236           * Note:
1237           * ----------------------------------------------------------------------------
1238           */
1239          void MAC_MultiFilter(U8_T* pbuf, U8_T len)
1240          {
1241   1              U8_T    count = len/MAC_ADDRESS_LEN;
1242   1              U8_T    index, bitNum;
1243   1              U8_T    filter[8] = {0};
1244   1      
1245   1              for (index = 0; index < count; index++)
1246   1              {
1247   2                      if (!(pbuf[0] & 1))
1248   2                              break;
1249   2      
1250   2                      bitNum = (U8_T)((mac_ComputeCrc32(MAC_ADDRESS_LEN, pbuf)>>26)&0x3f);
1251   2                      pbuf += MAC_ADDRESS_LEN;
1252   2                      filter[7 - (bitNum/8)] |= (1 << (bitNum % 8));
1253   2              }
1254   1      
1255   1              mac_WriteReg(MAC_MULTICASE_REG, filter, 8);
1256   1      
1257   1      } /* End of MAC_MultiFilter() */
1258          #endif
1259          
1260          #if MAC_DEBUG
1261          /*
1262           * ----------------------------------------------------------------------------
1263           * Function Name: MAC_IndirectIO
1264           * Purpose: mac indirect register read/write, only for debugging.
1265           * Params:
1266           * Returns:
1267           * Note:
1268           * ----------------------------------------------------------------------------
1269           */
1270          U8_T MAC_IndirectIO(U8_T rw, U16_T index, U8_T XDATA* pbuf)
1271          {
1272   1              U8_T len;
1273   1      
1274   1              switch (index)
1275   1              {
1276   2              case MAC_SRAM_DATA_REG:
1277   2              case MAC_MULTICASE_REG:
1278   2                      len = 8;
1279   2                      break;
1280   2              case MAC_ADDR_REG:
1281   2                      if (rw == 1)
1282   2                      {
1283   3                              MAC_SetMacAddr(pbuf);
1284   3                      }
1285   2                      len = 6;
1286   2                      break;
1287   2              case MAC_WAKEUP_FRAME_MASK0:
1288   2              case MAC_WAKEUP_FRAME_MASK1:
1289   2                      len = 4;
1290   2                      break;
1291   2              case MAC_IPG_CTL_REG:
C51 COMPILER V9.01   MAC                                                                   03/08/2012 11:01:02 PAGE 22  

1292   2                      len = 3;
1293   2                      break;
1294   2              case MAC_SRAM_CMD_REG:
1295   2              case MAC_WAKEUP_FRAME_CRC0:
1296   2              case MAC_WAKEUP_FRAME_CRC1:
1297   2              case MAC_IN_PHY_MSG_REG:
1298   2                      len = 2;
1299   2                      break;
1300   2              case MAC_RX_CTL_REG:
1301   2              case MAC_TEST_REG:
1302   2              case MAC_MEDIUM_STATUS_MODE_REG:
1303   2              case MAC_ETH_INTERFACE_REG:
1304   2              case MAC_WAKEUP_INT_ENABLE_REG:
1305   2              case MAC_LINK_CHANGE_INT_ENABLE_REG:
1306   2              case MAC_WAKEUP_LINK_INT_STATUS_REG:
1307   2              case MAC_WAKEUP_FRAME_COMMAND:
1308   2              case MAC_WAKEUP_FRAME_OFFSET0:
1309   2              case MAC_WAKEUP_FRAME_LAST_BYTE0:
1310   2              case MAC_WAKEUP_FRAME_OFFSET1:
1311   2              case MAC_WAKEUP_FRAME_LAST_BYTE1:
1312   2              case MAC_ARB_CTL_REG:
1313   2              case MAC_IN_PHY_CTL_STATUS_REG:
1314   2              case MAC_IN_PHY_INT_ENABLE_REG:
1315   2              case MAC_IN_PHY_INT_STATUS_REG:
1316   2                      len = 1;
1317   2                      break;
1318   2              default:
1319   2                      return 0xff;
1320   2              }
1321   1      
1322   1              if (rw == 0) /* read */
1323   1                      mac_ReadReg (index, pbuf, len);
1324   1              else if (rw == 1) /* write */
1325   1                      mac_WriteReg (index, pbuf, len);
1326   1              else
1327   1                      return 0xff;
1328   1      
1329   1              return  len;
1330   1      
1331   1      } /* End of MAC_IndirectIO() */
1332          #endif
1333          
1334          /* End of mac.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2972    ----
   CONSTANT SIZE    =    597    ----
   XDATA SIZE       =     18      49
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
