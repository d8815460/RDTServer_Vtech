C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE UIP
OBJECT MODULE PLACED IN .\uip.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe ..\src\mtcpip\uip.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X8020) INCDIR(..
                    -\src\main;..\src\mcpu;..\src\mswdma;..\src\uart0;..\src\mmstimer;..\src\mwif;..\src\madapter;..\src\mtcpip;..\src\mping;
                    -..\src\mpppoe;..\src\si2c;..\src\mdnsc;..\src\mconsole;..\src\mtelnet;..\src\meeprom;..\src\mmac;..\src\mdhcpc;..\src\mh
                    -ttp;..\src\mgs2wifi;..\src\mhsuart;..\src\msmtpc;..\src\web_page;..\src\mdhcps;..\src\mdebug;..\..\..\Include;..\..\..\B
                    -uild\ASIX8051_220\) DEFINE(RuntimeCodeAt32KH) VARBANKING DEBUG PRINT(.\output\uip.lst) OBJECT(.\uip.obj)

line level    source

   1          /**
   2           * \addtogroup uip
   3           * @{
   4           */
   5          
   6          /**
   7           * \file
   8           * The uIP TCP/IP stack code.
   9           * \author Adam Dunkels <adam@dunkels.com>
  10           */
  11          
  12          /*
  13           * Copyright (c) 2001-2003, Adam Dunkels.
  14           * All rights reserved. 
  15           *
  16           * Redistribution and use in source and binary forms, with or without 
  17           * modification, are permitted provided that the following conditions 
  18           * are met: 
  19           * 1. Redistributions of source code must retain the above copyright 
  20           *    notice, this list of conditions and the following disclaimer. 
  21           * 2. Redistributions in binary form must reproduce the above copyright 
  22           *    notice, this list of conditions and the following disclaimer in the 
  23           *    documentation and/or other materials provided with the distribution. 
  24           * 3. The name of the author may not be used to endorse or promote
  25           *    products derived from this software without specific prior
  26           *    written permission.  
  27           *
  28           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  29           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  30           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  31           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  32           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  34           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  35           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  36           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  37           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  38           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
  39           *
  40           * This file is part of the uIP TCP/IP stack.
  41           *
  42           * $Id: uip.c,v$
  43           *
  44           */
  45          
  46          /*
  47          This is a small implementation of the IP and TCP protocols (as well as
  48          some basic ICMP stuff). The implementation couples the IP, TCP and the
  49          application layers very tightly. To keep the size of the compiled code
  50          down, this code also features heavy usage of the goto statement.
  51          
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 2   

  52          The principle is that we have a small buffer, called the uip_buf, in
  53          which the device driver puts an incoming packet. The TCP/IP stack
  54          parses the headers in the packet, and calls upon the application. If
  55          the remote host has sent data to the application, this data is present
  56          in the uip_buf and the application read the data from there. It is up
  57          to the application to put this data into a byte stream if needed. The
  58          application will not be fed with data that is out of sequence.
  59          
  60          If the application whishes to send data to the peer, it should put its
  61          data into the uip_buf, 40 bytes from the start of the buffer. The
  62          TCP/IP stack will calculate the checksums, and fill in the necessary
  63          header fields and finally send the packet back to the peer.
  64          */
  65          
  66          /*       浜様様様様様様様様様様様様様様様様様様様様様様様様様様様様融
  67                   ?   TITLE:  Keil C51 v7.00 port of Adam Dunkels' uIP v0.9 
  68                   ?REVISION:  VER 0.0                                       
  69                   ?REV.DATE:  14-01-05                                      
  70                   ? ARCHIVE:                                                
  71                   ?  AUTHOR:  Murray R. Van Luyn, 2005.                     
  72                   藩様様様様様様様様様様様様様様様様様様様様様様様様様様様様夕        */
  73          
  74          #include "uip.h"
  75          #include "uipopt.h"
  76          #include "uip_arch.h"
  77          #include "tcpip.h"
  78          #include "tcpip_uip.h"
  79          
  80          /*-----------------------------------------------------------------------------------*/
  81          /* Variable definitions. */
  82          
  83          
  84          /* The IP address of this host. If it is defined to be fixed (by setting UIP_FIXEDADDR to 1 in uipopt.h), 
             -the address is set here. Otherwise, the address */
  85          #if UIP_FIXEDADDR > 0
              const U16_T code uip_hostaddr[2] =
                      {HTONS((UIP_IPADDR0 << 8) | UIP_IPADDR1),
                       HTONS((UIP_IPADDR2 << 8) | UIP_IPADDR3)};
              const U16_T code uip_arp_draddr[2] =
                      {HTONS((UIP_DRIPADDR0 << 8) | UIP_DRIPADDR1),
                       HTONS((UIP_DRIPADDR2 << 8) | UIP_DRIPADDR3)};
              const U16_T code uip_arp_netmask[2] =
                      {HTONS((UIP_NETMASK0 << 8) | UIP_NETMASK1),
                       HTONS((UIP_NETMASK2 << 8) | UIP_NETMASK3)};
              #else
  96          U16_T idata uip_hostaddr[2];       
  97          U16_T idata uip_arp_draddr[2], uip_arp_netmask[2];
  98          #endif /* UIP_FIXEDADDR */
  99          
 100          U8_T xdata uip_buf[UIP_BUFSIZE+2];  /* The packet buffer that contains incoming packets. */
 101          volatile U8_T *uip_appdata; /* The uip_appdata pointer points to application data. */
 102          volatile U8_T *uip_sappdata;  /* The uip_appdata pointer points to the application data which is to be sen
             -t. */
 103          
 104          #if UIP_URGDATA > 0
 105          volatile U8_T *uip_urgdata;  /* The uip_urgdata pointer points to urgent data (out-of-band data), if prese
             -nt. */
 106          volatile U8_T idata uip_urglen, uip_surglen;
 107          #endif /* UIP_URGDATA > 0 */
 108          
 109          volatile U16_T idata uip_len, uip_slen;  /* The uip_len is either 8 or 16 bits, depending on the maximum p
             -acket size. */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 3   

 110          volatile U8_T idata uip_flags;  /* The uip_flags variable is used for communication between the TCP/IP sta
             -ck and the application program. */
 111          struct uip_conn xdata *uip_conn;  /* uip_conn always points to the current connection. */
 112          struct uip_conn xdata uip_conns[UIP_CONNS];  /* The uip_conns array holds all TCP connections. */
 113          U16_T idata uip_listenports[UIP_LISTENPORTS];  /* The uip_listenports list all currently listning ports. *
             -/
 114          
 115          U8_T xdata uip_extraflag;
 116          U8_T xdata dummy[16] _at_ 0x0000;
 117          
 118          #if UIP_UDP
 119          struct uip_udp_conn xdata *uip_udp_conn;
 120          struct uip_udp_conn xdata uip_udp_conns[UIP_UDP_CONNS];
 121          U16_T idata uip_udp_listenports[UIP_UDP_LISTENPORTS];
 122          #endif /* UIP_UDP */
 123          
 124          static U16_T idata ipid;  /* Ths ipid variable is an increasing number that is used for the IP ID field. *
             -/
 125          
 126          static U8_T idata iss[4];  /* The iss variable is used for the TCP initial sequence number. */
 127          
 128          #if UIP_ACTIVE_OPEN
 129          static U16_T idata lastport;  /* Keeps track of the last port used for a new connection. */
 130          #endif /* UIP_ACTIVE_OPEN */
 131          
 132          /* Temporary variables. */
 133          volatile U8_T uip_acc32[4];
 134          static U8_T idata c, opt;
 135          static U16_T idata tmp16;
 136          
 137          /* Structures and definitions. */
 138          #define TCP_FIN 0x01
 139          #define TCP_SYN 0x02
 140          #define TCP_RST 0x04
 141          #define TCP_PSH 0x08
 142          #define TCP_ACK 0x10
 143          #define TCP_URG 0x20
 144          #define TCP_CTL 0x3f
 145          
 146          #define ICMP_ECHO_REPLY 0
 147          #define ICMP_ECHO       8     
 148          
 149          /* Macros. */
 150          #define GEN_BUF ((uip_tcpip_hdr *)&uip_buf[0])
 151          #define FBUF ((uip_tcpip_hdr *)&uip_reassbuf[0])
 152          #define GEN_ICMPBUF ((uip_icmpip_hdr *)&uip_buf[0])
 153          #define GEN_UDPBUF ((uip_udpip_hdr *)&uip_buf[0])
 154          
 155          /* Transparent mode */
 156          #define GEN_BUF_TRANSP ((uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
 157          #define GEN_ICMPBUF_TRANSP ((uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
 158          #define GEN_UDPBUF_TRANSP ((uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
 159          
 160          /* use for PPPoE */
 161          #define PPPOE_BUF ((uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN + 8])
 162          #define PPPOE_ICMPBUF ((uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN + 8])
 163          #define PPPOE_UDPBUF ((uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN + 8])
 164          
 165          static uip_tcpip_hdr* BUF = GEN_BUF;
 166          static uip_udpip_hdr* UDPBUF = GEN_UDPBUF;
 167          static uip_icmpip_hdr* ICMPBUF = GEN_ICMPBUF;
 168          
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 4   

 169          #if UIP_STATISTICS == 1
              struct uip_stats uip_stat;
              #define UIP_STAT(s) s
              #else
 173          #define UIP_STAT(s)
 174          #endif /* UIP_STATISTICS == 1 */
 175          
 176          #if UIP_LOGGING == 1
              #include <stdio.h>
              void uip_log(char *msg);
              #define UIP_LOG(m) uip_log(m)
              #else
 181          #define UIP_LOG(m)
 182          #endif /* UIP_LOGGING == 1 */
 183          
 184          /*-----------------------------------------------------------------------------------*/
 185          
 186          void uip_init(void)
 187          {
 188   1              for(c = 0; c < UIP_LISTENPORTS; ++c) {
 189   2                      uip_listenports[c] = 0;
 190   2              }
 191   1              for(c = 0; c < UIP_CONNS; ++c) {
 192   2                      uip_conns[c].tcpstateflags = CLOSED;
 193   2              }
 194   1      #if UIP_ACTIVE_OPEN
 195   1              lastport = 1024;
 196   1      #endif /* UIP_ACTIVE_OPEN */
 197   1      
 198   1      #if UIP_UDP
 199   1              for(c = 0; c < UIP_UDP_LISTENPORTS; ++c) {
 200   2                      uip_udp_listenports[c] = 0;
 201   2              }
 202   1              for(c = 0; c < UIP_UDP_CONNS; ++c) {
 203   2                      uip_udp_conns[c].lport = 0;
 204   2              }
 205   1      #endif /* UIP_UDP */
 206   1        
 207   1        /* IPv4 initialization. */
 208   1      #if UIP_FIXEDADDR == 0
 209   1              uip_hostaddr[0] = uip_hostaddr[1] = 0;
 210   1      #endif /* UIP_FIXEDADDR */
 211   1      
 212   1      }
 213          
 214          /*-----------------------------------------------------------------------------------*/
 215          
 216          #if UIP_ACTIVE_OPEN
 217          struct uip_conn *uip_connect(U16_T *ripaddr, U16_T rport)
 218          {
 219   1              register struct uip_conn *conn, *cconn;
 220   1        
 221   1              /* Find an unused local port. */
 222   1      again:
 223   1              ++lastport;
 224   1      
 225   1              if(lastport >= 32000) {
 226   2                      lastport = 4096;
 227   2              }
 228   1      
 229   1              /* Check if this port is already in use, and if so try to find another one. */
 230   1              for(c = 0; c < UIP_CONNS; ++c) {
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 5   

 231   2                      conn = &uip_conns[c];
 232   2                      if(conn->tcpstateflags != CLOSED && conn->lport == htons(lastport)) {
 233   3                              goto again;
 234   3                      }
 235   2              }
 236   1      
 237   1              conn = 0;
 238   1              for(c = 0; c < UIP_CONNS; ++c) {
 239   2                      cconn = &uip_conns[c]; 
 240   2                      if(cconn->tcpstateflags == CLOSED) {
 241   3                              conn = cconn;
 242   3                              break;
 243   3                      }
 244   2                      if(cconn->tcpstateflags == TIME_WAIT) {
 245   3                              if(conn == 0 || cconn->timer > uip_conn->timer) {
 246   4                                      conn = cconn;
 247   4                              }
 248   3                      }
 249   2              }
 250   1      
 251   1              if(conn == 0) {
 252   2                      return 0;
 253   2              }
 254   1        
 255   1              conn->tcpstateflags = SYN_SENT;
 256   1      
 257   1              conn->snd_nxt[0] = iss[0];
 258   1              conn->snd_nxt[1] = iss[1];
 259   1              conn->snd_nxt[2] = iss[2];
 260   1              conn->snd_nxt[3] = iss[3];
 261   1      
 262   1              conn->initialmss = conn->mss = TCPIP_MssLen;
 263   1        
 264   1              conn->len = 1;   /* TCP length of the SYN is one. */
 265   1              conn->nrtx = 0;
 266   1              conn->timer = 1; /* Send the SYN next time around. */
 267   1              conn->rto = UIP_RTO;
 268   1              conn->sa = 0;
 269   1              conn->sv = 16;
 270   1              conn->lport = htons(lastport);
 271   1              conn->rport = rport;
 272   1              conn->ripaddr[0] = ripaddr[0];
 273   1              conn->ripaddr[1] = ripaddr[1];
 274   1              conn->keepaliveflag = 0;
 275   1              conn->keepalivetick = 0;
 276   1              conn->tos = 0;
 277   1          conn->sndkeepalive = 0;
 278   1        
 279   1              return conn;
 280   1      }
 281          #endif /* UIP_ACTIVE_OPEN */
 282          
 283          /*-----------------------------------------------------------------------------------*/
 284          #if UIP_ACTIVE_OPEN
 285          #if UIP_UDP
 286          struct uip_udp_conn *uip_udp_new(U16_T *ripaddr, U16_T rport)
 287          {
 288   1              register struct uip_udp_conn *conn;
 289   1        
 290   1              /* Find an unused local port. */
 291   1      again:
 292   1              ++lastport;
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 6   

 293   1      
 294   1              if(lastport >= 32000) {
 295   2                      lastport = 4096;
 296   2              }
 297   1        
 298   1              for(c = 0; c < UIP_UDP_CONNS; ++c) {
 299   2                      if(uip_udp_conns[c].lport == lastport) {
 300   3                              goto again;
 301   3                      }
 302   2              }
 303   1      
 304   1              conn = 0;
 305   1              for(c = 0; c < UIP_UDP_CONNS; ++c) {
 306   2                      if(uip_udp_conns[c].lport == 0) {
 307   3                              conn = &uip_udp_conns[c]; 
 308   3                              break;
 309   3                      }
 310   2              }
 311   1      
 312   1              if(conn == 0) {
 313   2              return 0;
 314   2              }
 315   1        
 316   1              conn->lport = HTONS(lastport);
 317   1              conn->rport = HTONS(rport);
 318   1              conn->ripaddr[0] = ripaddr[0];
 319   1              conn->ripaddr[1] = ripaddr[1];
 320   1              conn->tos = 0;
 321   1        
 322   1              return conn;
 323   1      }
 324          #endif /* UIP_UDP */
 325          
 326          void uip_udp_unlisten(U16_T port)
 327          {
 328   1              for(c = 0; c < UIP_UDP_LISTENPORTS; ++c) {
 329   2                      if(uip_udp_listenports[c] == port) {
 330   3                              uip_udp_listenports[c] = 0;
 331   3                              return;
 332   3                      }
 333   2              }
 334   1      }
 335          
 336          /*-----------------------------------------------------------------------------------*/
 337          
 338          void uip_udp_listen(U16_T port)
 339          {
 340   1              for(c = 0; c < UIP_UDP_LISTENPORTS; ++c) {
 341   2                      if(uip_udp_listenports[c] == 0) {
 342   3                              uip_udp_listenports[c] = port;
 343   3                              return;
 344   3                      }
 345   2              }
 346   1      }
 347          
 348          #endif
 349          /*-----------------------------------------------------------------------------------*/
 350          
 351          void uip_unlisten(U16_T port)
 352          {
 353   1              for(c = 0; c < UIP_LISTENPORTS; ++c) {
 354   2                      if(uip_listenports[c] == port) {
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 7   

 355   3                              uip_listenports[c] = 0;
 356   3                              return;
 357   3                      }
 358   2              }
 359   1      }
 360          
 361          /*-----------------------------------------------------------------------------------*/
 362          
 363          void uip_listen(U16_T port)
 364          {
 365   1              for(c = 0; c < UIP_LISTENPORTS; ++c) {
 366   2                      if(uip_listenports[c] == 0) {
 367   3                              uip_listenports[c] = port;
 368   3                              return;
 369   3                      }
 370   2              }
 371   1      }
 372          
 373          /*-----------------------------------------------------------------------------------*/
 374          
 375          /* XXX: IP fragment reassembly: not well-tested. */
 376          
 377          #if UIP_REASSEMBLY
              #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
              static U8_T uip_reassbuf[UIP_REASS_BUFSIZE];
              static U8_T uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
              static const U8_T code bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
                                                  0x0f, 0x07, 0x03, 0x01};
              static U16_T uip_reasslen;
              static U8_T uip_reassflags;
              #define UIP_REASS_FLAG_LASTFRAG 0x01
              static U8_T uip_reasstmr;
              
              #define IP_HLEN 20
              #define IP_MF   0x20
              
              static U8_T
              uip_reass(void)
              {
                      U16_T offset, len;
                      U16_T i;
              
                      /* If ip_reasstmr is zero, no packet is present in the buffer, so we
                         write the IP header of the fragment into the reassembly
                         buffer. The timer is updated with the maximum age. */
                      if(uip_reasstmr == 0) {
                              memcpy(uip_reassbuf, &BUF->vhl, IP_HLEN);
                              uip_reasstmr = UIP_REASS_MAXAGE;
                              uip_reassflags = 0;
                              /* Clear the bitmap. */
                              memset(uip_reassbitmap, sizeof(uip_reassbitmap), 0);
                      }
              
                      /* Check if the incoming fragment matches the one currently present
                         in the reasembly buffer. If so, we proceed with copying the
                         fragment into the buffer. */
                      if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
                         BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
                         BUF->destipaddr[0] == FBUF->destipaddr[0] &&
                         BUF->destipaddr[1] == FBUF->destipaddr[1] &&
                         BUF->ipid[0] == FBUF->ipid[0] &&
                         BUF->ipid[1] == FBUF->ipid[1])
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 8   

                      {
                              len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
                              offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
              
                              /* If the offset or the offset + fragment length overflows the
                                 reassembly buffer, we discard the entire packet. */
                              if(offset > UIP_REASS_BUFSIZE || offset + len > UIP_REASS_BUFSIZE) {
                                      uip_reasstmr = 0;
                                      goto nullreturn;
                              }
              
                              /* Copy the fragment into the reassembly buffer, at the right offset. */
                              memcpy(&uip_reassbuf[IP_HLEN + offset], (char *)BUF + (int)((BUF->vhl & 0x0f) * 4), len);
                    
                              /* Update the bitmap. */
                              if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
                                      /* If the two endpoints are in the same byte, we only update that byte. */
                                      uip_reassbitmap[offset / (8 * 8)] |= bitmap_bits[(offset / 8 ) & 7] &
                                                                                                               ~bitmap_bits[((offset + len) / 8 ) & 7];
                              } else {
                                      /* If the two endpoints are in different bytes, we update the
                                         bytes in the endpoints and fill the stuff inbetween with 0xff. */
                                      uip_reassbitmap[offset / (8 * 8)] |= bitmap_bits[(offset / 8 ) & 7];
                                      for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
                                              uip_reassbitmap[i] = 0xff;
                                      }      
                                      uip_reassbitmap[(offset + len) / (8 * 8)] |= ~bitmap_bits[((offset + len) / 8 ) & 7];
                              }
              
                              /* If this fragment has the More Fragments flag set to zero, we
                                 know that this is the last fragment, so we can calculate the
                                 size of the entire packet. We also set the
                                 IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
                                 the final fragment. */
              
                              if((BUF->ipoffset[0] & IP_MF) == 0) {
                                      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
                                      uip_reasslen = offset + len;
                              }
              
                              /* Finally, we check if we have a full packet in the buffer. We do
                                 this by checking if we have the last fragment and if all bits
                                 in the bitmap are set. */
                              if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
                                      /* Check all bytes up to and including all but the last byte in the bitmap. */
                                      for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
                                              if(uip_reassbitmap[i] != 0xff) {
                                                      goto nullreturn;
                                              }
                                      }
                                      /* Check the last byte in the bitmap. It should contain just the right amount of bits. */
                                      if(uip_reassbitmap[uip_reasslen / (8 * 8)] != (U8_T)~bitmap_bits[uip_reasslen / 8 & 7]) {
                                              goto nullreturn;
                                      }
              
                                      /* If we have come this far, we have a full packet in the
                                         buffer, so we allocate a pbuf and copy the packet into it. We
                                         also reset the timer. */
                                      uip_reasstmr = 0;
                                      memcpy(BUF, FBUF, uip_reasslen);
              
                                      /* Pretend to be a "normal" (i.e., not fragmented) IP packet from now on. */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 9   

                                      BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
                                      BUF->len[0] = uip_reasslen >> 8;
                                      BUF->len[1] = uip_reasslen & 0xff;
                                      BUF->ipchksum = 0;
                      #if (!CHECKSUM_OFFLOAD)
                                      BUF->ipchksum = ~(uip_ipchksum());
                      #endif
              
                                      return uip_reasslen;
                              }
                      }
              
               nullreturn:
                return 0;
              }
              #endif /* UIP_REASSEMBL */
 495          
 496          /*-----------------------------------------------------------------------------------*/
 497          
 498          static void uip_add_rcv_nxt(U16_T n)
 499          {
 500   1              uip_add32(uip_conn->rcv_nxt, n);
 501   1              uip_conn->rcv_nxt[0] = uip_acc32[0];
 502   1              uip_conn->rcv_nxt[1] = uip_acc32[1];
 503   1              uip_conn->rcv_nxt[2] = uip_acc32[2];
 504   1              uip_conn->rcv_nxt[3] = uip_acc32[3];
 505   1      }
 506          
 507          /*-----------------------------------------------------------------------------------*/
 508          
 509          void uip_process(U8_T flag)
 510          {
 511   1              register struct uip_conn *uip_connr = uip_conn;
 512   1      
 513   1              if (TCPIP_IsPppoe)
 514   1              {
 515   2                      BUF = PPPOE_BUF;
 516   2                      UDPBUF = PPPOE_UDPBUF;
 517   2                      ICMPBUF = PPPOE_ICMPBUF;
 518   2              }
 519   1              else if (TCPIP_EthHeadLen)
 520   1              {
 521   2                      BUF = GEN_BUF_TRANSP;
 522   2                      UDPBUF = GEN_UDPBUF_TRANSP;
 523   2                      ICMPBUF = GEN_ICMPBUF_TRANSP;
 524   2              }
 525   1              else
 526   1              {
 527   2                      BUF = GEN_BUF;
 528   2                      UDPBUF = GEN_UDPBUF;
 529   2                      ICMPBUF = GEN_ICMPBUF;
 530   2              }
 531   1      
 532   1              /* Check if we were invoked because of the perodic timer fireing. */
 533   1              if(flag == UIP_TIMER) {
 534   2      
 535   2                      uip_appdata = &uip_buf[40 + TCPIP_EthHeadLen + TCPIP_PppoeHeaderLen];
 536   2      #if UIP_REASSEMBLY
                              if(uip_reasstmr != 0) {
                                      --uip_reasstmr;
                              }
              #endif /* UIP_REASSEMBLY */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 10  

 541   2      
 542   2                      /* Increase the initial sequence number. */
 543   2                      if(++iss[3] == 0) {
 544   3                              if(++iss[2] == 0) {
 545   4                                      if(++iss[1] == 0) {
 546   5                                              ++iss[0];
 547   5                                      }
 548   4                              }
 549   3                      }    
 550   2                      uip_len = 0;
 551   2                      if(uip_connr->tcpstateflags == TIME_WAIT || uip_connr->tcpstateflags == FIN_WAIT_2) {
 552   3                              ++(uip_connr->timer);
 553   3                              if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 554   4                                      uip_connr->tcpstateflags = CLOSED;
 555   4                                      uip_flags = UIP_ABORT;
 556   4                                      UIP_APPCALL();
 557   4      
 558   4                                      /* We also send a reset packet to the remote host. */
 559   4                                      BUF->flags = TCP_RST | TCP_ACK;
 560   4                                      BUF->tos = 0;
 561   4                                      goto tcp_send_nodata;
 562   4                              }
 563   3                      } else if(uip_connr->tcpstateflags != CLOSED) {
 564   3                              /* If the connection has outstanding data, we increase the connection's timer 
 565   3                                 and see if it has reached the RTO value in which case we retransmit. */
 566   3                              if(uip_outstanding(uip_connr)) {
 567   4                                      if(uip_connr->timer-- == 0) {
 568   5                                              if(uip_connr->nrtx == UIP_MAXRTX || ((uip_connr->tcpstateflags == SYN_SENT ||
 569   5                                                 uip_connr->tcpstateflags == SYN_RCVD) && uip_connr->nrtx == UIP_MAXSYNRTX))
 570   5                                              {
 571   6                                                      uip_connr->tcpstateflags = CLOSED;
 572   6                                                      /* We call UIP_APPCALL() with uip_flags set to UIP_TIMEDOUT to 
 573   6                                                         inform the application that the connection has timed out. */
 574   6                                                      uip_flags = UIP_TIMEDOUT;
 575   6                                                      UIP_APPCALL();
 576   6      
 577   6                                                      /* We also send a reset packet to the remote host. */
 578   6                                                      BUF->flags = TCP_RST | TCP_ACK;
 579   6                                                      BUF->tos = 0;
 580   6                                                      goto tcp_send_nodata;
 581   6                                              }
 582   5                                              /* Exponential backoff. */
 583   5                                              uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4? 4:uip_connr->nrtx);
 584   5                                              ++(uip_connr->nrtx);
 585   5      
 586   5                                              /* Ok, so we need to retransmit. We do this differently depending on which
 587   5                                                 state we are in. In ESTABLISHED, we call upon the application so that it
 588   5                                                 may prepare the data for the retransmit. In SYN_RCVD, we resend the SYNACK
 589   5                                                 that we sent earlier and in LAST_ACK we have to retransmit our FINACK. */
 590   5                                              UIP_STAT(++uip_stat.tcp.rexmit);
 591   5                                              switch(uip_connr->tcpstateflags & TS_MASK) 
 592   5                                              {
 593   6                                                      case SYN_RCVD:
 594   6                                                              /* In the SYN_RCVD state, we should retransmit our SYNACK. */
 595   6                                                              goto tcp_send_synack;
 596   6      
 597   6      #if UIP_ACTIVE_OPEN
 598   6                                                      case SYN_SENT:
 599   6                                                              /* In the SYN_SENT state, we retransmit out SYN. */
 600   6                                                              BUF->flags = 0;
 601   6      
 602   6                                                              goto tcp_send_syn;
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 11  

 603   6      #endif /* UIP_ACTIVE_OPEN */
 604   6      
 605   6                                                      case ESTABLISHED:
 606   6                                                              /* In the ESTABLISHED state, we call upon the application to do 
 607   6                                                                 the actual retransmit after which we jump into the code for 
 608   6                                                                 sending out the packet (the apprexmit label). */
 609   6                                                              uip_len = 0;
 610   6                                                              uip_slen = 0;
 611   6                                                              uip_flags = UIP_REXMIT;
 612   6                                                              UIP_APPCALL();
 613   6                                                              uip_connr = uip_conn;
 614   6                                                              uip_connr->len = uip_slen;
 615   6                                                              goto apprexmit;
 616   6      
 617   6                                                      case FIN_WAIT_1:
 618   6                                                      case CLOSING:
 619   6                                                      case LAST_ACK:
 620   6                                                              /* In all these states we should retransmit a FINACK. */
 621   6                                                              goto tcp_send_finack;
 622   6                                              }
 623   5                                      }
 624   4                              } else if((uip_connr->tcpstateflags & TS_MASK) == ESTABLISHED) {
 625   4                                      if (uip_connr->keepaliveflag)
 626   4                                      {
 627   5                                              if (++uip_connr->keepalivetick == TCPIP_KEEPALIVE_PERIOD)
 628   5                                              {
 629   6                                                      /* if there is no keep-alive reply after 4 keep-alive packets were sent,
 630   6                                                       * it will assume the connection does not exist any more.
 631   6                                                       */
 632   6                                                      if (uip_connr->sndkeepalive < 4)
 633   6                                                      {
 634   7                                                              uip_connr->sndkeepalive++;
 635   7                                                              uip_connr->keepalivetick = 0;
 636   7      
 637   7                                                              BUF->flags = TCP_ACK;
 638   7                                                              uip_len = 41;
 639   7                                                              BUF->tcpoffset = 5 << 4;
 640   7      
 641   7                                                              BUF->seqno[0] = uip_connr->snd_nxt[0];
 642   7                                                              BUF->seqno[1] = uip_connr->snd_nxt[1];
 643   7                                                              BUF->seqno[2] = uip_connr->snd_nxt[2];
 644   7                                                              if ((BUF->seqno[3] = (uip_connr->snd_nxt[3] - 1)) == 0xff)
 645   7                                                                      if ((BUF->seqno[2] = (uip_connr->snd_nxt[2] - 1)) == 0xff)
 646   7                                                                              if ((BUF->seqno[1] = (uip_connr->snd_nxt[1] - 1)) == 0xff)
 647   7                                                                                      BUF->seqno[0] = uip_connr->snd_nxt[0] - 1;
 648   7                                                              BUF->tos = uip_connr->tos;
 649   7                                                              goto tcp_keepalive;
 650   7                                                      }
 651   6                                                      else
 652   6                                                      {
 653   7                                                              uip_connr->keepalivetick = 0;
 654   7                                                              uip_connr->sndkeepalive = 0;
 655   7                                                              uip_flags = UIP_CONN_TIMEDOUT;
 656   7                                                              UIP_APPCALL();
 657   7                                                              goto appsend;
 658   7                                                      }
 659   6                                              }
 660   5                                      }
 661   4                                      else
 662   4                                      {
 663   5                                              if (++uip_connr->keepalivetick == TCPIP_CONN_TIMEOUT)
 664   5                                              {
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 12  

 665   6                                                      uip_connr->keepalivetick = 0;
 666   6                                                      uip_connr->sndkeepalive = 0;
 667   6                                                      uip_flags = UIP_CONN_TIMEDOUT;
 668   6                                                      UIP_APPCALL();
 669   6                                                      goto appsend;
 670   6                                              }
 671   5                                      }
 672   4                                      /* If there was no need for a retransmission, we poll the application for new data. */
 673   4      //                              uip_len = 0;
 674   4      //                              uip_slen = 0;
 675   4      //                              uip_flags = UIP_POLL;
 676   4      //                              UIP_APPCALL();
 677   4      //                              goto appsend;
 678   4                              }
 679   3                      }
 680   2                      goto drop;
 681   2              }
 682   1      #if UIP_UDP 
 683   1              if(flag == UIP_UDP_TIMER) {
 684   2                      if(uip_udp_conn->lport != 0) {
 685   3      //                      uip_appdata = &uip_buf[TCPIP_EthHeadLen + 28 + TCPIP_PppoeHeaderLen];
 686   3      //                      uip_len = uip_slen = 0;
 687   3      //                      uip_flags = UIP_POLL;
 688   3      //                      UIP_UDP_APPCALL();
 689   3                              goto udp_send;
 690   3                      } else {
 691   3                              goto drop;
 692   3                      }
 693   2              }
 694   1      #endif
 695   1      #if UIP_ACTIVE_OPEN
 696   1              if (flag == UIP_ACTIVE_SEND)
 697   1              {
 698   2                      switch(uip_connr->tcpstateflags & TS_MASK)
 699   2                      {
 700   3                      case SYN_SENT:
 701   3                              BUF->flags = 0;
 702   3                              goto tcp_send_syn;
 703   3                      default:
 704   3                              if (uip_extraflag & UIP_SEND_REXMIT)
 705   3                              {
 706   4                                      uip_connr->len = uip_slen;
 707   4                                      goto apprexmit;
 708   4                              }
 709   3                              else
 710   3                                      goto appsend;
 711   3                      }
 712   2                      goto drop;
 713   2              }
 714   1      #endif /* UIP_ACTIVE_OPEN */
 715   1      
 716   1              uip_appdata = &uip_buf[40 + TCPIP_EthHeadLen + TCPIP_PppoeHeaderLen];
 717   1              uip_len -= (TCPIP_EthHeadLen + TCPIP_PppoeHeaderLen);
 718   1      
 719   1              /* This is where the input processing starts. */
 720   1              UIP_STAT(++uip_stat.ip.recv);
 721   1      
 722   1              /* Start of IPv4 input header processing code. */
 723   1      
 724   1              /* Check validity of the IP header. */  
 725   1              if(BUF->vhl != 0x45)  { /* IP version and header length. */
 726   2              UIP_STAT(++uip_stat.ip.drop);
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 13  

 727   2              UIP_STAT(++uip_stat.ip.vhlerr);
 728   2                  UIP_LOG("ip: invalid version or header length.");
 729   2                      goto drop;
 730   2              }
 731   1      
 732   1              /* Check the size of the packet. If the size reported to us in uip_len doesn't 
 733   1                 match the size reported in the IP header, there has been a transmission 
 734   1                 error and we drop the packet. */
 735   1      
 736   1              if(BUF->len[0] != (uip_len >> 8)) { /* IP length, high byte. */
 737   2                      uip_len = (uip_len & 0xff) | (BUF->len[0] << 8);
 738   2              }
 739   1      
 740   1              if(BUF->len[1] != (uip_len & 0xff)) { /* IP length, low byte. */
 741   2                      uip_len = (uip_len & 0xff00) | BUF->len[1];
 742   2              }
 743   1      
 744   1              /* Check the fragment flag. */
 745   1              if((BUF->ipoffset[0] & 0x3f) != 0 || BUF->ipoffset[1] != 0) { 
 746   2      #if UIP_REASSEMBLY
                              uip_len = uip_reass();
                              if(uip_len == 0) {
                                      goto drop;
                              }
              #else
 752   2                      UIP_STAT(++uip_stat.ip.drop);
 753   2                      UIP_STAT(++uip_stat.ip.fragerr);
 754   2                      UIP_LOG("ip: fragment dropped.");    
 755   2                      goto drop;
 756   2      #endif /* UIP_REASSEMBLY */
 757   2              }
 758   1      
 759   1              /* If we are configured to use ping IP address configuration and hasn't been 
 760   1                 assigned an IP address yet, we accept all ICMP packets. */
 761   1      #if UIP_PINGADDRCONF
                      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
                              if(BUF->proto == UIP_PROTO_ICMP) {
                                      UIP_LOG("ip: possible ping config packet received.");
                                      goto icmp_input;
                              } else {
                                      UIP_LOG("ip: packet dropped since no address assigned.");
                                      goto drop;
                              }
                      }
              #endif /* UIP_PINGADDRCONF */
 772   1      
 773   1              if (TCPIP_EthHeadLen && uip_hostaddr[0] && (BUF->destipaddr[0] < 0xe000))
 774   1              {
 775   2                      /* Check if the packet is destined for our IP address. */  
 776   2                      if(BUF->destipaddr[0] != uip_hostaddr[0]) {
 777   3                              UIP_STAT(++uip_stat.ip.drop);
 778   3                              UIP_LOG("ip: packet not for us.");
 779   3                              goto drop;
 780   3                      }
 781   2                      if(BUF->destipaddr[1] != uip_hostaddr[1]) {
 782   3                              if (((BUF->destipaddr[1] & 0xff) != 0xff) ||
 783   3                                      ((BUF->destipaddr[1] & 0xff00) != (uip_hostaddr[1] & 0xff00)))
 784   3                              {
 785   4                                      UIP_STAT(++uip_stat.ip.drop);
 786   4                                      UIP_LOG("ip: packet not for us.");
 787   4                                      goto drop;
 788   4                              }
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 14  

 789   3                      }
 790   2              }
 791   1      #if (!CHECKSUM_OFFLOAD)
                      if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header checksum. */
                              UIP_STAT(++uip_stat.ip.drop);
                              UIP_STAT(++uip_stat.ip.chkerr);
                              UIP_LOG("ip: bad checksum.");    
                              goto drop;
                      }
              #endif
 799   1              if(BUF->proto == UIP_PROTO_TCP)  /* Check for TCP packet. If so, jump to the tcp_input label. */
 800   1                      goto tcp_input;
 801   1      
 802   1      #if UIP_UDP
 803   1              if(BUF->proto == UIP_PROTO_UDP)
 804   1                      goto udp_input;
 805   1      #endif /* UIP_UDP */
 806   1      
 807   1              if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from here. */
 808   2                      UIP_STAT(++uip_stat.ip.drop);
 809   2                      UIP_STAT(++uip_stat.ip.protoerr);
 810   2                      UIP_LOG("ip: neither tcp nor icmp.");        
 811   2                      goto drop;
 812   2              }
 813   1        
 814   1      /*icmp_input:*/
 815   1              
 816   1              UIP_STAT(++uip_stat.icmp.recv);
 817   1        
 818   1              /* ICMP echo (i.e., ping) processing. This is simple, we only change the ICMP type 
 819   1                 from ECHO to ECHO_REPLY and adjust the ICMP checksum before we return the packet. */
 820   1              if(ICMPBUF->type != ICMP_ECHO)
 821   1              {
 822   2                      if ((ICMPBUF->type == ICMP_ECHO_REPLY) && TCPIP_PingRespCallBack)
 823   2                              TCPIP_PingRespCallBack();
 824   2      
 825   2                      goto drop;
 826   2              }
 827   1              else
 828   1              {
 829   2                      /* If we are configured to use ping IP address assignment, we use the destination 
 830   2                         IP address of this ping packet and assign it to ourself. */
 831   2      #if UIP_PINGADDRCONF
                              if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
                                      uip_hostaddr[0] = BUF->destipaddr[0];
                                      uip_hostaddr[1] = BUF->destipaddr[1];
                              }
              #endif /* UIP_PINGADDRCONF */  
 837   2        
 838   2                      ICMPBUF->type = ICMP_ECHO_REPLY;
 839   2      
 840   2      #if (!CHECKSUM_OFFLOAD)  
                              if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
                                      ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
                              } else {
                                      ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
                              }
              #endif
 847   2        
 848   2                      /* Swap IP addresses. */
 849   2                      tmp16 = BUF->destipaddr[0];
 850   2                      BUF->destipaddr[0] = BUF->srcipaddr[0];
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 15  

 851   2                      BUF->srcipaddr[0] = tmp16;
 852   2                      tmp16 = BUF->destipaddr[1];
 853   2                      BUF->destipaddr[1] = BUF->srcipaddr[1];
 854   2                      BUF->srcipaddr[1] = tmp16;
 855   2              }
 856   1      
 857   1              UIP_STAT(++uip_stat.icmp.sent);
 858   1              goto send;
 859   1      
 860   1        /* End of IPv4 input header processing code. */
 861   1      
 862   1      #if UIP_UDP
 863   1              /* UDP input processing. */
 864   1      udp_input:
 865   1              /* UDP processing is really just a hack. We don't do anything to the UDP/IP headers, 
 866   1                 but let the UDP application do all the hard work. If the application sets uip_slen, 
 867   1                 it has a packet to send. */
 868   1      #if (!CHECKSUM_OFFLOAD)
              #if UIP_UDP_CHECKSUMS
                      if(uip_udpchksum() != 0xffff) { 
                              UIP_STAT(++uip_stat.udp.drop);
                              UIP_STAT(++uip_stat.udp.chkerr);
                              UIP_LOG("udp: bad checksum.");    
                              goto drop;
                      }  
              #endif /* UIP_UDP_CHECKSUMS */
              #endif /* !CHECKSUM_OFFLOAD */
 878   1      
 879   1              uip_flags = 0;
 880   1      
 881   1              /* Demultiplex this UDP packet between the UDP "connections". */
 882   1              for(uip_udp_conn = &uip_udp_conns[0]; uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS]; ++uip_udp_conn)
 883   1              {
 884   2                      if(uip_udp_conn->lport != 0 && UDPBUF->destport == uip_udp_conn->lport &&
 885   2                         ((uip_udp_conn->rport == 0) || (UDPBUF->srcport == uip_udp_conn->rport)) &&
 886   2                         (((uip_udp_conn->ripaddr[0] == 0) && (uip_udp_conn->ripaddr[1] == 0)) ||
 887   2                         ((uip_udp_conn->ripaddr[0] == 0xffff) &&(uip_udp_conn->ripaddr[1] == 0xffff)) ||
 888   2                         ((BUF->srcipaddr[0] == uip_udp_conn->ripaddr[0]) &&
 889   2                         (BUF->srcipaddr[1] == uip_udp_conn->ripaddr[1])))) 
 890   2                      {
 891   3                              if (uip_udp_conn->rport == 0)
 892   3                                      uip_udp_conn->rport = UDPBUF->srcport;
 893   3                              else if ((uip_udp_conn->ripaddr[0] == 0) &&(uip_udp_conn->ripaddr[1] == 0))
 894   3                              {
 895   4                                      uip_udp_conn->ripaddr[0] = BUF->srcipaddr[0];
 896   4                                      uip_udp_conn->ripaddr[1] = BUF->srcipaddr[1];
 897   4                              }
 898   3                              goto udp_found; 
 899   3                      }
 900   2              }
 901   1      
 902   1              /* find listen port */
 903   1              for(c = 0; c < UIP_UDP_LISTENPORTS; ++c)
 904   1              {
 905   2                      if(UDPBUF->destport == uip_udp_listenports[c])
 906   2                              goto found_udp_listen;
 907   2              }
 908   1      
 909   1              goto drop;
 910   1      found_udp_listen:
 911   1              for(c = 0; c < UIP_UDP_CONNS; c++)
 912   1              {
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 16  

 913   2                      if (uip_udp_conns[c].lport == 0)
 914   2                      {
 915   3                              uip_udp_conns[c].lport = UDPBUF->destport;
 916   3                              uip_udp_conns[c].rport = UDPBUF->srcport;
 917   3                              uip_udp_conns[c].ripaddr[0] = BUF->srcipaddr[0];
 918   3                              uip_udp_conns[c].ripaddr[1] = BUF->srcipaddr[1];
 919   3                              uip_udp_conns[c].tcpip_id = UIP_UDP_CONNS;
 920   3                              uip_udp_conns[c].tos = 0;
 921   3                              uip_udp_conn = &uip_udp_conns[c];
 922   3                              uip_flags |= UIP_CONNECTED;
 923   3                              break;
 924   3                      }
 925   2              }
 926   1              if (c == UIP_UDP_CONNS)
 927   1                      goto drop;
 928   1      
 929   1      udp_found:
 930   1              uip_len = uip_len - 28;
 931   1              uip_appdata = &uip_buf[TCPIP_EthHeadLen + 28 + TCPIP_PppoeHeaderLen];
 932   1              uip_flags |= UIP_NEWDATA;
 933   1              uip_slen = 0;
 934   1              UIP_UDP_APPCALL();
 935   1      
 936   1      udp_send:
 937   1      
 938   1              if(uip_slen == 0) {
 939   2                      goto drop;      
 940   2              }
 941   1              uip_len = uip_slen + 28;
 942   1      
 943   1              BUF->len[0] = (uip_len >> 8);
 944   1              BUF->len[1] = (uip_len & 0xff);
 945   1        
 946   1              BUF->proto = UIP_PROTO_UDP;
 947   1      
 948   1              UDPBUF->udplen = HTONS(uip_slen + 8);
 949   1              UDPBUF->udpchksum = 0;
 950   1      #if (!CHECKSUM_OFFLOAD)
              #if UIP_UDP_CHECKSUMS 
                      /* Calculate UDP checksum. */
                      UDPBUF->udpchksum = ~(uip_udpchksum());
                      if(UDPBUF->udpchksum == 0) {
                              UDPBUF->udpchksum = 0xffff;
                      }
              #endif /* UIP_UDP_CHECKSUMS */
              #endif /* !CHECKSUM_OFFLOAD */
 959   1      
 960   1              BUF->srcport  = uip_udp_conn->lport;
 961   1              BUF->destport = uip_udp_conn->rport;
 962   1      
 963   1              BUF->srcipaddr[0] = uip_hostaddr[0];
 964   1              BUF->srcipaddr[1] = uip_hostaddr[1];
 965   1              BUF->destipaddr[0] = uip_udp_conn->ripaddr[0];
 966   1              BUF->destipaddr[1] = uip_udp_conn->ripaddr[1];
 967   1              BUF->tos = uip_udp_conn->tos;
 968   1       
 969   1              goto ip_send_nolen;
 970   1      #endif /* UIP_UDP */
 971   1        
 972   1              /* TCP input processing. */  
 973   1      tcp_input:
 974   1      
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 17  

 975   1              UIP_STAT(++uip_stat.tcp.recv);
 976   1      
 977   1              /* Start of TCP input header processing code. */
 978   1      #if (!CHECKSUM_OFFLOAD)  
                      if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP checksum. */
                              UIP_STAT(++uip_stat.tcp.drop);
                              UIP_STAT(++uip_stat.tcp.chkerr);
                              UIP_LOG("tcp: bad checksum.");    
                              goto drop;
                      }
              #endif
 986   1        
 987   1              /* Demultiplex this segment. */
 988   1              /* First check any active connections. */
 989   1              for(uip_connr = &uip_conns[0]; uip_connr < &uip_conns[UIP_CONNS]; ++uip_connr) {
 990   2                      if(uip_connr->tcpstateflags != CLOSED &&
 991   2                         BUF->destport == uip_connr->lport &&
 992   2                         BUF->srcport == uip_connr->rport &&
 993   2                         BUF->srcipaddr[0] == uip_connr->ripaddr[0] &&
 994   2                         BUF->srcipaddr[1] == uip_connr->ripaddr[1]) 
 995   2                      {
 996   3                              if ((uip_connr->tcpstateflags == TIME_WAIT) && ((BUF->flags & TCP_CTL) == TCP_SYN))
 997   3                                      goto tcp_waitport_send_synack;
 998   3                              else
 999   3                                      goto found;
1000   3                      }
1001   2              }
1002   1      
1003   1              /* If we didn't find and active connection that expected the packet, either this packet
1004   1                 is an old duplicate, or this is a SYN packet destined for a connection in LISTEN. If
1005   1                 the SYN flag isn't set, it is an old packet and we send a RST. */
1006   1              if((BUF->flags & TCP_CTL) != TCP_SYN)
1007   1                      goto reset;
1008   1        
1009   1              tmp16 = BUF->destport;
1010   1              /* Next, check listening connections. */  
1011   1              for(c = 0; c < UIP_LISTENPORTS; ++c) {
1012   2                      if(tmp16 == uip_listenports[c])
1013   2                              goto found_listen;
1014   2              }
1015   1        
1016   1              /* No matching connection found, so we send a RST packet. */
1017   1              UIP_STAT(++uip_stat.tcp.synrst);
1018   1      
1019   1      reset:
1020   1      
1021   1              /* We do not send resets in response to resets. */
1022   1              if(BUF->flags & TCP_RST) 
1023   1                      goto drop;
1024   1      
1025   1              UIP_STAT(++uip_stat.tcp.rst);
1026   1        
1027   1              BUF->flags = TCP_RST | TCP_ACK;
1028   1              uip_len = 40;
1029   1              BUF->tcpoffset = 5 << 4;
1030   1      
1031   1              /* Flip the seqno and ackno fields in the TCP header. */
1032   1              c = BUF->seqno[3];
1033   1              BUF->seqno[3] = BUF->ackno[3];  
1034   1              BUF->ackno[3] = c;
1035   1        
1036   1              c = BUF->seqno[2];
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 18  

1037   1              BUF->seqno[2] = BUF->ackno[2];  
1038   1              BUF->ackno[2] = c;
1039   1        
1040   1              c = BUF->seqno[1];
1041   1              BUF->seqno[1] = BUF->ackno[1];
1042   1              BUF->ackno[1] = c;
1043   1        
1044   1      
1045   1              c = BUF->seqno[0];
1046   1              BUF->seqno[0] = BUF->ackno[0];  
1047   1              BUF->ackno[0] = c;
1048   1      
1049   1              /* We also have to increase the sequence number we are acknowledging. If the least 
1050   1                 significant byte overflowed, we need to propagate the carry to the other bytes as well. */
1051   1              if(++BUF->ackno[3] == 0) {
1052   2                      if(++BUF->ackno[2] == 0) {
1053   3                              if(++BUF->ackno[1] == 0) {
1054   4                                      ++BUF->ackno[0];
1055   4                              }
1056   3                      }
1057   2              }
1058   1       
1059   1              /* Swap port numbers. */
1060   1              tmp16 = BUF->srcport;
1061   1              BUF->srcport = BUF->destport;
1062   1              BUF->destport = tmp16;
1063   1        
1064   1              /* Swap IP addresses. */
1065   1              tmp16 = BUF->destipaddr[0];
1066   1              BUF->destipaddr[0] = BUF->srcipaddr[0];
1067   1              BUF->srcipaddr[0] = tmp16;
1068   1              tmp16 = BUF->destipaddr[1];
1069   1              BUF->destipaddr[1] = BUF->srcipaddr[1];
1070   1              BUF->srcipaddr[1] = tmp16;
1071   1              BUF->tos = 0;
1072   1        
1073   1              /* And send out the RST packet! */
1074   1              goto tcp_send_noconn;
1075   1      
1076   1              /* This label will be jumped to if we matched the incoming packet with a connection 
1077   1                 in LISTEN. In that case, we should create a new connection and send a SYNACK in return. */
1078   1      found_listen:
1079   1      
1080   1              /* First we check if there are any connections avaliable. Unused connections are kept in
1081   1                 the same table as used connections, but unused ones have the tcpstate set to CLOSED. 
1082   1                 Also, connections in TIME_WAIT are kept track of and we'll use the oldest one if no
1083   1                 CLOSED connections are found. Thanks to Eddie C. Dost for a very nice algorithm for 
1084   1                 the TIME_WAIT search. */
1085   1              uip_connr = -1;    // 8051 xdata starts at 0x0000
*** WARNING C196 IN LINE 1085 OF ..\SRC\MTCPIP\UIP.C: mspace probably invalid
1086   1              for(c = 0; c < UIP_CONNS; ++c) {
1087   2                      if(uip_conns[c].tcpstateflags == CLOSED) {
1088   3                              uip_connr = &uip_conns[c];
1089   3                              break;
1090   3                      }
1091   2                      if(uip_conns[c].tcpstateflags == TIME_WAIT) {
1092   3                              if(uip_connr == 0 || uip_conns[c].timer > uip_connr->timer) {
1093   4                                      uip_connr = &uip_conns[c];
1094   4                              }
1095   3                      }
1096   2              }
1097   1      
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 19  

1098   1              if(uip_connr == -1) {  // 8051 xdata starts at 0x0000
1099   2                      /* All connections are used already, we drop packet and hope that the remote end will 
1100   2                         retransmit the packet at a time when we have more spare connections. */
1101   2                      UIP_STAT(++uip_stat.tcp.syndrop);
1102   2                      UIP_LOG("tcp: found no unused connections.");
1103   2                      goto drop;
1104   2              }
1105   1              uip_connr->tcpip_id = UIP_CONNS;
1106   1      
1107   1      tcp_waitport_send_synack:
1108   1      
1109   1              uip_conn = uip_connr;
1110   1        
1111   1              /* Fill in the necessary fields for the new connection. */
1112   1              uip_connr->rto = uip_connr->timer = UIP_RTO;
1113   1              uip_connr->sa = 0;
1114   1              uip_connr->sv = 4;  
1115   1              uip_connr->nrtx = 0;
1116   1              uip_connr->lport = BUF->destport;
1117   1              uip_connr->rport = BUF->srcport;
1118   1              uip_connr->ripaddr[0] = BUF->srcipaddr[0];
1119   1              uip_connr->ripaddr[1] = BUF->srcipaddr[1];
1120   1              uip_connr->tcpstateflags = SYN_RCVD;
1121   1              uip_connr->keepaliveflag = 0;
1122   1              uip_connr->keepalivetick = 0;
1123   1          uip_connr->sndkeepalive = 0;
1124   1      
1125   1              uip_connr->snd_nxt[0] = iss[0];
1126   1              uip_connr->snd_nxt[1] = iss[1];
1127   1              uip_connr->snd_nxt[2] = iss[2];
1128   1              uip_connr->snd_nxt[3] = iss[3];
1129   1              uip_connr->len = 1;
1130   1      
1131   1              /* rcv_nxt should be the seqno from the incoming packet + 1. */
1132   1              uip_connr->rcv_nxt[3] = BUF->seqno[3];
1133   1              uip_connr->rcv_nxt[2] = BUF->seqno[2];
1134   1              uip_connr->rcv_nxt[1] = BUF->seqno[1];
1135   1              uip_connr->rcv_nxt[0] = BUF->seqno[0];
1136   1              uip_add_rcv_nxt(1);
1137   1      
1138   1              uip_connr->window[0] = BUF->wnd[0];
1139   1              uip_connr->window[1] = BUF->wnd[1];
1140   1              uip_connr->tos = 0;
1141   1      
1142   1              /* Parse the TCP MSS option, if present. */
1143   1              if((BUF->tcpoffset & 0xf0) > 0x50) {
1144   2                      for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1145   3                              opt = uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + c + TCPIP_PppoeHeaderLen];
1146   3                              if(opt == 0x00) {
1147   4                                      /* End of options. */   
1148   4                                      break;
1149   4                              } else if(opt == 0x01) {
1150   4                                      ++c;
1151   4                                      /* NOP option. */
1152   4                              } else if(opt == 0x02 && uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen] == 0
             -x04) {
1153   4                                      /* An MSS option with the right option length. */       
1154   4                                      tmp16 = ((U16_T)uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 2 + c + TCPIP_PppoeHeaderLen] << 8) |
1155   4                                                      (U16_T)uip_buf[40 + TCPIP_EthHeadLen + 3 + c + TCPIP_PppoeHeaderLen];
1156   4                                      uip_connr->initialmss = uip_connr->mss = tmp16 > TCPIP_MssLen? TCPIP_MssLen: tmp16;
1157   4              
1158   4                                      /* And we are done processing options. */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 20  

1159   4                                      break;
1160   4                              } else {
1161   4                                      /* All other options have a length field, so that we easily can skip past them. */
1162   4                                      if(uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen] == 0) {
1163   5                                              /* If the length field is zero, the options are malformed and we don't process them further. */
1164   5                                              break;
1165   5                                      }
1166   4                                      c += uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen];
1167   4                              }
1168   3                      }
1169   2              }
1170   1        
1171   1              /* Our response will be a SYNACK. */
1172   1      #if UIP_ACTIVE_OPEN
1173   1      tcp_send_synack:
1174   1      
1175   1              BUF->flags = TCP_ACK;    
1176   1        
1177   1      tcp_send_syn:
1178   1      
1179   1              BUF->flags |= TCP_SYN;    
1180   1      #else /* UIP_ACTIVE_OPEN */
              tcp_send_synack:
              
                      BUF->flags = TCP_SYN | TCP_ACK;    
              #endif /* UIP_ACTIVE_OPEN */
1185   1        
1186   1              /* We send out the TCP Maximum Segment Size option with our SYNACK. */
1187   1              BUF->optdata[0] = 2;
1188   1              BUF->optdata[1] = 4;
1189   1              BUF->optdata[2] = (TCPIP_MssLen) / 256;
1190   1              BUF->optdata[3] = (TCPIP_MssLen) & 255;
1191   1              uip_len = 44;
1192   1              BUF->tcpoffset = 6 << 4;
1193   1              BUF->tos = uip_connr->tos;
1194   1              goto tcp_send;
1195   1      
1196   1              /* This label will be jumped to if we found an active connection. */
1197   1      found:
1198   1      
1199   1              uip_conn = uip_connr;
1200   1              uip_flags = 0;
1201   1              uip_extraflag = 0;
1202   1      
1203   1              /* We do a very naive form of TCP reset processing; we just accept any RST and kill
1204   1                 our connection. We should in fact check if the sequence number of this reset is 
1205   1                 wihtin our advertised window before we accept the reset. */
1206   1              if(BUF->flags & TCP_RST) {
1207   2                      uip_connr->tcpstateflags = CLOSED;
1208   2                      UIP_LOG("tcp: got reset, aborting connection.");
1209   2                      uip_flags = UIP_ABORT;
1210   2                      UIP_APPCALL();
1211   2                      goto drop;
1212   2              }
1213   1              /* Calculated the length of the data, if the application has sent any data to us. */
1214   1              c = (BUF->tcpoffset >> 4) << 2;
1215   1              /* uip_len will contain the length of the actual TCP data. This is calculated by subtracing
1216   1                 the length of the TCP header (in c) and the length of the IP header (20 bytes). */
1217   1              uip_len = uip_len - c - 20;
1218   1      
1219   1              /* First, check if the sequence number of the incoming packet is what we're expecting next. 
1220   1                 If not, we send out an ACK with the correct numbers in. */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 21  

1221   1      //      if(uip_len > 0 &&
1222   1              if (((uip_len > 0) || (BUF->flags & TCP_FIN)) &&        /* modified at 2008/01/07 */
1223   1                 (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
1224   1                      BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
1225   1                      BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
1226   1                      BUF->seqno[3] != uip_connr->rcv_nxt[3]))
1227   1              {
1228   2                      BUF->tos = uip_connr->tos;
1229   2                      goto tcp_send_ack;
1230   2              }
1231   1      
1232   1              /* Next, check if the incoming segment acknowledges any outstanding data. If so, we update 
1233   1                 the sequence number, reset the length of the outstanding data, calculate RTT estimations,
1234   1                 and reset the retransmission timer. */
1235   1               if((BUF->flags & TCP_ACK) && (uip_outstanding(uip_connr) || uip_connr->waitAck)) {
1236   2              U8_T rttUpdate=0;
1237   2      
1238   2                      uip_add32(uip_connr->snd_nxt, uip_connr->len);
1239   2                      if(BUF->ackno[0] == uip_acc32[0] && BUF->ackno[1] == uip_acc32[1] &&
1240   2                         BUF->ackno[2] == uip_acc32[2] && BUF->ackno[3] == uip_acc32[3])
1241   2                      {
1242   3                              /* Update sequence number. */
1243   3                              uip_connr->snd_nxt[0] = uip_acc32[0];
1244   3                              uip_connr->snd_nxt[1] = uip_acc32[1];
1245   3                              uip_connr->snd_nxt[2] = uip_acc32[2];
1246   3                              uip_connr->snd_nxt[3] = uip_acc32[3];
1247   3                  rttUpdate=1;
1248   3                              uip_connr->count = 0;
1249   3                      }
1250   2                      else
1251   2                      {
1252   3                              U8_T*   point1 = uip_connr->seq1;
1253   3      
1254   3                              if ((uip_connr->count >= 2) && (BUF->ackno[0] == point1[0]) &&
1255   3                                      (BUF->ackno[1] == point1[1]) && (BUF->ackno[2] == point1[2]) &&
1256   3                                      (BUF->ackno[3] == point1[3]))
1257   3                              {
1258   4                                      uip_extraflag |= UIP_RCV_PRE2_ACK;
1259   4                                      rttUpdate=1;
1260   4                                      uip_connr->count = 2;
1261   4                              }
1262   3                              else if ((uip_connr->count >= 1)&&(BUF->ackno[0] == uip_connr->snd_nxt[0]) &&
1263   3                                      (BUF->ackno[1] == uip_connr->snd_nxt[1]) &&
1264   3                                      (BUF->ackno[2] == uip_connr->snd_nxt[2]) &&
1265   3                                      (BUF->ackno[3] == uip_connr->snd_nxt[3]))
1266   3                              {
1267   4                                      uip_extraflag |= UIP_RCV_PRE1_ACK;
1268   4                                      rttUpdate=1;
1269   4                                      uip_connr->count = 1;
1270   4                              }
1271   3                              else
1272   3                              {
1273   4                                      U8_T*   point1 = uip_connr->seq2;
1274   4      
1275   4                                      if ((uip_connr->count >= 3) && (BUF->ackno[0] == point1[0]) &&
1276   4                                              (BUF->ackno[1] == point1[1]) && (BUF->ackno[2] == point1[2]) &&
1277   4                                              (BUF->ackno[3] == point1[3]))
1278   4                                      {
1279   5                                              uip_extraflag |= UIP_RCV_PRE3_ACK;
1280   5                                              rttUpdate=1;
1281   5                                              uip_connr->count = 3;
1282   5                                      }
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 22  

1283   4                              }
1284   3                      }
1285   2      
1286   2              if (rttUpdate)
1287   2              {
1288   3                              /* Do RTT estimation, unless we have done retransmissions. */
1289   3                              if(uip_connr->nrtx == 0) {
1290   4                                      signed char m;
1291   4                                      m = uip_connr->rto - uip_connr->timer;
1292   4                                      /* This is taken directly from VJs original code in his paper */
1293   4                                      m = m - (uip_connr->sa >> 3);
1294   4                                      uip_connr->sa += m;
1295   4                                      if(m < 0) {
1296   5                                              m = -m;
1297   5                                      }
1298   4                                      m = m - (uip_connr->sv >> 2);
1299   4                                      uip_connr->sv += m;
1300   4                                      uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
1301   4                              }
1302   3                              /* Set the acknowledged flag. */
1303   3                              uip_flags = UIP_ACKDATA;
1304   3                              /* Reset the retransmission timer. */
1305   3                              uip_connr->timer = uip_connr->rto;
1306   3      
1307   3                              /* Had received packet so reset keepalive tick to 0. */
1308   3                              uip_connr->keepalivetick = 0;
1309   3                              uip_connr->sndkeepalive = 0;
1310   3              }
1311   2              }
1312   1      
1313   1              if ((BUF->wnd[0] < 0x40) && (uip_connr->window[0] > 0x80)) /* small than 16k bytes */
1314   1                      uip_extraflag |= UIP_RCV_WINDOW;
1315   1      
1316   1              /* Do different things depending on in what state the connection is. */
1317   1              switch(uip_connr->tcpstateflags & TS_MASK)
1318   1              {
1319   2                      /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not implemented, 
1320   2                         since we force the application to close when the peer sends a FIN (hence 
1321   2                         the application goes directly from ESTABLISHED to LAST_ACK). */
1322   2                      case SYN_RCVD:
1323   2                              /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and we are waiting 
1324   2                                 for an ACK that acknowledges the data we sent out the last time. Therefore, we
1325   2                                 want to have the UIP_ACKDATAflag set. If so, we enter the ESTABLISHED state. */
1326   2                              if(uip_flags & UIP_ACKDATA) {
1327   3                                      uip_connr->tcpstateflags = ESTABLISHED;
1328   3                                      uip_flags = UIP_CONNECTED;
1329   3                                      uip_connr->len = 0;
1330   3                                      if(uip_len > 0) {
1331   4                                              uip_flags |= UIP_NEWDATA;
1332   4                                              uip_add_rcv_nxt(uip_len);
1333   4                                      }
1334   3                                      uip_slen = 0;
1335   3                                      UIP_APPCALL();
1336   3                                      goto appsend;
1337   3                              }
1338   2                              goto drop;
1339   2      
1340   2      #if UIP_ACTIVE_OPEN
1341   2                      case SYN_SENT:
1342   2                              /* In SYN_SENT, we wait for a SYNACK that is sent in response to our SYN.
1343   2                                 The rcv_nxt is set to sequence number in the SYNACK plus one, and we 
1344   2                                 send an ACK. We move into the ESTABLISHED state. */
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 23  

1345   2                              if((uip_flags & UIP_ACKDATA) && BUF->flags == (TCP_SYN | TCP_ACK)) {
1346   3                                      /* Parse the TCP MSS option, if present. */
1347   3                                      if((BUF->tcpoffset & 0xf0) > 0x50) {
1348   4                                              for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1349   5                                                      opt = uip_buf[40 + TCPIP_EthHeadLen + c + TCPIP_PppoeHeaderLen];
1350   5                                                      if(opt == 0x00) {
1351   6                                                      /* End of options. */   
1352   6                                                              break;
1353   6                                                      } else if(opt == 0x01) {
1354   6                                                              ++c;
1355   6                                                              /* NOP option. */
1356   6                                                      } else if(opt == 0x02 && uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen] =
             -= 0x04) {
1357   6                                                              /* An MSS option with the right option length. */
1358   6                                                              tmp16 = (uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 2 + c + TCPIP_PppoeHeaderLen] << 8) |
1359   6                                                                               uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 3 + c + TCPIP_PppoeHeaderLen];
1360   6                                                              uip_connr->initialmss = uip_connr->mss = tmp16 > TCPIP_MssLen? TCPIP_MssLen: tmp16;
1361   6                                                              /* And we are done processing options. */
1362   6                                                              break;
1363   6                                                      } else {
1364   6                                                              /* All other options have a length field, so that we easily can skip past them. */
1365   6                                                              if(uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen] == 0) {
1366   7                                                              /* If the length field is zero, the options are malformed 
1367   7                                                                 and we don't process them further. */
1368   7                                                                      break;
1369   7                                                              }
1370   6                                                              c += uip_buf[UIP_TCPIP_HLEN + TCPIP_EthHeadLen + 1 + c + TCPIP_PppoeHeaderLen];
1371   6                                                      }
1372   5                                              }
1373   4                                      }
1374   3                                      uip_connr->tcpstateflags = ESTABLISHED;      
1375   3                                      uip_connr->rcv_nxt[0] = BUF->seqno[0];
1376   3                                      uip_connr->rcv_nxt[1] = BUF->seqno[1];
1377   3                                      uip_connr->rcv_nxt[2] = BUF->seqno[2];
1378   3                                      uip_connr->rcv_nxt[3] = BUF->seqno[3];
1379   3                                      uip_add_rcv_nxt(1);
1380   3      
1381   3                                      uip_connr->window[0] = BUF->wnd[0];
1382   3                                      uip_connr->window[1] = BUF->wnd[1];
1383   3      
1384   3                                      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
1385   3                                      uip_connr->len = 0;
1386   3                                      uip_len = 0;
1387   3                                      uip_slen = 0;
1388   3                                      UIP_APPCALL();
1389   3                                      goto appsend;
1390   3                              }
1391   2      
1392   2                              uip_flags = UIP_ABORT;
1393   2                              UIP_APPCALL();
1394   2                              goto reset;
1395   2      #endif /* UIP_ACTIVE_OPEN */
1396   2          
1397   2                      case ESTABLISHED:
1398   2                              /* In the ESTABLISHED state, we call upon the application to feed
1399   2                                 data into the uip_buf. If the UIP_ACKDATA flag is set, the
1400   2                                 application should put new data into the buffer, otherwise we are
1401   2                                 retransmitting an old segment, and the application should put that
1402   2                                 data into the buffer.
1403   2      
1404   2                                 If the incoming packet is a FIN, we should close the connection on
1405   2                                 this side as well, and we send out a FIN and enter the LAST_ACK
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 24  

1406   2                                 state. We require that there is no outstanding data; otherwise the
1407   2                                 sequence numbers will be screwed up. */
1408   2      
1409   2                              if(BUF->flags & TCP_FIN) {
1410   3      //                              if(uip_outstanding(uip_connr)) {
1411   3      //                                      goto drop;
1412   3      //                              }
1413   3                                      uip_add_rcv_nxt(1 + uip_len);      
1414   3                                      uip_flags = UIP_CLOSE;
1415   3                                      if(uip_len > 0) {
1416   4                                              uip_flags |= UIP_NEWDATA;
1417   4                                      }
1418   3                                      UIP_APPCALL();
1419   3                                      uip_connr = uip_conn;
1420   3                                      uip_connr->len = 1;
1421   3                                      uip_connr->tcpstateflags = LAST_ACK;
1422   3                                      uip_connr->nrtx = 0;
1423   3      
1424   3      tcp_send_finack:
1425   3      
1426   3                                      BUF->flags = TCP_FIN | TCP_ACK;
1427   3                                      BUF->tos = 0;
1428   3                                      goto tcp_send_nodata;
1429   3                              }
1430   2      
1431   2                              /* Check the URG flag. If this is set, the segment carries urgent
1432   2                                 data that we must pass to the application. */
1433   2                              if(BUF->flags & TCP_URG) {
1434   3      #if UIP_URGDATA > 0
1435   3                                      uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
1436   3                                      if(uip_urglen > uip_len) {
1437   4                                              /* There is more urgent data in the next segment to come. */
1438   4                                              uip_urglen = uip_len;
1439   4                                      }
1440   3                                      uip_add_rcv_nxt(uip_urglen);
1441   3                                      uip_len -= uip_urglen;
1442   3                                      uip_urgdata = uip_appdata;
1443   3                                      uip_appdata += uip_urglen;
1444   3                              } else {
1445   3                                      uip_urglen = 0;
1446   3      #endif /* UIP_URGDATA > 0 */
1447   3                                      uip_appdata += (BUF->urgp[0] << 8) | BUF->urgp[1];
1448   3                                      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
1449   3                              }
1450   2          
1451   2                              /* If uip_len > 0 we have TCP data in the packet, and we flag this
1452   2                                 by setting the UIP_NEWDATA flag and update the sequence number
1453   2                                 we acknowledge. If the application has stopped the dataflow
1454   2                                 using uip_stop(), we must not accept any data packets from the
1455   2                                 remote host. */
1456   2                              if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1457   3                                      uip_flags |= UIP_NEWDATA;
1458   3                                      uip_add_rcv_nxt(uip_len);
1459   3                              }
1460   2                  /* Check that received tcp keep alive */
1461   2                  else if (uip_len == 0 && (BUF->flags == TCP_ACK) && 
1462   2                           uip_connr->keepaliveflag && uip_connr->sndkeepalive)
1463   2                  {
1464   3                       uip_connr->keepalivetick = 0;
1465   3                       uip_connr->sndkeepalive = 0;
1466   3                  }
1467   2                              /* Check if the available buffer space advertised by the other end
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 25  

1468   2                                 is smaller than the initial MSS for this connection. If so, we
1469   2                                 set the current MSS to the window size to ensure that the
1470   2                                 application does not send more data than the other end can
1471   2                                 handle.
1472   2      
1473   2                                 If the remote host advertises a zero window, we set the MSS to
1474   2                                 the initial MSS so that the application will send an entire MSS
1475   2                                 of data. This data will not be acknowledged by the receiver,
1476   2                                 and the application will retransmit it. This is called the
1477   2                                 "persistent timer" and uses the retransmission mechanim. */
1478   2                              tmp16 = ((U16_T)BUF->wnd[0] << 8) + (U16_T)BUF->wnd[1];
1479   2                              if(tmp16 > uip_connr->initialmss || tmp16 == 0) {
1480   3                                      tmp16 = uip_connr->initialmss;
1481   3                              }
1482   2                              uip_connr->mss = tmp16;
1483   2      
1484   2                              /* If this packet constitutes an ACK for outstanding data (flagged
1485   2                                 by the UIP_ACKDATA flag, we should call the application since it
1486   2                                 might want to send more data. If the incoming packet had data
1487   2                                 from the peer (as flagged by the UIP_NEWDATA flag), the
1488   2                                 application must also be notified.
1489   2      
1490   2                                 When the application is called, the global variable uip_len
1491   2                                 contains the length of the incoming data. The application can
1492   2                                 access the incoming data through the global pointer
1493   2                                 uip_appdata, which usually points 40 bytes into the uip_buf
1494   2                                 array.
1495   2      
1496   2                                 If the application wishes to send any data, this data should be
1497   2                                 put into the uip_appdata and the length of the data should be
1498   2                                 put into uip_len. If the application don't have any data to
1499   2                                 send, uip_len must be set to 0. */
1500   2                              if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
1501   3                                      uip_connr->keepalivetick = 0;
1502   3                      uip_connr->sndkeepalive = 0;
1503   3                                      uip_slen = 0;
1504   3                                      UIP_APPCALL();
1505   3      
1506   3      appsend:
1507   3                                      uip_connr = uip_conn;
1508   3      
1509   3                                      if(uip_flags & UIP_ABORT) {
1510   4                                              uip_slen = 0;
1511   4                                              uip_connr->tcpstateflags = CLOSED;
1512   4                                              BUF->flags = TCP_RST | TCP_ACK;
1513   4                                              BUF->tos = 0;
1514   4                                              goto tcp_send_nodata;
1515   4                                      }
1516   3                                      if(uip_flags & UIP_CLOSE) {
1517   4      //                              if(uip_flags == UIP_CLOSE) {
1518   4                                              uip_slen = 0;
1519   4                                              uip_connr->len = 1;
1520   4                                              uip_connr->tcpstateflags = FIN_WAIT_1;
1521   4                                              uip_connr->nrtx = 0;
1522   4                                              BUF->flags = TCP_FIN | TCP_ACK;
1523   4                                              BUF->tos = 0;
1524   4                                              goto tcp_send_nodata;   
1525   4                                      }
1526   3      
1527   3                                      if (uip_extraflag & UIP_SEND_NONE)
1528   3                                              goto drop;
1529   3      
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 26  

1530   3                                      /* If uip_slen > 0, the application has data to be sent. */
1531   3                                      if(uip_slen > 0) {
1532   4                                              /* If the connection has acknowledged data, the contents of
1533   4                                                 the ->len variable should be discarded. */ 
1534   4                                              if((uip_flags & UIP_ACKDATA) != 0) {
1535   5                                                      uip_connr->len = 0;
1536   5                                              }
1537   4      
1538   4                                              /* If the ->len variable is non-zero the connection has already 
1539   4                                                 data in transit and cannot send anymore right now. */
1540   4                                              if(uip_connr->len == 0) {
1541   5                                                      /* The application cannot send more than what is allowed by the mss
1542   5                                                         (the minumum of the MSS and the available window). */
1543   5                                                      if(uip_slen > uip_connr->mss) {
1544   6                                                              uip_slen = uip_connr->mss;
1545   6                                                      }
1546   5      
1547   5                                                      /* Remember how much data we send out now so that we know
1548   5                                                         when everything has been acknowledged. */
1549   5                                                      uip_connr->len = uip_slen;
1550   5      
1551   5                                              } else {
1552   5                                                      /* If the application already had unacknowledged data, we make sure 
1553   5                                                         that the application does not send (i.e., retransmit) out more 
1554   5                                                         than it previously sent out. */
1555   5                                                      uip_slen = uip_connr->len;
1556   5                                              }
1557   4                                      } else {
1558   4                                              uip_connr->len = 0;
1559   4                                      }
1560   3                                      uip_connr->nrtx = 0;
1561   3      apprexmit:
1562   3      
1563   3                                      uip_appdata = uip_sappdata;
1564   3            
1565   3                                      /* If the application has data to be sent, or if the incoming
1566   3                                         packet had new data in it, we must send out a packet. */
1567   3                                      if(uip_slen > 0 && uip_connr->len > 0) {
1568   4                                              /* Add the length of the IP and TCP headers. */
1569   4                                              uip_len = uip_connr->len + UIP_TCPIP_HLEN;
1570   4                                              /* We always set the ACK flag in response packets. */
1571   4                                              if (uip_extraflag & UIP_SEND_PUSH)
1572   4                                                      BUF->flags = TCP_ACK | TCP_PSH;
1573   4                                              else
1574   4                                                      BUF->flags = TCP_ACK;
1575   4      //                                      if (uip_flags & UIP_CLOSE)
1576   4      //                                              BUF->flags |= TCP_FIN;
1577   4                                              BUF->tos = uip_connr->tos;
1578   4                                              /* Send the packet. */
1579   4                                              goto tcp_send_noopts;
1580   4                                      }
1581   3                                      /* If there is no data to send, just send out a pure ACK if there is newdata. */
1582   3                                      if(uip_flags & UIP_NEWDATA) {
1583   4                                              uip_len = UIP_TCPIP_HLEN;
1584   4                                              BUF->flags = TCP_ACK;
1585   4                                              BUF->tos = uip_connr->tos;
1586   4                                              goto tcp_send_noopts;
1587   4                                      }
1588   3                              }
1589   2                              goto drop;
1590   2      
1591   2                      case LAST_ACK:
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 27  

1592   2                              /* We can close this connection if the peer has acknowledged our 
1593   2                                 FIN. This is indicated by the UIP_ACKDATA flag. */     
1594   2                              if(uip_flags & UIP_ACKDATA) {
1595   3                                      uip_connr->tcpstateflags = CLOSED;
1596   3                                      uip_flags = UIP_CLOSE;
1597   3                                      UIP_APPCALL();
1598   3                              }
1599   2                              break;
1600   2          
1601   2                      case FIN_WAIT_1:
1602   2                              /* The application has closed the connection, but the remote host
1603   2                                 hasn't closed its end yet. Thus we do nothing but wait for a
1604   2                                 FIN from the other side. */
1605   2                              if(uip_len > 0) {
1606   3                                      uip_add_rcv_nxt(uip_len);
1607   3                              }
1608   2                              if(BUF->flags & TCP_FIN) {
1609   3                                      if(uip_flags & UIP_ACKDATA) {
1610   4                                              uip_connr->tcpstateflags = TIME_WAIT;
1611   4                                              uip_connr->timer = 0;
1612   4                                              uip_connr->len = 0;
1613   4                                      } else {
1614   4                                              uip_connr->tcpstateflags = CLOSING;
1615   4                                      }
1616   3                                      uip_add_rcv_nxt(1);
1617   3                                      uip_flags = UIP_CLOSE;
1618   3                                      UIP_APPCALL();
1619   3                                      BUF->tos = 0;
1620   3                                      goto tcp_send_ack;
1621   3                              } else if(uip_flags & UIP_ACKDATA) {
1622   3                                      uip_connr->tcpstateflags = FIN_WAIT_2;
1623   3                                      uip_connr->len = 0;
1624   3                                      goto drop;
1625   3                              }
1626   2                              if(uip_len > 0) {
1627   3                                      BUF->tos = 0;
1628   3                                      goto tcp_send_ack;
1629   3                              }
1630   2                              goto drop;
1631   2            
1632   2                      case FIN_WAIT_2:
1633   2                              if(uip_len > 0) {
1634   3                                      uip_add_rcv_nxt(uip_len);
1635   3                              }
1636   2                              if(BUF->flags & TCP_FIN) {
1637   3                                      uip_connr->tcpstateflags = TIME_WAIT;
1638   3                                      uip_connr->timer = 0;
1639   3                                      uip_add_rcv_nxt(1);
1640   3                                      uip_flags = UIP_CLOSE;
1641   3                                      UIP_APPCALL();
1642   3                                      BUF->tos = 0;
1643   3                                      goto tcp_send_ack;
1644   3                              }
1645   2                              if(uip_len > 0) {
1646   3                                      BUF->tos = 0;
1647   3                                      goto tcp_send_ack;
1648   3                              }
1649   2                              goto drop;
1650   2      
1651   2                      case TIME_WAIT:
1652   2                              BUF->tos = 0;
1653   2                              goto tcp_send_ack;
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 28  

1654   2          
1655   2                      case CLOSING:
1656   2                              if(uip_flags & UIP_ACKDATA) {
1657   3                                      uip_connr->tcpstateflags = TIME_WAIT;
1658   3                                      uip_connr->timer = 0;
1659   3                              }
1660   2              }
1661   1              goto drop;
1662   1        
1663   1      
1664   1              /* We jump here when we are ready to send the packet, and just want
1665   1                 to set the appropriate TCP sequence numbers in the TCP header. */
1666   1      tcp_send_ack:
1667   1              BUF->flags = TCP_ACK;
1668   1              tcp_send_nodata:
1669   1              uip_len = 40;
1670   1              tcp_send_noopts:
1671   1              BUF->tcpoffset = 5 << 4;
1672   1              tcp_send:
1673   1              /* We're done with the input processing. We are now ready to send a reply.
1674   1                 Our job is to fill in all the fields of the TCP and IP headers before
1675   1                 calculating the checksum and finally send the packet. */
1676   1              BUF->seqno[0] = uip_connr->snd_nxt[0];
1677   1              BUF->seqno[1] = uip_connr->snd_nxt[1];
1678   1              BUF->seqno[2] = uip_connr->snd_nxt[2];
1679   1              BUF->seqno[3] = uip_connr->snd_nxt[3];
1680   1      
1681   1      tcp_keepalive:
1682   1              BUF->ackno[0] = uip_connr->rcv_nxt[0];
1683   1              BUF->ackno[1] = uip_connr->rcv_nxt[1];
1684   1              BUF->ackno[2] = uip_connr->rcv_nxt[2];
1685   1              BUF->ackno[3] = uip_connr->rcv_nxt[3];
1686   1      
1687   1              BUF->proto = UIP_PROTO_TCP;
1688   1        
1689   1              BUF->srcport  = uip_connr->lport;
1690   1              BUF->destport = uip_connr->rport;
1691   1      
1692   1              BUF->srcipaddr[0] = uip_hostaddr[0];
1693   1              BUF->srcipaddr[1] = uip_hostaddr[1];
1694   1              BUF->destipaddr[0] = uip_connr->ripaddr[0];
1695   1              BUF->destipaddr[1] = uip_connr->ripaddr[1];
1696   1      
1697   1              if(uip_connr->tcpstateflags & UIP_STOPPED) {
1698   2                      /* If the connection has issued uip_stop(), we advertise a zero
1699   2                         window so that the remote host will stop sending data. */
1700   2                      BUF->wnd[0] = BUF->wnd[1] = 0;
1701   2              } else {
1702   2                      BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
1703   2                      BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff); 
1704   2              }
1705   1      
1706   1      tcp_send_noconn:
1707   1              BUF->len[0] = (uip_len >> 8);
1708   1              BUF->len[1] = (uip_len & 0xff);
1709   1              BUF->urgp[0] = 0;
1710   1              BUF->urgp[1] = 0;
1711   1      
1712   1              /* Calculate TCP checksum. */
1713   1              BUF->tcpchksum = 0;
1714   1      #if (!CHECKSUM_OFFLOAD)
                      BUF->tcpchksum = ~(uip_tcpchksum());
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 29  

              #endif
1717   1      
1718   1      ip_send_nolen:
1719   1      
1720   1              BUF->vhl = 0x45;
1721   1              if (TCPIP_DontFrag == TCPIP_DONT_FRAGMENT)
1722   1                      BUF->ipoffset[0] = 0x40;
1723   1              else
1724   1                      BUF->ipoffset[0] = 0;
1725   1              BUF->ipoffset[1] = 0;
1726   1              BUF->ttl  = UIP_TTL;
1727   1              ++ipid;
1728   1              BUF->ipid[0] = ipid >> 8;
1729   1              BUF->ipid[1] = ipid & 0xff;
1730   1        
1731   1              /* Calculate IP checksum. */
1732   1              BUF->ipchksum = 0;
1733   1      #if (!CHECKSUM_OFFLOAD)
                      BUF->ipchksum = ~(uip_ipchksum());
              #endif
1736   1      
1737   1              UIP_STAT(++uip_stat.tcp.sent);
1738   1      
1739   1      send:
1740   1      
1741   1              UIP_STAT(++uip_stat.ip.sent);
1742   1      
1743   1              /* Return and let the caller do the actual transmission. */
1744   1              return;
1745   1      
1746   1      drop:
1747   1      
1748   1              uip_len = 0;
1749   1              return;
1750   1      }
1751          
1752          /*-----------------------------------------------------------------------------------*/
1753          
1754          U16_T htons(U16_T val)
1755          {
1756   1              return HTONS(val);
1757   1      }
1758          
1759          /*-----------------------------------------------------------------------------------*/
1760          
1761          #if UIP_LOGGING == 1
              void uip_log(char *msg)
              {
                      printf("%s\n\r", msg);
              }
              #endif
1767          /** @} */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14129    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2503      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     79    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.01   UIP                                                                   08/29/2011 15:27:54 PAGE 30  

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
